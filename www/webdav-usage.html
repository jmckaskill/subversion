<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Use of WebDAV in Subversion</title>
  </head>

  <body bgcolor=white>
    <h1>Use of WebDAV in Subversion</h1>

    <p>
      This document details how WebDAV is used within the
      <a href="http://subversion.tigris.org/">Subversion
      product</a>. Specifically, how the client side interfaces with
      <a href="http://www.webdav.org/neon/">Neon</a> to generate
      WebDAV requests over the wire, and what the
      server must do to map incoming WebDAV requests into operations
      against the Subversion repository. Note that the server side is
      implemented as an
      <a href="http://www.apache.org/httpd">Apache 2.0</a> module,
      operating as a back-end for its mod_dav functionality.
    </p>
    <p>
      This document heavily refers to the
      <a href="http://subversion.tigris.org/svn-design.html">Subversion
	design document</a> and the
      <a href="http://www.webdav.org/deltav/">latest Delta-V protocol
	draft</a>. Details of those documents will <em>not</em> be
      replicated here.
    </p>

    <hr width="80&#37;">
    <h2>Basic Concepts</h2>
    <p>
      Subversion uses a tree-based format to describe a change set
      against the repository. This tree is constructed on the client
      side to describe the change. It is then marshalled to the
      server, reconstructed, and applied against the
      repository. However, WebDAV uses a sequence of changes. As a
      result, we must map from the tree form to a sequence of WebDAV
      requests, send them over the wire, then reconstruct the tree
      form on the server for application to the repository.
    </p>
    <p>
      In addition, Subversion applies a change set in two steps. It
      sends a "skeleton delta", or "skelta", to the server as a
      preflight test to check whether the change set can be
      applied. The server then returns a token to be passed back along
      with the final delta. The combination of a token and the
      complete delta completes the process, and the change set is
      applied to the repository.
    </p>
    <p>
      Subversion also provides properties on files, directories, and
      even the abstract concept of a version. Each of the operations
      involving properties will be mapped directly to WebDAV
      properties, which are manipulated with the <code>PROPFIND</code>
      and <code>PROPPATCH</code> HTTP methods. To enable properties on
      abstract versions, the Subversion Apache module will publish a
      URL namespace containing resources for each version. The
      per-version properties will be maintained on these resources.
    </p>
    <p>
      Subversion specifies that the server will compute deltas between
      two versions. Presumably, the server can create the delta much
      more efficiently than a client performing a sequence of
      <code>PROPFIND</code> requests. This feature will be implemented
      using the <code>DAV:compare-report</code> report option. If the
      client is performing an actual update, then a series of GET
      operations will be performed to fetch the files which have
      changed.
    </p>
    <p>
      Tags and branches are handled through the WebDAV
      <code>LABEL</code> and <code>COPY</code> methods as appropriate.
    </p>

    <hr width="80&#37;">
    <h2>Subversion Projects as URLs</h2>
    <p>
      The very first concept to define is how a project is exposed to
      the client. Subversion will expose all projects as URLs on a
      server. The files and subdirectories under this project will be
      exposed through the URL namespace.
    </p>
    <p>
      For example, let us assume that we have a project named
      "example". And let us say that this project will be exposed at
      the URL: <code>http://subversion.tigris.org/example/</code>.
    </p>
    <p>
      This mapping will be set up through a set of configuration
      parameters for the Apache HTTPD server (which is hosting the
      Subversion code and the particular project in question). The
      configuration might look like:
    </p>
    <blockquote>
<pre>&lt;Location /example&gt;
    DAV subversion
    SVNPath /home/svn-projects/example
&lt;/Location&gt;</pre>
    </blockquote>
    <p>
      Files and directories within the project will be directly mapped
      to the URL namespace. For example, if the project contains a
      file "file.c" in a subdirectory "sub", then the URL for that
      file will be
      <code>http://subversion.tigris.org/example/sub/file.c</code>.
    </p>

    <hr width="80&#37;">
    <h2>Committing a Change Set</h2>
    <p>
      Change sets are modelled using the "activity" concept from
      WebDAV. An activity can be viewed as a transaction for a set of
      resources.
    </p>
    <h3>Creating the activity</h3>
    <p>
      At the start of a commit, the client will issue a
      <code>REPORT</code> method for a
      <code>DAV:repository-report</code> to determine where the
      activity should be created. Next, the client will generate a
      UUID (a unique value) to use for the activity's
      location. Finally, the client will issue a
      <code>MKACTIVITY</code> method request, where the URL is
      composed from the URL returned by the
      <code>repository-report</code> and the UUID. The request will
      construct an activity to hold all of the changes for the commit.
    </p>
    <p>Abbreviated summary:</p>
    <dl>
      <dt>Request: REPORT, DAV:repository-report</dt>
      <dd>Response: http://www.example.com/$svn/act/</dd>
      <dt>Request: MKACTIVITY,
	http://www.example.com/$svn/act/01234567-89ab-cdef-0123-456789abcdef</dt>
      <dd>Response: 201, created</dd>
    </dl>
    <p>
      The (advanced) <code>CHECKOUT</code> method has a way to specify 
      an activity upon checkout. This feature will be used to
      associate all items with the newly-created activity.
    </p>
    
    <h3>Mapping changes to WebDAV</h3>
    <p>
      A change set in Subversion is specified with a "tree delta" (see
      the SVN design for more details on the changes that can be
      placed into a tree delta). The tree delta will be unravelled
      into a set of requests. These requests will be one of the
      following forms:
    </p>
    <dl>
      <dt>Delete file/directory</dt>
      <dd>
	This will be mapped to a <code>DELETE</code> operation. The
	target will be checked out using <code>CHECKOUT</code>, then
	the working resource will be deleted using
	<code>DELETE</code>.
	<p>
	  Note that the versioning protocol draft states the result of
	  deleting a working resource is undefined. Subversion will
	  define this as "the version selector corresponding to the
	  working resource will be deleted upon <code>CHECKIN</code>
	  (or <code>MERGE</code>)."
	</p>

	<p>
	  Note: this implicitly changes the directory containing the
	  deleted file/dir. These changes will be integrated at
	  <code>MERGE</code> time. Effectively, we are assuming the
	  directory has <code>DAV:auto-version</code> enabled on it,
	  allowing the change to the set of bindings within the
	  directory. It may turn out that we will need to perform a
	  <code>CHECKOUT</code> on the directory itself before doing
	  the <code>DELETE</code>.
	</p>
      </dd>

      <dt>New file</dt>
      <dd>
	This is modeled by performing a <code>CHECKOUT</code> on the
	target directory. The new file is created within the
	directory's working resource with a <code>PUT</code>, or a
	directory can be created there using a <code>MKCOL</code>
	request.

	<p></p>
      </dd>

      <dt>New file/directory, previous ancestory</dt>
      <dd>
	A tree delta can specify that a file/directory originates as a
	copy of another file/dir. Further, this copy may be modified
	by additional elements the tree delta.

	<p>
	  This change will be modeled by performing a
	  <code>CHECKOUT</code> on the directory containing the new
	  file/directory. A <code>COPY</code> of the version selector
	  (of the original file/dir) into the target directory will
	  establish the ancestry. The resource created by the
	  <code>COPY</code> will become a new working resource, thus
	  becoming a target for additional changes.
	</p>
      </dd>

      <dt>Replace file</dt>
      <dd>
	This is modeled with a <code>CHECKOUT</code> on the target
	file, followed by a <code>PUT</code> to the working resource.

	<p></p>
      </dd>

      <dt>Replace file with another file</dt>
      <dd>
	This operation is performed by using a <code>CHECKOUT</code>
	on the target, then using <code>COPY</code> to copy the source
	file (a version selector) over the working resource. The
	<code>COPY</code> establishes the proper ancestry for the
	file.
	<p>
	  Note that the source of the <code>COPY</code> is the version 
	  selector. This makes it possible to swap files arbitrarily
	  since the source (the version selectors) will not change
	  until <code>MERGE</code> time.
	</p>
      </dd>

      <dt>Replace directory</dt>
      <dd>
	In Subversion terms, "replace directory" means that additions, 
	deletions, and other changes will occur <em>within</em> the
	directory. Each of these changes are modeled individually, and 
	the change to the directory is performed
	implicitly. Therefore, this "change" has no particular mapping 
	into WebDAV.

	<p></p>
      </dd>

      <dt>Replace directory with another directory/file</dt>
      <dd>
	When a directory is <em>replaced</em>, rather than simply
	modified, we use the <code>COPY</code> method to copy a
	resource over the replaced directory. As usual, the directory
	to be replaced is checked out first, using
	<code>CHECKOUT</code>. The <code>COPY</code> will specify
	<code>Overwrite:&nbsp;T</code> header to overwrite the
	checked-out directory.

	<p></p>
      </dd>

      <dt>Property delta</dt>
      <dd>
	A property delta (against a file or directory) maps directly
	to a <code>PROPPATCH</code> in WebDAV terms. Before applying a 
	<code>PROPPATCH</code>, the target file/directory will be
	checked out using <code>CHECKOUT</code>
      </dd>
    </dl>

    <p>
      Note that file "moves" are modeled using <code>COPY</code> to
      establish the linkage between the new/old files/directories,
      followed by a <code>DELETE</code> to remove the old
      file/directory.
    </p>

    <h3>Skeleton Deltas</h3>
    <p>
      As mentioned above, Subversion uses a two-pass system during a
      commit. The first pass will create the activity, perform all the 
      necessary <code>CHECKOUT</code> operations, and then perform a
      number of <code>DELETE</code>, <code>COPY</code>, and
      <code>MKCOL</code> requests against the working resources. To
      keep the wire bandwidth small, <code>PROPPATCH</code> and
      <code>PUT</code> requests will be minimized:
    </p>
    <dl>
      <dt><code>PROPPATCH</code> skeleton</dt>
      <dd>
	To provide a quick test of whether a <code>PROPPATCH</code> is
	allowed against the target resource, the client will issue the
	<code>PROPPATCH</code> with a <code>DAV:remove</code> element
	for a custom, predefined Subversion property (which will never
	exist). This will "exercise" the access rights for property
	changes. At commit time, the property-delta will be mapped
	into a complete <code>PROPPATCH</code>.
	<p>
	  Note that DAV says it is okay to remove a property that
	  doesn't exist. Effectively, the removal of the property will 
	  always be a null operation.
	</p>
      </dd>

      <dt><code>PUT</code> skeleton</dt>
      <dd>
	The client will issue a zero-length <code>PUT</code> request
	against the working resource. When the final commit is
	performed, another <code>PUT</code> will be performed with the 
	entire file contents.
	<p></p>
      </dd>
    </dl>

    <h3>Final Commit</h3>
    <p>
      The final action of the commit process is to issue a
      <code>MERGE</code> request to the Subversion server, specifying
      that the activity (created earlier) be merged into the
      corresponding versioned resources.
    </p>

    <h3>Example</h3>
    <p>
      Consider the following set of operations and its corresponding
      tree delta (taken from the SVN design document):
    </p>
    <ol type=1 start=1>
      <li>rename <code>/dir1/dir2</code> to <code>/dir1/dir4</code>,</li>
      <li>rename <code>/dir1/dir3</code> to <code>/dir1/dir2</code>, and</li>
      <li>move <code>file3</code> from <var>/dir1/dir4</var> to <var>/dir1/dir2</var>.</li>
    </ol>
<pre>&lt;tree-delta&gt;
  &lt;replace name='dir1'&gt;
    &lt;directory&gt;
      &lt;tree-delta&gt;
        &lt;replace name='dir2'&gt;
          &lt;directory ancestor='/dir1/dir3'&gt;         (1)
            &lt;tree-delta&gt;
              &lt;new name='file3'&gt;                    (2)
                &lt;file ancestor='/dir1/dir2/file3'/&gt;
              &lt;/new&gt;
            &lt;/tree-delta&gt;
          &lt;/directory&gt;
        &lt;/replace&gt;
        &lt;delete name='dir3'/&gt;                       (3)
        &lt;new name='dir4'&gt;                           (4)
          &lt;directory ancestor='/dir1/dir2'&gt;
            &lt;tree-delta&gt;
              &lt;delete name='file3'/&gt;                (5)
            &lt;/tree-delta&gt;
          &lt;/directory&gt;
        &lt;/new&gt;
      &lt;/tree-delta&gt;
    &lt;/directory&gt;
  &lt;/replace&gt;
&lt;/tree-delta&gt;
</pre>

    <p>
      Walking through this delta, we map out the WebDAV requests
      listed below. The numbers in the above delta roughly correspond
      to the numbered entries below. The correspondence is not exact
      because a specific, resulting behavior is typically based on a
      combination of a few elements in the delta.
    </p>
    <ol>
      <li>
	The <code>&lt;directory ancestor="/dir1/dir3"&gt;</code>
	specifies that we are overwriting <code>/dir1/dir2</code> with 
	<code>/dir1/dir3</code>.
	<p>
	  <code>CHECKOUT&nbsp;/dir1/dir2/</code><br>
	  <i>(returns a working resource URL for the directory)</i>
	</p>
	<p>
	  <code>COPY&nbsp;/dir1/dir3/</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/.../</code><br>
	  <code>Overwrite:&nbsp;T</code>
	</p>
      </li>
      <li>
	<code>/dir1/dir2/file3</code> is new (since we just overwrote
	the original <code>dir2</code> directory), and originates from
	<code>/dir1/dir2/file3</code>. Thus, we simply
	<code>COPY</code> the file into the target directory's working 
	resource:
	<p>
	  <code>COPY&nbsp;/dir1/dir2/file3</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/.../file3</code>
	</p>
      </li>
      <li>
	<code>CHECKOUT&nbsp;/dir1/dir3/</code><br>
	<i>(returns a working resource URL for the directory)</i>
	<p>
	  <code>DELETE&nbsp;/$svn/wr/.../</code>
	</p>
      </li>
      <li>
	We are going to  creating a new subdirectory (<code>dir4</code>) in the
	<code>/dir1</code> directory. Since we don't have
	<code>/dir1</code> checked out yet, we do so:
	<p>
	  <code>CHECKOUT&nbsp;/dir1/</code><br>
	  <i>(returns a working resource URL for the directory)</i>
	</p>
	<p>
	  And now we copy the right directory into the new working
	  resource:
	</p>
	<p>
	  <code>COPY&nbsp;/dir1/dir2/</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/.../dir4/</code>
	</p>
      </li>
      <li>
	The <code>COPY</code> created a complete set of working
	resources on the server, so we simply delete the part that we
	don't want:
	<p>
	  <code>DELETE:&nbsp;/$svn/wr/.../dir4/file3</code>
	</p>
      </li>
    </ol>

    <hr width="80&#37;">
    <h2>URL Layout</h2>
    <p>
      The Subversion server exposes projects at user-defined URLs. For
      example, the "foo" project might be located at
      <code>http://www.example.com/foo/</code>. However, the server
      also requires a number of other resources to be exposed for
      proper operation. These additional resources can be specified on 
      a per-project basis, but will typically be defined on a
      server-wide basis. The <code>SVNAuxLocation</code> directive is
      used to define the location of these auxilliary resources:
      </p>
    <blockquote>
<pre>&lt;Location /example&gt;
    DAV subversion
    SVNPath /home/svn-projects/example
    SVNAuxLocation /$svn
&lt;/Location&gt;</pre>
    </blockquote>
    <p>
      Underneath the location specified by
      <code>SVNAuxLocation</code>, we will expose several
      collections. Assuming we use the example of <code>/$svn</code>,
      the collections are:
    </p>
    <dl>
      <dt><code>/$svn/act/</code></dt>
      <dd>
	This area is where activity resources are created. The client
	will pick a unique name within this collection and issue a
	<code>MKACTIVITY</code> for that URL. The client will then use 
	the activity in further interactions.
	<p>
	  No methods are allowed on the <code>/$svn/act/</code> URL.
	</p>
	<p>
	  Only a subset of methods are allowed on the activities
	  within the collection. They are: <code>PROPFIND</code>,
	  <code>MERGE</code>, and <code>DELETE</code>.
	</p>
	<p>
	  Per the Delta-V specification, all activity resources will
	  have a <code>DAV:resourcetype</code> of
	  <code>DAV:activity</code>.
	</p>
      </dd>
      
      <dt><code>/$svn/his/</code></dt>
      <dd>
	This collection contains the version history resources for
	files and directories in a project. Its internal layout is
	completely server-defined. Clients will receive URLs into this 
	collection (or a subcollection) from various responses.
	<p>
	  No methods are allowed on the <code>/$svn/his/</code> URL.
	</p>
	<p>
	  Internally, the URL namespace is laid out with URLs of the
	  following form:
	</p>
	<blockquote>
	  <code>/$svn/his/<var>project-id</var>/<var>node-id</var>/<var>version</var></code>
	</blockquote>
	<p>
	  The <var>project-id</var> is a unique identifier assigned to
	  each Subversion project that is located within this history
	  URL namespace. The <var>node-id</var> is an internal value
	  that Subversion uses to reference individual files and
	  directories. The <var>version</var> portion is used to refer 
	  to specific versions of a resource.
	</p>
	<p>
	  The <code>DAV:resourcetype</code> of the <var>node-id</var>
	  collection is <code>DAV:version-history</code>. The resource 
	  which includes the version is a <code>DAV:???</code> (this
	  has not been defined in the Delta-V spec)
	</p>
      </dd>

      <dt><code>/$svn/ver/</code></dt>
      <dd>
	This collection contains resources for each version of a
	project. This resource can then be used for storing and
	fetching information about a version as a whole (rather than
	from a particular file or directory).
	<p>
	  No methods are allowed on the <code>/$svn/ver/</code> URL.
	</p>
	<p>
	  The layout of this collection is internal to the server. For 
	  reference purposes here (and to describe the
	  implementation), it is laid out as:
	</p>
	<blockquote>
	  <code>/$svn/ver/<var>project-id</var>/<var>version</var></code>
	</blockquote>
	<p>
	  <code>PROPFIND</code> and <code>PROPPATCH</code> are allowed 
	  against these URLs, but all other methods are illegal.
	</p>
	<p>
	  All version resources (for the files and directories in a
	  project) have a live property with a URL referring to the
	  whole-project version resource. This property is named
	  <code>SVN:project-version</code> (???, TBD) and is
	  constructed according to:
	</p>
	<blockquote>
	  <code>&lt;!ELEMENT project-version (href)&gt;</code>
	</blockquote>
	<p>
	  The <code>DAV:resourcetype</code> of the project version
	  resources is <code>SVN:project-version</code> (???, TBD).
	</p>
      </dd>

      <dt><code>/$svn/wr/</code></dt>
      <dd>
	This collection contains working resources for the resources
	that have been checked out with the <code>CHECKOUT</code>
	method. The form and construction of this collection is
	server-defined, but is also well-defined so that clients may
	interact properly with versioned collections that have been
	checked out.
	<p>
	  No methods are allowed on the <code>/$svn/wr/</code> URL.
	</p>
	<p>
	  The <code>DAV:resourcetype</code> of the working resources
	  is <code>DAV:???</code> (this has not been defined in the
	  Delta-V spec)
	</p>
      </dd>
    </dl>

    <hr width="80&#37;">
    <h2>Property Management (and History/Log Reporting)</h2>
    <p>
      As mentioned before, Subversion properties map onto WebDAV
      properties. There are particular properties that the WebDAV code 
      wants to take particular care of:
    </p>
    <dl>
      <dt><code>DAV:comment</code></dt>
      <dd>
	This is the standard property for specifying a checkin
	comment. These properties will be attached to the project
	version resources in the <code>/$svn/ver/</code> collection.
	<p></p>
      </dd>
      <dt><code>DAV:creator-displayname</code></dt>
      <dd>
	This is a live property that is generated from Subversion's
	concept of the "user" who made a particular change. It is a
	read-only property.
	<p></p>
      </dd>
      <dt><code>DAV:checkin-date</code></dt>
      <dd>
	This is a read-only live property maintained by the server on
	version resources. Strictly speaking, it is only maintained on 
	the project-version resources, but the Delta-V specification
	states that it is exposed on every version resource.
      </dd>
    </dl>
    <p>
      The history for a specified file will be generated using the
      <code>REPORT</code> method and a
      <code>DAV:property-report</code> report. A typical history will
      fetch the three properties mentioned above for each version of
      the file/directory.
    </p>
    <p>
      Based on the client design, it may be important to specify other 
      read-only live properties for information about versions. For
      examply, how many lines were added/removed in a particular
      checkin for a file? Creating these live properties will be quite 
      straight-forward, and driven by the client design over time.
    </p>

    <hr width="80&#37;">
    <h2>Fetching Status and Updates</h2>
    <p>
      The Subversion design discusses the use of skeleton deltas and
      deltas to return status and update information (see
      <code>ra_get_status()</code> and
      <code>ra_get_update()</code>). However, the appropriate
      mechanism to use in WebDAV is a <code>PROPFIND</code> on a file,
      directory, or tree to fetch the <code>DAV:target</code>
      property. The <code>DAV:target</code> property will specify the
      URL of the version the version-selector is referring to. If the
      URL matches the value stored in the working copy, then no
      changes were made in the repository.
    </p>
    <p>
      It is presumed that the working copy library can detect local
      modifications to a file, and local tree structure changes. The
      important part is when the local library needs to consult the
      server to look for server-side changes.
    </p>
    <p>
      Updates are handled similarly, then followed by a sequence of
      <code>GET</code> operations to fetch the new files.
    </p>
    <p>
      <code>GET</code> (and <code>PUT</code>) operations will transfer 
      content in a "diff" format when possible. The mechanics of this
      will follow the Internet Draft, titled
      <a href="http://www.ietf.org/internet-drafts/draft-mogul-http-delta-07.txt">Delta Encoding in HTTP</a>.
    </p>

    <h3>Entity Tags (etags)</h3>
    <p>
      Etags are required to be unique across all versions of a
      resource and across all resources on the server. Luckily, this
      is very easy for a version control system. Each etag will be
      constructed as a tuple pair of (<code>projectId</code>,
      <code>nodeId</code>).
    </p>
    <p>
      Etags are used to generate diffs, following the guidelines in
      the aforementioned draft:
      <a href="http://www.ietf.org/internet-drafts/draft-mogul-http-delta-07.txt">Delta Encoding in HTTP</a>.
      The problem then becomes how to get the etag for each file and
      directory revision stored on the client. During a
      <em>checkout</em> or <em>update</em> process, this is easy: the
      etag is provided in the HTTP response headers for each
      file retrieved. If etags are needed for directories, then they
      can be retrieved via <code>PROPFIND</code> (or possibly through
      a <code>REPORT</code> or during a sequence of
      <code>PROPFIND</code>s to traverse the server).
    </p>
    <p>
      The harder part is getting the etag after a <em>commit</em> has
      occurred. The <code>MERGE</code> response does not provide an
      obvious way to return the updated etag for each merged file. The
      <code>MERGE</code> method could be updated, or possibly the
      client will issue a <code>REPORT</code> after the merge is
      complete.
      <br>
      <i>This issue is still open and pending research. Until then,
	etags will not (always) be available to the client for
	fetching a diff from the server during an update.</i>
    </p>

    <hr width="80&#37;">
    <h2>Tags and Branches</h2>
    <p>
      The current Subversion design specification is not entirely
      clear on how tagging and branching will be performed. For the
      most part, all branching will be handled by copying source trees 
      to another location in the repository.
    </p>
    <p>
      <small>
	Note: the copies are actually by reference, rather than a
	complete duplication of the source.
      </small>
    </p>
    <p>
      Copies are handled just like a regular commit. An activity is
      created with <code>MKACTIVITY</code>, a working resource is
      created via <code>CHECKOUT</code> (for the target directory),
      and then a <code>COPY</code> is performed. The activity is then
      merged back into the repository with a <code>MERGE</code>
      request.
    </p>
    <p>
      <i>Note: we may be able to simplify all of this by simply
	assuming that <code>DAV:auto-version</code> is set and doing a 
	single <code>COPY</code> operation to the target area. Some
	investigation/thought is needed here.</i>
    </p>
    <h3>Tags/Labels</h3>
    <p>
      Subversion does not have any specific design yet for tagging or
      labeling specific versions of the repository. Presumably, this
      would be performed by the client through some kind of property
      operation.
    </p>
    <p>
      Whatever the client/server ends up using for its design, all
      labeling requests will be mapped into <code>PROPFIND</code> and
      <code>LABEL</code> requests. The former for label discovery
      (read the <code>DAV:label-name-set</code> property), and the
      latter for applying, changing, and removing labels from
      versions.
    </p>
    <p>
      As mentioned before, we expose properties for the abstract
      concept of a version. Those resources could be used for applying
      label information to the entire repository, rather than on a
      per-file basis. The exact needs here will be dependent upon the
      model chosen by the server to represent the different types of
      labels and how they can be applied to the
      repository. Nevertheless, the mapping should be straight
      forward.
    </p>

    <hr width="80&#37;">
    <h2>Server Requirements</h2>
    <h3>DAV Methods</h3>
    <p>
      The server will need to implement the following WebDAV methods
      for proper operation:
    </p>
    <ul>
      <li><code>MKACTIVITY</code></li>
      <li><code>CHECKOUT</code></li>
      <li><code>PROPPATCH</code></li>
      <li><code>PROPFIND</code></li>
      <li><code>DELETE</code></li>
      <li><code>COPY</code></li>
      <li><code>MERGE</code></li>
      <li><code>REPORT</code></li>
      <li><code>LABEL</code></li>
    </ul>
    <p>
      The following "core versioning" methods are not required by
      Subversion at this time:
      <code>VERSION-CONTROL</code>,
      <code>CHECKIN</code>,
      <code>UNCHECKOUT</code>,
      and
      <code>SET-TARGET</code>.
      The following "advanced versioning" methods are not required by
      Subversion at this time:
      <code>MKWORKSPACE</code>,
      and
      <code>BASELINE-CONTROL</code>.
    </p>

    <h3>DAV Properties</h3>
    <p>
      All of the "core versioning" properties will be implemented:
    </p>
    <ul>
      <li><code>DAV:creator-displayname</code></li>
      <li><code>DAV:comment</code></li>
      <li><code>DAV:target</code></li>
      <li><code>DAV:auto-version</code> is set to <code>F</code></li>
      <li>
	<code>DAV:version-name</code> is simply the (global) version
	number
      </li>
      <li><code>DAV:version</code></li>
      <li>
	<code>DAV:predecessor-set</code>
	<br>
	<i>
	  Note: the Subversion design document is not clear on the
	  mechanics of how multiple predecessors are merged to create
	  a single, new version. When this clarifies, then
	  <code>DAV:predecessor-set</code> may end up containing more
	  than zero or one predecessor URLs
	</i>
      </li>
      <li><code>DAV:checkin-date</code></li>
      <li><code>DAV:label-name-set</code></li>
      <li><code>DAV:checked-out</code></li>
    </ul>
    <p>
      The following "advanced versioning" properties will be
      implemented:
    </p>
    <ul>
      <li><code>DAV:version-history</code></li>
      <li>
	<code>DAV:checkout-fork</code> (protected) is set to
	<code>DAV:discouraged</code>
      </li>
      <li>
	<code>DAV:checkin-fork</code> (protected) is set to
	<code>DAV:discouraged</code>
      </li>
      <li><code>DAV:version-set</code></li>
      <li><code>DAV:initial-version</code></li>
      <li><code>DAV:unreserved</code> (protected) is set to <code>F</code></li>
    </ul>

    <h3>OPTIONS</h3>
    <p>
      The <code>OPTIONS</code> request will signal that it supports
      the following DAV features:
    </p>
    <ul>
      <li><code>1</code></li>
      <li><code>2</code></li>
      <li><code>core-versioning</code></li>
      <li><code>property-report</code></li>
      <li><code>activity</code></li>
      <li><code>mkactivity</code></li>
      <li><code>merge</code></li>
      <li><code>collection-versioning</code></li>
      <li><code>checkout-fork</code></li>
      <li><code>checkin-fork</code></li>
    </ul>
    <p>
      The <code>REPORT</code> method and
      <code>DAV:available-report</code> report will signal support for 
      the following reports:
      <code>DAV:available-report</code>,
      <code>DAV:repository-report</code>,
      <code>DAV:property-report</code>,
      and
      <code>DAV:compare-report</code>.
    </p>

    <h3>Notes, reminders</h3>
    <p>
      Advanced CHECKOUT to associate an activity with the working
      resource.
      <br>
      COPY into a checked-out collection must create new working
      resources (recursively).
      <br>
      Add SVN:test-proppatch (live) property.
      <br>
      <var>project-id</var> must be generated and kept permanently
      with a Subversion project.
      <br>
      Discuss timeouts and auto-purge of activities (and the related
      working resources).
      <br>
      Need a database to map working resource URLs to some semantic
      info about those working resources, and the activities they are
      a part of.
      <br>
      Need a database to map activity URLs to their relevant
      information.
    </p>

    <hr>
    <address><a href="mailto:gstein@lyra.org">Greg Stein</a></address>
<!-- Created: Thu Aug 10 19:14:20 PDT 2000 -->
<!-- hhmts start -->
Last modified: Sat Aug 26 02:05:09 PDT 2000
<!-- hhmts end -->
  </body>
</html>
