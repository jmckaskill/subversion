  Heap overflow in Subversion client and server

Summary:
========

  Clients with commit access to a vulnerable server can cause a remote heap overflow.
  Servers can cause a heap overflow on vulnerable clients that try to do a checkout or
  update.

Known vulnerable:
=================

  Subversion clients and servers <= 1.6.3.

Known fixed:
============

  Subversion 1.6.4

  (Search for "Patch" below to see the patch from 1.6.3 -> 1.6.4.
   Search for "Recommendations" to get URLs for the 1.6.4 release.)

Details:
========

  The libsvn_delta library does not contain sufficient input validation
  of svndiff streams.  If a stream with large windows is processed,
  one of several integer overflows may lead to some boundary checks incorrectly
  passing, which in turn can lead to a heap overflow.

Severity:
=========

  A remote attacker with commit access to repository may be able to
  execute code on a Subversion server.  A malicious server may be able to
  execute code on a Subversion client.

Recommendations:
================

We recommend all users to upgrade to 1.6.4.

References:
===========

  CVE-2009-2411

Reported by:
============

  Matt Lewis, Google.

Recommendations:
================

  Upgrade to Subversion 1.6.4:

  http://subversion.tigris.org/project_packages.html

Patch:
======

  This patch applies to Subversion 1.6.x:

Index: libsvn_delta/svndiff.c
===================================================================
--- libsvn_delta/svndiff.c	(revision 38477)
+++ libsvn_delta/svndiff.c	(working copy)
@@ -487,7 +487,7 @@
         return svn_error_createf
           (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
            _("Invalid diff stream: insn %d cannot be decoded"), n);
-      else if (op.length <= 0)
+      else if (op.length == 0)
         return svn_error_createf
           (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
            _("Invalid diff stream: insn %d has non-positive length"), n);
@@ -499,7 +499,8 @@
       switch (op.action_code)
         {
         case svn_txdelta_source:
-          if (op.length > sview_len - op.offset)
+          if (op.length > sview_len - op.offset ||
+              op.offset > sview_len)
             return svn_error_createf
               (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
                _("Invalid diff stream: "
@@ -685,6 +686,12 @@
       if (p == NULL)
         return SVN_NO_ERROR;
 
+      if (tview_len > SVN_DELTA_WINDOW_SIZE ||
+          sview_len > SVN_DELTA_WINDOW_SIZE ||
+          newlen > SVN_DELTA_WINDOW_SIZE)
+        return svn_error_create(SVN_ERR_SVNDIFF_CORRUPT_WINDOW, NULL,
+                                _("Svndiff contains a too-large window"));
+
       /* Check for integer overflow.  */
       if (sview_offset < 0 || inslen + newlen < inslen
           || sview_len + tview_len < sview_len
@@ -841,6 +848,12 @@
   SVN_ERR(read_one_size(inslen, stream));
   SVN_ERR(read_one_size(newlen, stream));
 
+  if (*tview_len > SVN_DELTA_WINDOW_SIZE ||
+      *sview_len > SVN_DELTA_WINDOW_SIZE ||
+      *newlen > SVN_DELTA_WINDOW_SIZE)
+    return svn_error_create(SVN_ERR_SVNDIFF_CORRUPT_WINDOW, NULL,
+                            _("Svndiff contains a too-large window"));
+
   /* Check for integer overflow.  */
   if (*sview_offset < 0 || *inslen + *newlen < *inslen
       || *sview_len + *tview_len < *sview_len
Index: libsvn_delta/text_delta.c
===================================================================
--- libsvn_delta/text_delta.c	(revision 38477)
+++ libsvn_delta/text_delta.c	(working copy)
@@ -548,7 +548,7 @@
 /* Functions for applying deltas.  */
 
 /* Ensure that BUF has enough space for VIEW_LEN bytes.  */
-static APR_INLINE void
+static APR_INLINE svn_error_t *
 size_buffer(char **buf, apr_size_t *buf_size,
             apr_size_t view_len, apr_pool_t *pool)
 {
@@ -557,8 +557,12 @@
       *buf_size *= 2;
       if (*buf_size < view_len)
         *buf_size = view_len;
+      SVN_ERR_ASSERT(APR_ALIGN_DEFAULT(*buf_size) >= *buf_size);
       *buf = apr_palloc(pool, *buf_size);
+      SVN_ERR_ASSERT(*buf != NULL);
     }
+
+    return SVN_NO_ERROR;
 }
 
 
@@ -659,7 +663,7 @@
                          >= ab->sbuf_offset + ab->sbuf_len)));
 
   /* Make sure there's enough room in the target buffer.  */
-  size_buffer(&ab->tbuf, &ab->tbuf_size, window->tview_len, ab->pool);
+  SVN_ERR(size_buffer(&ab->tbuf, &ab->tbuf_size, window->tview_len, ab->pool));
 
   /* Prepare the source buffer for reading from the input stream.  */
   if (window->sview_offset != ab->sbuf_offset
@@ -668,7 +672,8 @@
       char *old_sbuf = ab->sbuf;
 
       /* Make sure there's enough room.  */
-      size_buffer(&ab->sbuf, &ab->sbuf_size, window->sview_len, ab->pool);
+      SVN_ERR(size_buffer(&ab->sbuf, &ab->sbuf_size, window->sview_len,
+              ab->pool));
 
       /* If the existing view overlaps with the new view, copy the
        * overlap to the beginning of the new buffer.  */

