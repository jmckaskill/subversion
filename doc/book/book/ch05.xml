<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-5">
<title>Repository Administration</title>

  <simplesect>

    <para>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems safely resolved.  In this
      chapter, we'll discuss:</para>

    <itemizedlist>
      <listitem>
        <para>creation and configuration of a repository.</para>
      </listitem>
      <listitem>
        <para>networking of repositories.</para>
      </listitem>
      <listitem>
        <para>repository maintainance, including the use of the
          <command>svnlook</command> and <command>svnadmin</command>
          tools provided with Subversion.</para>
      </listitem>
      <listitem>
        <para>suggestions for how to arrange the versioned data in
          your repository.</para>
      </listitem>
      <listitem>
        <para>common questions and mistakes regarding repositories.</para>
      </listitem>
    </itemizedlist>

    <para>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control, you can skip
      this chapter altogether.  However, if you are, or wish to
      become, a Subversion repository administrator,
      <footnote>
        <para>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</para>
      </footnote>
      you should definitely pay attention to this chapter.</para>

    <para>Of course, one cannot administer a repository unless one has
      a repository to administer.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <title>Repository Creation and Configuration</title>

    <para>Creating a Subversion repository is an incredibly simple
      task.  The <command>svnadmin</command> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</para>
          
    <screen>
$ svnadmin create path/to/repos
</screen>
          
    <para>This creates a new repository in the directory
      <filename>path/to/repos</filename>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<filename>/</filename>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <literal>svn:date</literal>, set to the time at which
      the repository was created.</para>
          
    <para>You may have noticed that the path argument to
      <command>svnadmin</command> was just a regular filesystem path
      and not a URL like the <command>svn</command> client program
      uses when referring to repositories.  Both
      <command>svnadmin</command> and <command>svnlook</command> are
      considered server-side utilities&mdash;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even "local"
      <literal>file:</literal> ones) to these two programs.</para>

    <para>So, after you've run the <command>svnadmin create</command>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</para>
            
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README
</screen>
      
    <para>As you can see, immediately inside the repository directory
      is collection of mostly subdirectories.  As in other areas of
      the Subversion design, modularity is given high regard, and
      heirarchical organization is preferred to cluttered chaos.  The
      following is a brief description of all of those items in your
      new repository directory:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Currently unused, repository configuration files will
            go in this directory someday.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>dav</term>
        <listitem>
          <para>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>db</term>
        <listitem>
          <para>The main Berkeley DB environment, full of DB tables
            that comprise the data store for Subversion's filesystem
            (where all of your versioned data resides).</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>format</term>
        <listitem>
          <para>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>locks</term>
        <listitem>
          <para>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>README</term>
        <listitem>
          <para>A file which merely informs its readers that they
            are looking at a Subversion repository.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <para>In general, you'll not want to tamper with most of the items
      in your repository, at least not <quote>by hand</quote>.  The
      <command>svnadmin</command> tool should be sufficient for any
      changes necessary to your repository, or you can look to
      third-party tools (such as Berkeley DB's tool suite) for
      tweaking relevant subsections of the repository.  Some
      exceptions exist, though, and we'll cover those here.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <title>Hook scripts</title>

      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</para>
            
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks.</para>
            
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl  write-sentinels.tmpl
post-revprop-change.tmpl  read-sentinels.tmpl
pre-commit.tmpl           start-commit.tmpl
</screen>
            
      <para>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory
        which can be execute as the name (like
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>

      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <literal>.tmpl</literal> extension,
        and then customize the hooks contents.  Windows, however, uses
        file extensions to denote executability, so you would need to
        supply a program whose basename is the name of the hook plus
        one of the special extensions recognized by Windows for
        executable programs, such as <filename>.exe</filename> or
        <filename>.com</filename> for programs, and
        <filename>.bat</filename> for batch files.</para>
          
      <para>Currently there are five true hooks implemented by the
        Subversion repository.</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <para>This is run before the committer's transaction is
              even created.  It is typically used to decide if the
              user has commit privileges at all.  The repository
              passes two arguments to this program:  the path to the
              repository, and username which is attempting the commit.
              If the program returns a non-zero exit value, the commit
              is stopped before the transaction is even created.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <para>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and transaction is removed.</para>

            <para>The Subversion distribution includes a
              <command>commit-access-control.pl</command> script
              (located in the <filename>tools/hook-scripts</filename>
              directory of the Subversion source tree) that can be
              called from <command>pre-commit</command> to implement
              fine-grained access control.  At this time, this is the
              only method by which users can implement finer-grained
              access control beyond what
              <filename>httpd.conf</filename> offers.  In a future
              version of Subversion, we plan to implement ACLs
              directly in the filesystem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <para>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a perform a backup of the repository.  The repository
              passes two arguments to this program: the path to the
              repository, and the new revision number that was
              created.  The exit code of the program is ignored.</para>
                
            <para>The Subversion distribution includes a
              <command>commit-email.pl</command> script (located in
              the <filename>tools/hook-scripts/</filename> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</para>

            <para>Another useful tool provided by Subversion is the
              <command>hot-backup.py</command> script (located in the
              <filename>tools/backup/</filename> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database backend), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <literal>svn:log</literal> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <filename>post-revprop-change</filename>)
              so that repository administrators can keep records of
              changes to these items using some externals means if
              they so desire.</para>

            <para>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modied property exist, the
              authenticated username of the person making the change,
              and name of the property itself.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>As mentioned earlier, this hook is the counterpart
              of <filename>pre-revprop-change</filename> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <filename>pre-revprop-change</filename> hook
              exists.  When both of these hooks are present, the
              <filename>post-revprop-change</filename> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and name of
              the property itself.</para>

            <para>The Subversion distribution includes a
              <command>propchange-email.pl</command> script (located
              in the <filename>tools/hook-scripts/</filename>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <sidebar>
        <title>Sentinels, Those <quote>Other</quote> Hooks</title>

        <para>In addition to the hook scripts, Subversion has
          templates for two other special event handlers&mdash;the
          <filename>read-sentinels</filename> and
          <filename>write-sentinels</filename>.  These special
          programs, called <firstterm>sentinels</firstterm>, are
          intended to be daemon-like applications which are started at
          the beginning of a user's operation, and which receive
          multiple event notifications of a single type over the
          course of that operation.  Depending on the sentinel's
          responses to each of these notifications, Subversion may
          stop or otherwise modify the operation.  Fortunately for
          today's Subversion repository administrators, these
          sentinels can be ignored, since support for them is not yet
          implemented in Subversion itself!</para>
      </sidebar>
            
      <para>Subversion will attempt to execute hooks as the same user
        who owns the Subversion repository process.  In most cases,
        the repository is being access via Apache HTTP server and
        mod_dav_svn, so this user is the same user that Apache runs
        as.  The hooks themselves will need to be configured with
        OS-level permissions that allow that user to execute them.
        Also, this means that any file or programs (including the
        Subversion repository itself) accessed directly or indirectly
        by the hook will be accessed as the same user.  In other
        words, be alert to potential permissioning problems that might
        keep the hook from performing the tasks you've written it to
        perform.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <title>Berkeley DB configuration</title>

      <para>The Berkeley DB environment has it own set of default
        configuration values for things like the number of lock
        allowed to be taken out at any given time, or the size
        cutoff for Berkeley's journaling log file, etc.
        Subversion's filesystem code additional chooses default
        values for some of the Berkeley DB configuration options.
        However, sometimes your particular repository, with its
        unique collection of data and access patterns, might require
        a different set of configuration option values.</para>

     <para>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so have provided a mechanism for runtime
        overriding of many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence
        of a file named <filename>DB_CONFIG</filename> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley
        environment.</para>

     <para>The Berkeley configuration overrides file for your
        repository is located in the <filename>db</filename>
        environment directory, at
        <filename>repos/db/DB_CONFIG</filename>.  Subversion itself
        creates this file when it creates the rest the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <filename>DB_CONFIG</filename> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        BerkeleyDB to behave in a fashion that is unexpected by the
        rest of the Subversion code.</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-2">
    <title>Repository Maintenance</title>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <title>Examining a Repository</title>
            
      <sect3 id="svn-ch-5-sect-2.1.1">
        <title>Understanding Transactions and Revisions</title>
        
        <para>A Subversion repository is essentially a sequence of
          directory trees, each tree a snapshot of how the files and
          directories versioned in your repository looked at various
          points in time.  These snapshots are created as a result of
          client operations, and are called revisions.</para>

        <para>Every revision begins life as a transaction tree.  When
          doing a commit, a client builds a Subversion transaction
          that mirrors their local changes (plus any additional
          changes that might have been made to the repository since
          the beginning of the client's commit process), and then
          instructs the repository to store that tree as the next
          snapshot in the sequence.  If the commit succeeds, the
          transaction is effectively promoted into a new revision
          tree, and is assigned a new revision number.  If the commit
          fails for some reason, the transaction is destroyed and the
          client is informed of the failure.</para>
            
        <para>At the moment, updates work in a similar way.  The
          client builds a temporary transaction tree that mimics the
          state of the working copy.  The repository then compares
          that transaction tree with the revision tree at the request
          revision (usually the most recent, or
          <quote>youngest</quote> tree), and sends back information
          that informs the client about what changes are needed to
          transform their working copy into a replica of that revision
          tree.  After the update completes, the temporary transaction
          is deleted.</para>
            
        <para>The use of transaction trees is the only way to make
          permanent changes to repository's versioned filesystem.
          However, it's important to understand that the lifetime of a
          transaction is completely flexible.  In the case of updates,
          transactions are temporary trees that are immediately
          destroyed.  In the case of commits, transactions are
          transformed into permanent revisions (or aborted if the
          commit fails).  In the case of an error or bug, it's
          possible that a transaction can be accidentally left lying
          around in the repository (not really affecting anything, but
          still taking up space).</para>

        <para>In theory, someday whole workflow applications might
          revolve around more fine-grained control of transaction
          lifetime.  It is feasible to imagine a system whereby each
          transaction slated to become a revision is left in statis
          well after the client finishes describing its changes to
          repository.  This would enable each new commit to be
          reviewed by someone else, perhaps a manager or engineering
          QA team, who can choose to promote the transaction into a
          revision, or abort it.</para>
            
        <para>You might at this point be wondering what all of this
          has to do with repository administration.  The answer is
          simple: if you're administering a Subversion repository,
          you're going to have to examine revisions and transactions.
          It's part of monitoring the health of, and tracking changes
          to, your repository.</para>
            
      </sect3>

      <sect3 id="svn-ch-5-sect-2.1.2">
        <title>svnlook</title>
            
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          transaction in a repository.  No part of this program
          attempts to change the repository&mdash;it a
          <quote>read-only</quote> tool.  <command>svnlook</command>
          is the typically used by the repository hooks for reporting
          the changes that are about to be committed (in the case of
          the <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  Also, a repository administrator
          may find himself using this tool for diagnostic
          purposes.</para>
            
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
            
        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
...
</screen>

        <para>Nearly every one of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>--revision</option> and
          <option>--transaction</option> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of non-committed
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</para>

        <para>In the absence of both the <option>--revision</option>
          and <option>--transaction</option> options,
          <command>svnlook</command> will examine the youngest (or
          <quote>HEAD</quote>) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <filename>/path/to/repos</filename>:</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</screen>

        <para>The only exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options, and simply prints out the HEAD revision
          number.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
            
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <literal>info</literal> subcommand:</para>

        <screen>
$ svnlook info path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>The output of the <literal>info</literal> subcommand is
          defined as:</para>

        <orderedlist>
          <listitem>
            <para>The author, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The date, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The number of characters in the log message,
              followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The log message itself, followed by a newline.</para>
          </listitem>
        </orderedlist>

        <para>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>

        <para>Another common use of <command>svnlook</command> is to
          actually view the contents of a revision or transaction
          tree.  Examining the output of <command>svnlook
          tree</command> command, which displays the directories and
          files in the requested tree (optionally showing the
          filesystem node revision IDs for each of those paths) can be
          extremely helpful to administrators deciding on whether or
          not it is safe to remove a seemingly dead transaction.  It
          is also quite useful for Subversion developers who are
          diagnosing filesystem-related problems when they
          arise.</para>

        <screen>
$ svnlook tree path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <para><command>svnlook</command> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <command>svnlook</command>,
          and the output of those subcommands:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <para>Print the tree's author.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <para>Print the tree's datestamp.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <para>List all files and directories that changed in the 
                tree.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <para>Print unified diffs of changed files.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <para>List the directories that changed in the tree.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <para>Print the tree's author, datestamp, log message
                character count, and log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <para>Print the tree's log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <para>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <para>Print the youngest revision number.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-2.1.3">
        <title>svnadmin</title>

        <para>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you perform several maintainance operations on those
          repositories.  The syntax of <command>svnadmin</command> is
          similar to that of <command>svnlook</command>:</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   createtxn
   dump
...
</screen>

        <para>We've already mentioned <command>svnadmin</command>'s
          <literal>create</literal> subcommand (see <xref
          linkend="svn-ch-5-sect-1"/>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <para>Creates a new Subversion repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>createtxn</literal></term>
            <listitem>
              <para>Creates a transaction in the repository based on a
                given existing revision.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <para>Dumps the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <para>Loads a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <literal>dump</literal> subcommand.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lscr</literal></term>
            <listitem>
              <para>List the revisions in which a given path in the
                repository was modified.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <para>List the names of uncommitted Subversion
                transactions which currently exist in the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <para>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occured which prevented a process from cleanly
                shutting down its communication with the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <para>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <literal>lstxns</literal> subcommand).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <para>Replace the current value of the
                <literal>svn:log</literal> (commit log message)
                property on a given revision in the repository with a
                new value.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>undeltify</literal></term>
            <listitem>
              <para>Force the repository to use fulltext storage for
                the contents of a file at a given revision (as opposed
                to a smaller, compressed "delta" format), or perhaps
                for all files under a given directory in that
                revision.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-2.1.4">
        <title>svnshell.py</title>

        <para>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <command>svnshell.py</command> Python script (located in
          <filename>tools/examples/</filename> in the source tree)
          uses Subversion's language bindings (so you have to have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</para>

        <para>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          <quote>positioned</quote> in the root directory of the HEAD
          revision of the repository, and presented with a command
          prompt.  You can use the <literal>help</literal> command at
          any time to display a list of available commands and what
          they do.</para>

        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$
 help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <para>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&mdash;using the <literal>cd</literal> command.
          At all times, the command prompt will show you what revision
          (prefixed by <literal>rev:</literal>) or transaction
          (prefixed by <literal>txn:</literal>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <literal>setrev</literal> and
          <literal>settxn</literal> commands, respectively.  As in a
          Unix shell, you can use the <literal>ls</literal> command to
          display the contents of the current directory, and you can
          use the <literal>cat</literal> command to display the
          contents of a file.</para>

        <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1          &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2 cmpilato &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1          &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1          &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1          &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1          &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1          &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1          &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1          &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>

        <para>As you can see the previous example, multiple commands
          may be specified at a single command prompt, separated by a
          semicolon.  Also, the shell understands the notions of
          relative and absolute paths, and will properly handle the
          special path components <literal>.</literal> and
          <literal>..</literal>.</para>

        <para>You can use the <literal>youngest</literal> command to
          display the youngest revision.  This is useful for
          determining the range of valid revisions you can use as
          arguments to the <literal>setrev</literal> command&mdash;you
          can browse all the revisions (recalling that they are named
          with integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <command>lstxns</command> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <command>svnadmin lstxns</command> returns, and the same
          list that is valid for use with <command>svnlook</command>'s
          <option>--transaction</option> option.</para>

        <para>Once you've finished using the shell, you can exit
          cleanly by using the <command>exit</command> command.
          Alternatively, you can supply an end-of-file
          character&mdash;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <title>Berkeley DB Management</title>
            
      <para>Currently, the Subversion repository has only one database
        back-end: Berkeley DB.  All of your filesystem's structure and
        data live in a set of tables within the
        <filename>db</filename> subdirectory of your repository.  This
        subdirectory is a regular Berkeley DB environment directory,
        and can therefore be used in conjunction with any of
        Berkeley's database tools (you can see the documentation for
        these tools at SleepyCat's website, <systemitem
        class="url">http://www.sleepycat.com/</systemitem>).  For
        day-to-day Subversion use, these tools should be unnecessary,
        however, they do provide some important functionality that is
        currently not provided by Subversion itself.</para>

      <para>Remember that Berkeley DB has genuine transactions.
        Every attempt to change the DB is first logged.  If anything
        ever goes wrong, the DB can back itself up to a previous
        <literal>checkpoint</literal> and replay transactions to get
        the data back into a sane state.</para>
            
      <para>In our experience, we have seen situations where a bug in
        Subversion (which causes a crash) can sometimes have a
        side-effect of leaving the DB environment in a
        <quote>locked</quote> state.  When the repository is in this
        state, any attempts to read or write to the repository stall
        indefinitely as Subversion awaits the release of a lock that
        cannot be released.  Fortunately, Berkeley DB has genuine
        support for transactions, and Subversion takes advantage of
        that.  This means that every change to the database is first
        logged, and then exacted, so that if anyone goes wrong, the
        database can revert back to a previous
        <quote>checkpoint</quote> and replay the transactions to get
        back into a sane state.</para>
          
      <para>To <quote>unwedge</quote> the repository:</para>
 
      <orderedlist>
        <listitem>
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
              
          <screen>
Acquiring exclusive lock on repository db, and running recovery procedures.
Please stand by...
Recovery completed.
The latest repos revision is 19.
</screen>
        </listitem>
        <listitem>
          <para>Restart the Subversion server.</para>
        </listitem>
      </orderedlist>
            
      <para>Make sure you run this command as the user that owns and
        manages the database&mdash;typically your Apache
        process&mdash;and <emphasis>not</emphasis> as root.  Running
        <command>db_recover</command> as root leaves files owned by
        root in the <filename>db</filename> directory, which the
        non-root user that manages the database cannot open.  If you
        do this, you'll get <quote>permission denied</quote> error
        messages when you try to access the repository.</para><!--
        ###TODO Make this a warning block? -Fitz -->
      
      <para>Second, a repository administrator may need to manage
        the growth of logfiles.  At any given time, the DB
        environment is using at least one logfile to log
        transactions; when the <quote>current</quote> logfile grows
        to 10 megabytes, a new logfile is started, and the old one
        continues to exist.</para>
          
      <para>Thus, after a while, you may see a whole group of 1MB
        logfiles lying around the environment.  At this point, you
        can make a choice: if you leave every single logfile behind,
        it's guaranteed that <command>db_recover</command> will
        always be able to replay every single DB transaction, all
        the way back to the first commit.  (This is the
        <quote>safe</quote>, or perhaps paranoid, route.)  On the
        other hand, you can ask Berkeley DB to tell you which
        logfiles are no longer being actively written to:</para>
          
      <screen>
$ db_archive -a -h repos/db
log.0000000023
log.0000000024
log.0000000029
</screen>
            
      <para>Subversion's own repository uses a
        <literal>post-commit</literal> hook script, which, after
        performing a <quote>hot-backup</quote> of the repository,
        removes these excess logfiles.  (In the Subversion source
        tree, see
        <filename>tools/backup/hot-backup.py</filename>).</para>
          
      <para>This script also illustrates the safe way to perform a
        backup of the repository while it's still up and running:
        recursively copy the entire repository directory, then
        re-copy the logfiles listed by <command>db_archive
        -l</command>.</para>
          
      <para>To start using a repository backup that you've restored,
        be sure to run <command>db_recover -v</command> command in
        the <filename>db</filename> area first.  This guarantees
        that any unfinished log transactions are fully played before
        the repository goes live again.  (The
        <command>hot-backup.py</command> script does that for you
        during backup, so you can skip this step if you decide to
        use it.)</para>
          
      <para>Finally, note that Berkeley DB has a whole locking
        subsystem; in extremely intensive svn operations, we have seen
        situations where the DB environment runs out of locks.  The
        maximum number of locks can be adjusted by changing the values
        in the <filename>repos/db/DB_CONFIG</filename> file.  Don't
        change the default values unless you know what you're doing;
        be sure to read <systemitem
        class="url">http://www.sleepycat.com/docs/ref/lock/max.html</systemitem>
        first.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.3">
      <title>Tweaking with Svnadmin</title>
            
      <para>The <command>svnadmin</command> tool has some
        subcommands that are specifically useful to repository
        administrators.  Be careful with the
        <command>svnadmin</command>!  Unlike
        <command>svnlook</command>, which is read-only,
        <command>svnadmin</command> has the ability to modify the
        repository.</para>
          
      <para>The most-used feature is probably <literal>svnadmin
        setlog</literal>.  A commit's log message is an unversioned
        property directly attached to the revision object; there's
        only one log message per revision.  Sometimes a user screws
        up the message, and it needs to be replaced:</para>
          
      <screen>
$ echo "Here is the new, correct log message" > newlog.txt
$ svnadmin setlog myrepos 388 newlog.txt
</screen>
            
      <para>There's a nice CGI script in
        <filename>tools/cgi/</filename> that allows people (with
        commit-access passwords) to tweak existing log messages via
        web browser.</para>
          
      <para>Another common use of <command>svnadmin</command> is to
        inspect and clean up old, dead transactions.  Commits and
        updates both create transaction trees, but occasionally a
        bug or crash can leave them lying around.  By inspecting the
        datestamp on a transaction, an administrator can make a
        judgment call and remove it:</para>
          
      <screen>
$ svnadmin lstxns myrepos
319
321
$ svnadmin lstxns --long myrepos
Transaction 319
Created: 2002-07-14T12:57:22.748388Z
&hellip;
$ svnadmin rmtxns myrepos 319 321
</screen>
            
      <!-- ###TODO Hey guys, are going to continue to support
          svnadmin undeltify? -Ben -->
          
      <para>Another useful subcommand: <command>svnadmin
        undeltify</command>.  Remember that the latest version of
        each file is stored as fulltext in the repository, but that
        earlier revisions of files are stored as
        <quote>deltas</quote> against each next-most-recent
        revisions.  When a user attempts to access an earlier
        revision, the repository must apply a sequence of
        backwards-deltas to the newest fulltexts in order to derive
        the older data.</para>
          
      <para>If a particular revision tree is extremely popular, the
        administrator can speed up the access time to this tree by
        <quote>undeltifying</quote> any path within the
        revision&mdash; that is, by converting every file to
        fulltext:</para>
          
      <screen>
$ svnadmin undeltify myrepos 230 /project/tags/release-1.3
Undeltifying `/project/tags/release-1.3' in revision 230...done.
</screen>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.4">
      <title>Migrating a repository</title>
    
      <para>Sometimes special situations arise where you need to move
        all of your filesystem data from one repository to another.
        Perhaps the internal fs database schema has changed in some way
        in a new release of Subversion, or perhaps you'd like to start
        using a different database <quote>back end</quote>.</para>
  
      <para>Either way, your data needs to be migrated to a new
        repository.  To do this, we have the <command>svnadmin dump</command> and
        <command>svnadmin load</command> commands.</para>
  
      <para><command>svnadmin dump</command> writes a stream of your
        repository's data to stdout:</para>
  
      <screen>
$ svnadmin dump myrepos > dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
</screen>

      <para>This stream describes every revision in your repository as a
        list of changes to nodes.  It's mostly human-readable text; but
        when a file's contents change, the entire fulltext is dumped
        into the stream.  If you have binary files or binary
        property-values in your repository, those parts of the stream
        may be unfriendly to human readers.</para>
  
      <para>After dumping your data, you would then move the file to a
        different system (or somehow alter the environment to use a
        different version of <command>svnadmin</command> and/or
        <filename>libsvn_fs.so</filename>), and create a
        <quote>new</quote>-style repository that has a new schema or DB
        back-end:</para>
  
      <screen>
$ svnadmin create newrepos
</screen>
    
      <para>The <command>svnadmin load</command> command attempts to
        read a dumpstream from stdin, and effectively replays each
        commit:</para>
  
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
&hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;
</screen>

      <para>Voila, your revisions have been recommitted into the new
        repository.</para>
      
      <para>And because <command>svnadmin</command> uses standard input
        and output streams for the repository dump and load process,
        people who are feeling saucy with Unix can try things like
        this:</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>You can also create a dumpfile that represents a specific
        range of revisions.  <command>svnadmin dump</command> takes
        optional starting and ending revisions to accomplish just that
        task.</para>

      <screen>
$ svnadmin dump myrepos 23 > rev-23.dumpfile
$ svnadmin dump myrepos 100 200 > revs-100-200.dumpfile
</screen>

      <para>Now, regardless of the range of revisions used when
        dumping the repository, the default behavior is for the first
        revision dumped to always be compared against revision 0,
        which is just the empty root directory <filename>/</filename>.
        This means that the first revision in any dumpfile will always
        look like a gigantic list of <quote>added</quote> nodes.  We
        do this so that a file like
        <filename>revs-100-200.dumpfile</filename> can be directly
        loaded into an empty repository.</para>

      <para>However, if you add the <option>--incremental</option>
        option when you dump your repository, this tells
        <command>svnadmin</command> to compare the first dumped
        revision against the previous revision in the repository, the
        same way it treats every other revision that gets dumped.  The
        benefit of this is that you can create several small dumpfiles
        that can be loaded in succession, instead of one large one,
        like so:</para>

      <screen>
$ svnadmin dump myrepos 0 1000 > dumpfile1
$ svnadmin dump myrepos 1001 2000 --incremental > dumpfile2
$ svnadmin dump myrepos 2001 3000 --incremental > dumpfile3
</screen>

      <para>These dumpfiles could be loaded into a new repository with
        the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dumpfile a new range of revisions.  For example, you
        might have a post-commit hook that simply appends the
        repository dump of the single revision that triggered the
        hook.  Or you might have a script like the following that runs
        nightly to append dumpfile data for all the revisions that
        were added to the repository since the last time the script
        ran.</para>

      <screen>
#!/usr/bin/perl

$repos_path  = '/path/to/repos';
$dumpfile    = '/usr/backup/svn-dumpfile';
$last_dumped = '/var/log/svn-last-dumped';
 
# Figure out the starting revision (0 if we cannot read the last-dumped file,
# else use the revision in that file incremented by 1).
if (open LASTDUMPED, "$last_dumped")
{
    $new_start = &lt;LASTDUMPED&gt;;
    chomp $new_start;
    $new_start++;
    close LASTDUMPED;
}
else
{
    $new_start = 0;
}

# Query the youngest revision in the repos.
$youngest = `svnlook youngest $repos_path`;
chomp $youngest;

# Do the backup.
`svnadmin dump $repos_path $new_start $youngest --incremental >> $dumpfile`;

# Store a new last-dumped revision
open LASTDUMPED, "> $last_dumped" or die;
print LASTDUMPED "$youngest\n";
close LASTDUMPED;

# All done!
</screen>

      <para>As you can see, the Subversion repository dumpfile format,
        and specifically <command>svnadmin</command>'s use of that
        format, can be a valuable means by which to backup changes to
        your repository over time in case of a system crash or some
        other catastrophic event.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  NETWORKING A REPOSITORY                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-3">
    <title>Networking a Repository</title>
          
    <para>A Subversion repository is perfectly happy being accessed by
      clients running the same machine on which the repository
      resides, but most of the time, Subversion's users are not.  The
      typical Subversion setup involves a single server machine being
      accessed from client computers all over the office&mdash;or,
      perhaps, all over the world.  This section describes how to get
      your Subversion repository exposed outside its host machine for
      use by remote clients.</para>
            
    <para>Subversion's primary network server is the Apache HTTP
      Server (<command>httpd</command>), speaking the WebDAV/deltaV
      protocol.  This protocol (an extension to HTTP 1.1; see
      <systemitem class="url">http://www.webdav.org/</systemitem>)
      takes the ubiquitous HTTP protocol that is core of the World
      Wide Web, and adds writing&mdash;specifically, versioned
      writing&mdash;capabilities.  The result is a standarized, robust
      system that is conveniently packaged as part of the Apache 2.0
      software, is supported by numerous pieces of core operating
      system and third-party products, and which doesn't requite
      network administrators to open up yet another custom
      port.</para>

    <para>Much the following discussion includes references to Apache
      configurarion directives.  While some examples are given of the
      use of these directives, describing them in full is outside the
      scope of this chapter.  The Apache team maintains excellent
      documentation, publicly available on their website at
      <systemitem class="url">http://httpd.apache.org</systemitem>.
      For example, a general reference for the configuration
      directives is located at <systemitem
      class="url">http://httpd.apache.org/docs-2.0/mod/directives.html</systemitem>.)</para>
            
    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives with specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem which is not clearly noticeable
      otherwise.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.1">            
      <title>What You Need to Network Your Repository</title>

      <para>To network your repository, you basically need four
        components, availablity in two packages.  You'll need Apache
        <command>httpd</command> 2.0, the <command>mod_dav</command>
        DAV module that comes with it, Subversion, and the
        <command>mod_dav_svn</command> filesystem provider module
        distributed with Subversion.  Once you have all of those
        components, the process of networking your repository is as
        simple as:</para>

      <itemizedlist>
        <listitem>
          <para>getting httpd 2.0 up and running with the mod_dav
            module,</para>
        </listitem>
        <listitem>
          <para>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</para>
        </listitem>
        <listitem>
          <para>configuring your <filename>httpd.conf</filename> file
            to export the repository.</para>
        </listitem>
      </itemizedlist>
  
      <para>You can accomplish the first two items either by compiling
        <command>httpd</command> and Subversion from source code, or
        by installing pre-built binary packages of them on your
        system.</para>
  
      <!-- Need lots more detail here.  This fuzzy hand-waving ain't
          gonna cut it. -->

    </sect2>  

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.2">            
      <title>Basic Apache Configuration</title>

      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any further Subversion-related configuration.  If your
        Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>
  
      <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.</para>
  
      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, staring with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/absolute/path/to/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>
              
      <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</screen>
            
      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <literal>SVNParentPath</literal> directive, to indicate a that
        common parent directory.  For example, if you know you would
        be creating multiple Subversion repositories in a directory
        <filename>/usr/local/svn</filename> that would be access via
        URLs like <systemitem
        class="url">http://my.server.com/svn/repos1</systemitem>,
        <systemitem
        class="url">http://my.server.com/svn/repos2</systemitem>, and
        so on, you could use the following
        <filename>httpd.conf</filename> configuration syntax:</para>
            
      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>
            
      <para>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <filename>SVNPath</filename> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.3">            
      <title>Permissions, Authentication, and Authorization</title>
  
      <para>Now, at this stage, you should strongly consider the
        question of permissions.  If you've been running Apache for
        some time now as your regular web server, you probably already
        have a collection of content&mdash;web pages, scripts and
        such&mdash;that have been carefully given a set of permission
        requirements that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</para>
  
      <para>You will need to determine a permissioning setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things the Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permissioning problems are perhaps the most common
        oversight when configuring a Subversion repository for use
        with Apache.</para>
  
      <para>And while we are speaking about permissions, we should
        address how the authorization and authentication mechanisms
        provided by Apache fit into the scheme of things.  Unless you
        have some system-wide configuration of these things, the
        Subversion repositories you make available via the
        <filename>Location</filename> directives will be generally
        accessible to everyone.  In other words</para>
              
      <itemizedlist>
        <listitem>
          <para>anyone can use their svn client to checkout either a
            working copy of a repository URL (or any of its
            subdirectories),</para>
        </listitem>
        <listitem>
          <para>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</para>
        </listitem>
        <listitem>
          <para>anyone can commit to a repository.</para>
        </listitem>
      </itemizedlist>
      
      <para>If you want to restrict either read or write access to a
        repository as a whole, you can use Apache's built-in access
        control features.  The easiest such feature is the Basic
        authentication mechanism, which simply uses a username and
        password to verify that a user is who she says she is.  Apache
        provides an <command>htpasswd</command> utility for this
        purpose.  Using <command>htpasswd</command>, you can create a
        file that contains the usernames and passwords of the users to
        whom you wish to grant special access to your Subversion
        repository.  Let's grant commit access to Sally and
        Harry.</para>
  
      <screen>
$ ### First time: use -c to create the file
$ htpasswd -c /etc/svn-auth-file harry
New password: 
Re-type new password: 
Adding password for user harry
$ htpasswd /etc/svn-auth-file sally
New password: 
Re-type new password: 
Adding password for user sally
$
</screen>
    
      <para>Now, you need to add some more
        <filename>httpd.conf</filename> directives inside your
        <literal>Location</literal> block to tell Apache what to do
        with your new authentication file.  The
        <literal>AuthType</literal> directive specifies the type of
        authentication system to use; in this case, we want
        <literal>Basic</literal>.  <literal>AuthName</literal> is an
        arbitrary name that you give for the authentication domain.
        Most browsers will display this name in the popup dialog box
        when the browser is querying the user for his name and
        password.  Finally, use the <literal>AuthUserFile</literal>
        directive to specify the location of the file you created
        using <command>htpasswd</command>.</para>
  
      <para>After adding these three directives, your
        <literal>&lt;Location&gt;</literal> block should look
        something like this:</para>
  
      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
</screen>

      <para>Now, at this stage, if you were restart Apache, any
        Subversion operations which required authentication would
        harvest a username and password from the Subversion client,
        which would either provide previously cached values for these
        things, or prompt the user for the information.  All that
        remains is to actually tell Apache which operations actually
        require that authentication.</para>
  
      <para>You can restrict access on all repository operations by
        adding the <literal>Require valid-user</literal> directive to
        your <literal>&lt;Location&gt;</literal> block.  Using our
        previous example, this would mean that only clients that
        claimed to be either <literal>harry</literal> or
        <literal>sally</literal>, and which provided the correct
        password for that username, would be allowed to do anything
        with that Subversion repository.</para>
  
      <para>Sometimes you don't need to run such a tight ship.  The
        repository at <systemitem
        class="url">http://svn.collab.net/repos/svn</systemitem> which
        holds the Subversion source code, for example, allows anyone
        in the world to perform read-only tasks (like checking out
        working copies and browsing the repository with a web browser)
        on the repository, but restricts all write operations to
        authenticated users.  To do this type of selective
        restriction, you can use the <literal>Limit</literal> and
        <literal>LimitExcept</literal> configuration directives.  Like
        the <literal>Location</literal> directive, these blocks have
        starting and ending tags, and you would nest them inside your
        <filename>&lt;Location&gt;</filename> block.</para>
  
      <para>The parameters present on the <literal>Limit</literal> and
        <literal>LimitExcept</literal> directives are HTTP request
        types that are affected by that block.  For example, if you
        wanted to disallow all access to your repository except the
        currently supported read-only operations, you would use the
        <literal>LimitExcept</literal> directive, passing the
        <literal>GET</literal>, <literal>GET</literal>,
        <literal>GET</literal>, and <literal>GET</literal> request
        type parameters.  Then the previously mentioned
        <literal>Require valid-user</literal> directive would be
        placed inside the <literal>&lt;LimitExcept&gt;</literal> block
        instead of just inside the <literal>&lt;Location&gt;</literal>
        block.</para>
  
      <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>
          
      <para>These are only a few simple examples.  For more in-depth
        information about Apache access control, take a look at the
        <literal>Security</literal> section of the Apache
        documentation's tutorials collection at <systemitem
        class="url">http://httpd.apache.org/docs-2.0/misc/tutorials.html</systemitem>.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.4">
      <title>Server Names and the COPY Request</title>

      <para>Subversion makes use the <literal>COPY</literal> request
        type to perform server-side copies of files and directories.
        As part of the sanity checking done by the Apache modules, the
        source of the copy is expected to be located on the same
        machine as the destination of the copy.  To satisfy this
        requirement, you might need to tell mod_dav the name you use
        as the hostname of your server.  Generally, you can use the
        <literal>ServerName</literal> directive in
        <filename>httpd.conf</filename> to accomplish this.</para>
            
      <screen>
ServerName svn.red-bean.com
</screen>
            
      <para>If you are using Apache's virtual hosting support via the
        <literal>NameVirtualHost</literal> directive, you may need to
        use the <literal>ServerAlias</literal> directive to specify
        additional names that your server is known by.</para>

    </sect2> 

    <!-- ### TODO: talk about SSL, mod_deflate, using different ports,
         etc. -->

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-4">
    <title>Adding projects</title>

    <para>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <command>svn</command>
      client program's <literal>import</literal> subcommand to get to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.1">
      <title>Choosing a Repository Layout</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <quote>laying out</quote>
        the contents of your repository in an effective manner the
        first time, you can prevent a load of future headaches.</para>

        <!-- Put some wisdom here later.  I have none tonight.
             Specifically, the following section on 'svn import' is a
             joke.  It's no more about 'svn import' than it is about
             'svn mkdir' or 'svn smackdown -cage-match'.  -->
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.2">
      <title>Examples of 'svn import'</title>
          
      <para>You may want to give your repository an initial directory
        structure that reflects the trunk, branches, and tags of your
        project(s) (See <xref linkend="svn-ch-4"/>.)  You can do this
        via <command>svn mkdir</command>:</para>
            
      <screen>
$ svnadmin create /path/to/repos
$ svn mkdir file:///path/to/repos/projectA -m 'Base dir for A'
Committed revision 1.
            
$ svn mkdir file:///path/to/repos/projectA/trunk -m 'Main dir for A'
Committed revision 2.
            
$ svn mkdir file:///path/to/repos/projectA/branches -m 'Branches for A'
Committed revision 3.
            
$ svn mkdir file:///path/to/repos/projectA/tags -m 'Tags for A'
Committed revision 4.
            
$ svn co file:///path/to/repos/projectA/trunk projectA
Checked out revision 4.
             
# ... now work on projectA ...
</screen>
          
      <para>With <command>svn import</command>, you can create the
        structure with a single commit:</para>
            
      <screen>
$ svnadmin create /path/to/repos
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags    
$ svn import file:///path/to/repos projectA projectA -m 'Dir layout for A'
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Committed revision 1.

$ rm -rf projectA/
$ svn co file:///path/to/repos/projectA/trunk projectA
Checked out revision 1.
            
#  ... now work on projectA ...
</screen>

    </sect2>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
