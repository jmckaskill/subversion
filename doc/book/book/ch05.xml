<chapter id="svn-ch-5">
<title>Repository Administration</title>

  <simplesect>

    <para>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems safely resolved.</para>

    <para>In this chapter, we'll discuss how to create and configure a
      Subversion repository, and how to expose that repository for
      network accessibility.  We'll also talk about repository
      maintenance, including the use of the <command>svnlook</command>
      and <command>svnadmin</command> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</para>

    <para>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <footnote>
        <para>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</para>
      </footnote>
      you should definitely pay attention to this chapter.</para>

    <para>Of course, one cannot administer a repository unless one has
      a repository to administer.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY BASICS                               *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <title>Repository Basics</title>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <title>Understanding Transactions and Revisions</title>
        
      <para>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at various points in time.  These snapshots are created as a
        result of client operations, and are called revisions.</para>

      <para>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</para>
            
      <para>At the moment, updates work in a similar way.  The client
        builds a temporary transaction tree that mirrors the state of
        the working copy.  The repository then compares that
        transaction tree with the revision tree at the request
        revision (usually the most recent, or <quote>youngest</quote>
        tree), and sends back information that informs the client
        about what changes are needed to transform their working copy
        into a replica of that revision tree.  After the update
        completes, the temporary transaction is deleted.</para>
          
      <para>The use of transaction trees is the only way to make
        permanent changes to repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</para>

     <para>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</para>
            
      <para>What does all of this have to do with repository
        administration?  The answer is simple: if you're administering
        a Subversion repository, you're going to have to examine
        revisions and transactions as part of monitoring the health of
        your repository.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <title>Unversioned Properties</title>

      <para>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</para>

      <para>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree&mdash;the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <literal>svn:date</literal>&mdash;a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<literal>svn:author</literal>) and a
        property to store the log message attached to that revision
        (<literal>svn:log</literal>).</para>

      <para>Revision and transaction properties are
        <firstterm>unversioned properties</firstterm>&mdash;as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <literal>svn:log</literal> property with a new, corrected log
        message.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-2">
    <title>Repository Creation and Configuration</title>

    <para>Creating a Subversion repository is an incredibly simple
      task.  The <command>svnadmin</command> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</para>
          
    <screen>
$ svnadmin create path/to/repos
</screen>
          
    <para>This creates a new repository in the directory
      <filename>path/to/repos</filename>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<filename>/</filename>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <literal>svn:date</literal>, set to the time at which
      the repository was created.</para>
          
    <para>You may have noticed that the path argument to
      <command>svnadmin</command> was just a regular filesystem path
      and not a URL like the <command>svn</command> client program
      uses when referring to repositories.  Both
      <command>svnadmin</command> and <command>svnlook</command> are
      considered server-side utilities&mdash;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even "local"
      <literal>file:</literal> ones) to these two programs.</para>

    <para>So, after you've run the <command>svnadmin create</command>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</para>
            
    <screen>
$ ls repos
dav/  db/  format  hooks/  locks/  README
</screen>
      
    <para>With the exception of the <filename>README</filename> file,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</para>

    <variablelist>
     <varlistentry>
        <term>dav</term>
        <listitem>
          <para>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>db</term>
        <listitem>
          <para>The main Berkeley DB environment, full of DB tables
            that comprise the data store for Subversion's filesystem
            (where all of your versioned data resides).</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>format</term>
        <listitem>
          <para>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>locks</term>
        <listitem>
          <para>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>README</term>
        <listitem>
          <para>A file which merely informs its readers that they
            are looking at a Subversion repository.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <para>In general, you shouldn't tamper with your repository
      <quote>by hand</quote>.  The <command>svnadmin</command> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <title>Hook scripts</title>

      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</para>
            
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks.</para>
            
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</screen>
            
      <para>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory
        which can be executed as the name (like
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>

      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <literal>.tmpl</literal> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> or <filename>.com</filename> for
        programs, and <filename>.bat</filename> for batch
        files.</para>
          
      <para>Currently there are five true hooks implemented by the
        Subversion repository.</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <para>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <para>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and transaction is removed.</para>

            <para>The Subversion distribution includes some access
              control scripts (located in the
              <filename>tools/hook-scripts</filename> directory of the
              Subversion source tree) that can be called from
              <command>pre-commit</command> to implement fine-grained
              access control.  At this time, this is the only method
              by which administrators can implement finer-grained access
              control beyond what <filename>httpd.conf</filename>
              offers.  In a future version of Subversion, we plan to
              implement ACLs directly in the filesystem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <para>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</para>
                
            <para>The Subversion distribution includes a
              <command>commit-email.pl</command> script (located in
              the <filename>tools/hook-scripts/</filename> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</para>

            <para>Another useful tool provided by Subversion is the
              <command>hot-backup.py</command> script (located in the
              <filename>tools/backup/</filename> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <literal>svn:log</literal> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <filename>post-revprop-change</filename>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.</para>

            <para>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and name of the property itself.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-revprop-change</filename></term>
          <listitem>
            <para>As mentioned earlier, this hook is the counterpart
              of <filename>pre-revprop-change</filename> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <filename>pre-revprop-change</filename> hook
              exists.  When both of these hooks are present, the
              <filename>post-revprop-change</filename> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and name of
              the property itself.</para>

            <para>The Subversion distribution includes a
              <command>propchange-email.pl</command> script (located
              in the <filename>tools/hook-scripts/</filename>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <title>Berkeley DB configuration</title>

      <para>The Berkeley DB environment has it own set of default
        configuration values for things like the number of locks
        allowed to be taken out at any given time, or the size
        cutoff for Berkeley's journaling log file, etc.
        Subversion's filesystem code additionally chooses default
        values for some of the Berkeley DB configuration options.
        However, sometimes your particular repository, with its
        unique collection of data and access patterns, might require
        a different set of configuration option values.</para>

     <para>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        runtime overriding of many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <filename>DB_CONFIG</filename> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</para>

     <para>The Berkeley configuration file for your
        repository is located in the <filename>db</filename>
        environment directory, at
        <filename>repos/db/DB_CONFIG</filename>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <filename>DB_CONFIG</filename> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-3">
    <title>Repository Maintenance</title>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.1">
      <title>An Administrator's Toolkit</title>

      <sect3 id="svn-ch-5-sect-3.1.1">
        <title>svnlook</title>
            
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository&mdash;it's a
          <quote>read-only</quote> tool.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
            
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
            
        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
&hellip;
</screen>

        <para>Nearly every one of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>--revision</option> and
          <option>--transaction</option> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</para>

        <para>In the absence of both the <option>--revision</option>
          and <option>--transaction</option> options,
          <command>svnlook</command> will examine the youngest (or
          <quote>HEAD</quote>) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <filename>/path/to/repos</filename>:</para>

        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</screen>

        <para>The only exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options, and simply prints out the HEAD revision
          number.</para>

        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
            
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <literal>info</literal> subcommand:</para>

        <screen>
$ svnlook info path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <para>The output of the <literal>info</literal> subcommand is
          defined as:</para>

        <orderedlist>
          <listitem>
            <para>The author, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The date, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The number of characters in the log message,
              followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The log message itself, followed by a newline.</para>
          </listitem>
        </orderedlist>

        <para>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>

        <para>Another common use of <command>svnlook</command> is to
          actually view the contents of a revision or transaction
          tree.  Examining the output of <command>svnlook
          tree</command> command, which displays the directories and
          files in the requested tree (optionally showing the
          filesystem node revision IDs for each of those paths) can be
          extremely helpful to administrators deciding on whether or
          not it is safe to remove a seemingly dead transaction.  It
          is also quite useful for Subversion developers who are
          diagnosing filesystem-related problems when they
          arise.</para>

        <screen>
$ svnlook tree path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <para><command>svnlook</command> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <command>svnlook</command>,
          and the output of those subcommands:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <para>Print the tree's author.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <para>Print the tree's datestamp.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <para>List all files and directories that changed in the 
                tree.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <para>Print unified diffs of changed files.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <para>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <para>Print the tree's author, datestamp, log message
                character count, and log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <para>Print the tree's log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <para>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <para>Print the youngest revision number.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.2">
        <title>svnadmin</title>

        <para>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you perform several maintenance operations on those
          repositories.  The syntax of <command>svnadmin</command> is
          similar to that of <command>svnlook</command>:</para>

        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   createtxn
   dump
&hellip;
</screen>

        <para>We've already mentioned <command>svnadmin</command>'s
          <literal>create</literal> subcommand (see <xref
          linkend="svn-ch-5-sect-2"/>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <para>Creates a new Subversion repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>createtxn</literal></term>
            <listitem>
              <para>Creates a transaction in the repository based on a
                given existing revision.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <para>Dumps the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <para>Loads a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <literal>dump</literal> subcommand.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lscr</literal></term>
            <listitem>
              <para>List the revisions in which a given path in the
                repository was modified.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <para>List the names of uncommitted Subversion
                transactions which currently exist in the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <para>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred which prevented a process from cleanly
                shutting down its communication with the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <para>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <literal>lstxns</literal> subcommand).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <para>Replace the current value of the
                <literal>svn:log</literal> (commit log message)
                property on a given revision in the repository with a
                new value.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.3">
        <title>svnshell.py</title>

        <para>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <command>svnshell.py</command> Python script (located in
          <filename>tools/examples/</filename> in the source tree)
          uses Subversion's language bindings (so you have to have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</para>

        <para>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          <quote>positioned</quote> in the root directory of the HEAD
          revision of the repository, and presented with a command
          prompt.  You can use the <literal>help</literal> command at
          any time to display a list of available commands and what
          they do.</para>

        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <para>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&mdash;using the <literal>cd</literal> command.
          At all times, the command prompt will show you what revision
          (prefixed by <literal>rev:</literal>) or transaction
          (prefixed by <literal>txn:</literal>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <literal>setrev</literal> and
          <literal>settxn</literal> commands, respectively.  As in a
          Unix shell, you can use the <literal>ls</literal> command to
          display the contents of the current directory, and you can
          use the <literal>cat</literal> command to display the
          contents of a file.</para>

        <example id="svn-ch-7-sect-3.1.3-ex-1">
          <title>Using svnshell to navigate the repository</title>

          <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>
        </example>

        <para>As you can see in the previous example, multiple
          commands may be specified at a single command prompt,
          separated by a semicolon.  Also, the shell understands the
          notions of relative and absolute paths, and will properly
          handle the "<literal>.</literal>" and
          "<literal>..</literal>" special path components.</para>

        <para>The <literal>youngest</literal> command displays the
          youngest revision.  This is useful for determining the range
          of valid revisions you can use as arguments to the
          <literal>setrev</literal> command&mdash;you are allowed to
          browse all the revisions (recalling that they are named with
          integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <command>lstxns</command> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <command>svnadmin lstxns</command> returns, and the same
          list that is valid for use with <command>svnlook</command>'s
          <option>--transaction</option> option.</para>

        <para>Once you've finished using the shell, you can exit
          cleanly by using the <command>exit</command> command.
          Alternatively, you can supply an end-of-file
          character&mdash;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.4">
        <title>Berkeley DB Utilities</title>

        <para>Currently, the Subversion repository has only one
          database back-end&mdash;Berkeley DB.  All of your filesystem's
          structure and data live in a set of tables within the
          <filename>db</filename> subdirectory of your repository.
          This subdirectory is a regular Berkeley DB environment
          directory, and can therefore be used in conjunction with any
          of Berkeley's database tools (you can see the documentation
          for these tools at SleepyCat's website, <systemitem
          class="url">http://www.sleepycat.com/</systemitem>).  For
          day-to-day Subversion use, these tools are unnecessary,
          however, they do provide some important functionality that
          is currently not provided by Subversion itself.</para>
  
        <para>For example, because Subversion uses Berkeley DB's
          logging facilities, the database first writes out a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if something goes wrong, the database system can back up to
          a previous <firstterm>checkpoint</firstterm>&mdash;a
          location in the log files known not to be corrupt&mdash;and
          replay transactions until the data is restored to a usable
          state.  This functionality is one of the main reasons why
          Berkeley DB was chosen as Subversion's initial database
          back-end.</para>

        <para>Over time, these log files can accumulate.  That is
          actually a feature of the database system&mdash;you should
          be able to recreate your entire database using nothing but
          the log files, so these files are important for catastrophic
          database recovery.  But typically, you'll want to archive
          the log files that are no longer in use by Berkeley DB, and
          then remove them from disk to conserve space.  Berkeley DB
          provides a <command>db_archive</command> utility for, among
          other things, listing the log files that are associated with
          a given database and which are no longer in use.  That way,
          you know which files to archive and remove.</para>

        <para>Subversion's own repository uses a
          <literal>post-commit</literal> hook script, which, after
          performing a <quote>hot backup</quote> of the repository,
          removes these excess logfiles.  In the Subversion source
          tree, the script
          <filename>tools/backup/hot-backup.py</filename> illustrates
          the safe way to perform a backup of a Berkeley DB database
          environment while it's being actively accessed:  recursively
          copy the entire repository directory, then re-copy the
          logfiles listed by <command>db_archive -l</command>.</para>
            
        <para>Generally speaking, only the truly paranoid would need
          to backup their entire repository every time a commit
          occurred.  Subversion's repository is truly paranoid for what
          should be obvious reasons!  However, assuming that a given
          repository has some other redundancy mechanism in place with
          relatively fine granularity (per-commit, for example), a hot
          backup of the database might be something that a repository
          administrator would want to include as part of a system-wide
          nightly backup.  For more repositories, archived commit
          emails alone are sufficient restoration sources, at least
          for the last few commits.  But it's your data; protect it as
          much as you'd like.</para>
            
        <para>Berkeley DB also comes with a pair of utilities for
          converting the database tables to and from flat ASCII text
          files.  The <command>db_dump</command> and
          <command>db_load</command> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.</para>
        
      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.2">
      <title>Repository Cleanup</title>
            
      <para>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <command>svnadmin</command> utility provides some helpful
        functionality to assist you in performing such tasks as</para>

      <itemizedlist>
        <listitem>
          <para>modifying commit log messages,</para>
        </listitem>
        <listitem>
          <para>removing dead transactions,</para>
        </listitem>
        <listitem>
          <para>recovering <quote>wedged</quote> repositories, and</para>
        </listitem>
        <listitem>
          <para>migrating repository contents to a different
            repository.</para>
        </listitem>
      </itemizedlist>

      <para>Perhaps the most commonly used of
        <command>svnadmin</command>'s subcommands is
        <literal>setlog</literal>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</para>

      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks; see <xref
        linkend="svn-ch-5-sect-2.1"/>) to accept changes to this log
        message after the commit is finished, then the user can
        <quote>fix</quote> her log message remotely using the
        <command>svn</command> program's <literal>propset</literal>
        command (see <xref linkend="svn-ch-8"/>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&mdash; except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
          
      <screen>
$ echo "Here is the new, correct log message" > newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      
      <sidebar>
        <title>Don't Lose That Log Message!</title>
        
        <para>Administrators should be aware that using
          <command>svnadmin setlog</command> bypasses any revision
          property hook scripts that might be active for the
          repository.  Be extremely careful with this subcommand,
          ensuring that you are providing the correct revision number
          for the change.</para>
      </sidebar>

      <para>Another common use of <command>svnadmin</command> is to
        query the repository for outstanding&mdash;possibly
        dead&mdash;Subversion transactions.  In the event that commit
        should fail, the transaction is usually cleaned up.  That is,
        the transaction itself is removed from the repository, and any
        data associated with (and only with) that transaction is
        removed as well.  Occasionally, though, a failure occurs in
        such a way that the cleanup of the transaction never happens.
        This could happen for several reasons: perhaps the client
        operation was inelegantly terminated by the user, or a network
        failure might have occurred in the middle of an operation, etc.
        Regardless of the reason, these dead transactions serve only
        to clutter the repository and consume resources.</para>

      <para>You can use <command>svnadmin</command>'s
        <literal>lstxns</literal> command to list the names of the
        currently outstanding transactions.</para>

      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

      <para>Each item in the resultant output can then be used with
        <command>svnlook</command> (and its
        <option>--transaction</option> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&mdash;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <command>svnadmin rmtxns</command>, which will perform the
        cleanup of the transaction.  In fact, the
        <literal>rmtxns</literal> subcommand can take its input
        directly from the output of <literal>lstxns</literal>!</para>

      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

      <para>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</para>

      <example id="svn-ch-5-sect-3.2-ex-1">
        <title>txn-info.sh (reporting outstanding transactions)</title>

        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS=${1}
if [ x$REPOS = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info ${REPOS} --transaction ${TXN}
done
</programlisting>
      </example>

      <para>You can run the previous script using
        <command>/path/to/txn-info.sh /path/to/repos</command>.  The
        output is basically a concatenation of several chunks of
        <command>svnlook info</command> output (see <xref
        linkend="svn-ch-5-sect-3.1.1"/>), and will look something
        like:</para>

      <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

      <para>Usually, if you see a dead transaction that has no log
        message attached to it, this is the result of a failed update
        (or update-like) operation.  These operations use Subversion
        transactions under the hood to mimic working copy state.
        Since they are never intended to be committed, Subversion
        doesn't require a log message for those transactions.
        Transactions that do have log messages attached are almost
        certainly failed commits of some sort.  Also, a transaction's
        datestamp can provide interesting information&mdash;for
        example, how likely is it that an operation begun nine months
        ago is still active?</para>

      <para>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&mdash;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&mdash;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.3">
      <title>Repository recovery</title>

      <para>In order to protect the data in your repository, the
        database back-end uses a locking mechanism.  This mechanism
        ensures that portions of the database are not simultaneously
        modified by multiple database accessors, and that each process
        sees the data in the correct state when that data is being
        read from the database.  When a process needs to change
        something in the database, it first checks for the existence
        of a lock on the target data.  If the data is not locked, the
        process locks the data, makes the change it wants to make, and
        then unlocks the data.  Other processes are forced to wait
        until that lock is removed before they are permitted to
        continue accessing that section of the database.</para>

      <para>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets <quote>wedged</quote>.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&mdash;which isn't going to happen).</para>

      <para>First, if this happens to your repository, don't panic.
        Subversion's filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>e.g.: hard drive + huge electromagnet = disaster</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</para>

      <para>Secondly, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
              
          <screen>
Acquiring exclusive lock on repository db, and running recovery procedures.
Please stand by...
Recovery completed.
The latest repos revision is 19.
</screen>
        </listitem>
        <listitem>
          <para>Restart the Subversion server.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion developer list (at
        <email>dev@subversion.tigris.org</email>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.4">
      <title>Migrating a repository</title>
    
      <para>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <command>svnadmin</command> subcommands:
        <literal>dump</literal> and <literal>load</literal>.</para>

      <para>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  The
        recommended course of action when you are upgrading across one
        of those compatibility boundaries is a relatively simple
        process:</para>
  
      <orderedlist>
        <listitem>
          <para>Using your <emphasis>current</emphasis> version of
            <command>svnadmin</command>, dump your repositories to
            dump files.</para>
        </listitem>
        <listitem>
          <para>Upgrade to the new version of Subversion.</para>
        </listitem>
        <listitem>
          <para>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <emphasis>new</emphasis> <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <para>Again using your <emphasis>new</emphasis>
            <command>svnadmin</command>, load your dump files into
            their respective, just-created repositories.</para>
        </listitem>
        <listitem>
          <para>Finally, be sure to copy any customizations from your
            old repositories to the new ones, including
            <filename>DB_CONFIG</filename> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</para>
        </listitem>
      </orderedlist>

      <para><command>svnadmin dump</command> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</para>

      <screen>
$ svnadmin youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>

      <screen>
$ svnadmin dump myrepos --revision 23 > rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 > revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos 0 1000 > dumpfile1
$ svnadmin dump myrepos 1001 2000 --incremental > dumpfile2
$ svnadmin dump myrepos 2001 3000 --incremental > dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository with
        the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script like the
        following that runs nightly to append dump file data for all
        the revisions that were added to the repository since the last
        time the script ran.</para>

      <example id="svn-ch-5-sect-3.4-ex-1">
        <title>Using incremental repository dumps</title>

        <programlisting>
#!/usr/bin/perl

$repos_path  = '/path/to/repos';
$dumpfile    = '/usr/backup/svn-dumpfile';
$last_dumped = '/var/log/svn-last-dumped';
 
# Figure out the starting revision (0 if we cannot read the last-dumped file,
# else use the revision in that file incremented by 1).
if (open LASTDUMPED, "$last_dumped")
{
    $new_start = &lt;LASTDUMPED&gt;;
    chomp $new_start;
    $new_start++;
    close LASTDUMPED;
}
else
{
    $new_start = 0;
}

# Query the youngest revision in the repos.
$youngest = `svnlook youngest $repos_path`;
chomp $youngest;

# Do the backup.
`svnadmin dump $repos_path $new_start $youngest --incremental >> $dumpfile`;

# Store a new last-dumped revision
open LASTDUMPED, "&gt; $last_dumped" or die;
print LASTDUMPED "$youngest\n";
close LASTDUMPED;

# All done!
</programlisting>
      </example>

      <para>Used like this, <command>svnadmin</command>'s
        <literal>dump</literal> and <literal>load</literal> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</para>

      <para>Finally, another possible use of the Subversion repository
        dump file format is conversion from a different storage
        mechanism or version control system altogether.  Because the
        dump file format is, for the most part, human-readable,
        <footnote>
          <para>The Subversion repository dump file format resembles
            an RFC-822 format, the same type of format used for most
            email.</para>
        </footnote>
        it should be relatively easy to describe generic sets of
        changes&mdash;each of which should be treated as a new
        revision&mdash;using this file format.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.5">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies your repository
        data.</para>

      <para>There are generally two types of backup methods available
        for Subversion repository administrators&mdash;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <command>svnadmin dump --incremental</command> to
        perform an incremental backup (see <xref
        linkend="svn-ch-5-sect-3.4" />).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</para>

      <para>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        the Berkeley database environment).  Now, unless you
        temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a defunct backup, since someone might be currently
        writing to the database.</para>

      <para>Fortunately, Sleepycat's Berkeley DB documents describe a
        certain order in which database files can be copied which will
        guarantee a valid backup copy.  And better still, you don't
        have to implement that algorithm yourself, because the
        Subversion development team has already done so.  The
        <command>hot-backup.py</command> script is found in the
        <filename>tools/backup/</filename> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <command>hot-backup.py</command> will perform the
        necessary steps for backing up your live
        repository&mdash;without requiring that you bar public
        repository access at all&mdash;and then will clean out the
        dead Berkeley logfiles from your live repository.</para>

      <para>Even if you also have an incremental backup, you might want to run
        this program on a regular basis.  For example, you might
        consider adding <command>hot-backup.py</command> to a program
        scheduler (such as <command>crond</command> on Unix systems).
        Or, if you prefer fine-grained backup solutions, you could
        have your post-commit hook script call
        <command>hot-backup.py</command> (see <xref
        linkend="svn-ch-5-sect-2.1" />), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <filename>hooks/post-commit</filename> script in your live
        repository directory:</para>

      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>

      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</para>

      <para>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        full repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&mdash;and
        restoration from&mdash;incremental backups takes longer, as
        each commit is effectively replayed into either the dumpfile
        or the repository.</para>

      <para>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command>, for example,
            bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>

      <para>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  NETWORKING A REPOSITORY                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-4">
    <title>Networking a Repository</title>
          
    <para>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides.  But the typical Subversion setup involves a single
      server machine being accessed from clients on computers all over
      the office&mdash;or, perhaps, all over the world.</para>
 
    <para>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover each of Subversion's currently available server
      mechanisms, discussing the configuration and use of each one.
      After reading this section, you should be able to decide which
      networking setup is right for your needs, and understand how to
      enable such a setup on your host computer.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.1">            
      <title><command>httpd</command>, the Apache HTTP Server</title>

      <para>Subversion's primary network server is the Apache HTTP
        Server (<command>httpd</command>), speaking the WebDAV/deltaV
        protocol.  This protocol (an extension to HTTP 1.1; see
        <systemitem class="url">http://www.webdav.org/</systemitem>)
        takes the ubiquitous HTTP protocol that is core of the World
        Wide Web, and adds writing&mdash;specifically, versioned
        writing&mdash;capabilities.  The result is a standardized,
        robust system that is conveniently packaged as part of the
        Apache 2.0 software, is supported by numerous pieces of core
        operating system and third-party products, and which doesn't
        require network administrators to open up yet another custom
        port.
        <footnote>
          <para>They really hate doing that.</para>
        </footnote>
      </para>

      <para>Much of the following discussion includes references to
        Apache configuration directives.  While some examples are
        given of the use of these directives, describing them in full
        is outside the scope of this chapter.  The Apache team
        maintains excellent documentation, publicly available on their
        website at <systemitem
        class="url">http://httpd.apache.org</systemitem>.  For
        example, a general reference for the configuration directives
        is located at <systemitem
        class="url">http://httpd.apache.org/docs-2.0/mod/directives.html</systemitem>.)</para>
              
      <para>Also, as you make changes to your Apache setup, it is
        likely that somewhere along the way a mistake will be made.
        If you are not already familiar with Apache's logging
        subsystem, you should become aware of it.  In your
        <filename>httpd.conf</filename> file are directives which
        specify the on-disk locations of the access and error logs
        generated by Apache (the <literal>CustomLog</literal> and
        <literal>ErrorLog</literal> directives, respectively).
        Subversion's mod_dav_svn uses Apache's error logging interface
        as well.  You can always browse the contents of those files
        for information that might reveal the source of a problem
        which is not clearly noticeable otherwise.</para>

      <sect3 id="svn-ch-5-sect-4.1.1">            
        <title>What You Need for HTTP-based Repository Access</title>
  
        <para>To network your repository over HTTP, you basically need
          four components, available in two packages.  You'll need
          Apache <command>httpd</command> 2.0, the
          <command>mod_dav</command> DAV module that comes with it,
          Subversion, and the <command>mod_dav_svn</command>
          filesystem provider module distributed with Subversion.
          Once you have all of those components, the process of
          networking your repository is as simple as:</para>
  
        <itemizedlist>
          <listitem>
            <para>getting httpd 2.0 up and running with the mod_dav
              module,</para>
          </listitem>
          <listitem>
            <para>installing the mod_dav_svn plugin to mod_dav, which
              uses Subversion's libraries to access the repository,
              and</para>
          </listitem>
          <listitem>
            <para>configuring your <filename>httpd.conf</filename>
              file to export (or expose) the repository.</para>
          </listitem>
        </itemizedlist>
    
        <para>You can accomplish the first two items either by
          compiling <command>httpd</command> and Subversion from
          source code, or by installing pre-built binary packages of
          them on your system.  For the most up-to-date information on
          how to compile Subversion for use with Apache HTTP Server,
          as well as how to compile and configure Apache itself for
          this purpose, see the <filename>INSTALL</filename> file in
          the top level of the Subversion source code tree.</para>
  
      </sect3>  
  
      <sect3 id="svn-ch-5-sect-4.1.2"> 
        <title>Basic Apache Configuration</title>
  
        <para>Once you have all the necessary components installed on
          your system, all that remains is the configuration of Apache
          via its <filename>httpd.conf</filename> file.  Instruct
          Apache to load the mod_dav_svn module using the
          <literal>LoadModule</literal> directive.  This directive
          must precede any other Subversion-related configuration
          items.  If your Apache was installed using the default
          layout, your <command>mod_dav_svn</command> module should
          have been installed in the <filename>modules</filename>
          subdirectory of the Apache install location (often
          <filename>/usr/local/apache2</filename>).  The
          <literal>LoadModule</literal> directive has a simple syntax,
          mapping a named module to the location of a shared library
          on disk:</para>
    
        <screen>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</screen>

        <para>Note that if <command>mod_dav</command> was compiled as
          a shared object (instead of statically linked, directly to
          the <command>httpd</command> binary), you'll need a similar
          <literal>LoadModule</literal> statement for it, too.</para>
    
        <para>At a later location in your configuration file, you now
          need to tell Apache where you keep your Subversion
          repository (or repositories).  The
          <literal>Location</literal> directive has an XML-like
          notation, starting with an opening tag, and ending with a
          closing tag, with various other configuration directives in
          the middle.  The purpose of the <literal>Location</literal>
          directive is to instruct Apache to do something special when
          handling requests that are directed at a given URL or one of
          its children.  In the case of Subversion, you want Apache to
          simply hand off support for URLs that point at versioned
          resources to the DAV layer.  You can instruct Apache to
          delegate the handling of all URLs whose path portions (the
          part of the URL that follows the server's name and the
          optional port number) begin with
          <filename>/repos/</filename> to a DAV provider whose
          repository is located at
          <filename>/absolute/path/to/repository</filename> using the
          following <filename>httpd.conf</filename> syntax:</para>
                
        <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</screen>
            
        <para>If you plan to support multiple Subversion repositories
          that will reside in the same parent directory on your local
          disk, you can use an alternative directive, the
          <literal>SVNParentPath</literal> directive, to indicate that
          common parent directory.  For example, if you know you will
          be creating multiple Subversion repositories in a directory
          <filename>/usr/local/svn</filename> that would be accessed
          via URLs like <systemitem
          class="url">http://my.server.com/svn/repos1</systemitem>,
          <systemitem
          class="url">http://my.server.com/svn/repos2</systemitem>,
          and so on, you could use the <filename>httpd.conf</filename>
          configuration syntax in the following example:</para>
              
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</screen>
            
        <para>Using the previous syntax, Apache will delegate the
          handling of all URLs whose path portions begin with
          <filename>/svn/</filename> to the Subversion DAV provider,
          which will then assume that any items in the directory
          specified by the <literal>SVNParentPath</literal> directive
          are actually Subversion repositories.  This is a
          particularly convenient syntax in that, unlike the use of
          the <filename>SVNPath</filename> directive, you don't have
          to restart Apache in order to create and network new
          repositories.</para>
  
      </sect3>
  
      <sect3 id="svn-ch-5-sect-4.1.3"> 
        <title>Permissions, Authentication, and Authorization</title>
    
        <para>At this stage, you should strongly consider the question
          of permissions.  If you've been running Apache for some time
          now as your regular web server, you probably already have a
          collection of content&mdash;web pages, scripts and such.
          These items have already been configured with a set of
          permissions that allows them to work with Apache, or more
          appropriately, that allows Apache to work with those files.
          Apache, when used a Subversion server, will also need the
          correct permissions to read and write to your Subversion
          repository.</para>
    
        <para>You will need to determine a permission system setup
          that satisfies Subversion's requirements without messing up
          any previously existing web page or script installations.
          This might mean changing the permissions on your Subversion
          repository to match those in use by other things the Apache
          serves for you, or it could mean using the
          <literal>User</literal> and <literal>Group</literal>
          directives in <filename>httpd.conf</filename> to specify
          that Apache should run as the user and group that owns your
          Subversion repository.  There is no single correct way to
          set up your permissions, and each administrator will have
          different reasons for doing things a certain way.  Just be
          aware that permission-related problems are perhaps the most
          common oversight when configuring a Subversion repository
          for use with Apache.</para>
    
        <para>And while we are speaking about permissions, we should
          address how the authorization and authentication mechanisms
          provided by Apache fit into the scheme of things.  Unless
          you have some system-wide configuration of these things, the
          Subversion repositories you make available via the
          <filename>Location</filename> directives will be generally
          accessible to everyone.  In other words,</para>
                
        <itemizedlist>
          <listitem>
            <para>anyone can use their Subversion client to checkout a
              working copy of a repository URL (or any of its
              subdirectories),</para>
          </listitem>
          <listitem>
            <para>anyone can interactively browse the repository's
              latest revision simply by pointing their web browser to
              the repository URL, and</para>
          </listitem>
          <listitem>
            <para>anyone can commit to the repository.</para>
          </listitem>
        </itemizedlist>
  
        <para>If you want to restrict either read or write access to a
          repository as a whole, you can use Apache's built-in access
          control features.  The easiest such feature is the Basic
          authentication mechanism, which simply uses a username and
          password to verify that a user is who she says she is.
          Apache provides an <command>htpasswd</command> utility for
          managing the list of acceptable usernames and passwords,
          those to whom you wish to grant special access to your
          Subversion repository.  Let's grant commit access to Sally
          and Harry.  First, we need to add them to the password
          file.</para>
    
        <screen>
$ ### First time: use -c to create the file
$ htpasswd -c /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>

        <para>Next, you need to add some more
          <filename>httpd.conf</filename> directives inside your
          <literal>Location</literal> block to tell Apache what to do
          with your new password file.  The
          <literal>AuthType</literal> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <literal>Basic</literal> authentication system.
          <literal>AuthName</literal> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <literal>AuthUserFile</literal> directive to specify
          the location of the password file you created using
          <command>htpasswd</command>.</para>
    
        <para>After adding these three directives, your
          <literal>&lt;Location&gt;</literal> block should look
          something like this:</para>
    
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
</screen>

        <para>Now, at this stage, if you were to restart Apache, any
          Subversion operations which required authentication would
          harvest a username and password from the Subversion client,
          which would either provide previously cached values for
          these things, or prompt the user for the information.  All
          that remains is to tell Apache which operations actually
          require that authentication.</para>
  
        <para>You can restrict access on all repository operations by
          adding the <literal>Require valid-user</literal> directive
          to your <literal>&lt;Location&gt;</literal> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <literal>harry</literal> or
          <literal>sally</literal>, and which provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository.</para>
    
        <para>Sometimes you don't need to run such a tight ship.  The
          repository at <systemitem
          class="url">http://svn.collab.net/repos/svn</systemitem>
          which holds the Subversion source code, for example, allows
          anyone in the world to perform read-only repository tasks
          (like checking out working copies and browsing the
          repository with a web browser), but restricts all write
          operations to authenticated users.  To do this type of
          selective restriction, you can use the
          <literal>Limit</literal> and <literal>LimitExcept</literal>
          configuration directives.  Like the
          <literal>Location</literal> directive, these blocks have
          starting and ending tags, and you would nest them inside
          your <filename>&lt;Location&gt;</filename> block.</para>
  
        <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <literal>LimitExcept</literal> directive,
          passing the <literal>GET</literal>,
          <literal>PROPFIND</literal>, <literal>OPTIONS</literal>, and
          <literal>REPORT</literal> request type parameters.  Then the
          previously mentioned <literal>Require valid-user</literal>
          directive would be placed inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
          inside the <literal>&lt;Location&gt;</literal> block.</para>
    
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</screen>

        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <systemitem
          class="url">http://httpd.apache.org/docs-2.0/misc/tutorials.html</systemitem>.</para>
              
      </sect3>
  
      <sect3 id="svn-ch-5-sect-4.1.4">
        <title>Server Names and the COPY Request</title>
  
        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>
  
        <screen>
ServerName svn.red-bean.com
</screen>
            
        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</para>
  
      </sect3> 

      <sect3 id="svn-ch-5-sect-4.1.5">
        <title>Browsing the HEAD of the Repository</title>

        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue a <literal>GET</literal> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</para>

        <para>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</para>

        <para>You generally will get more use out of URLs to versioned
          files&mdash;after all, that's where the interesting content
          tends to lie.  But you might have occasion to browse a
          Subversion directory listing, where you'll quickly note that
          the generated HTML used to display that listing is very
          basic, and certainly not intended to be aesthetically
          pleasing (or even interesting).  To enable customization of
          these directory displays, Subversion provides an XML index
          feature.  A single <literal>SVNIndexXSLT</literal> directive
          in your repository's <literal>Location</literal> block of
          <filename>httpd.conf</filename> will instruct mod_dav_svn to
          generate XML output when displaying a directory listing, and
          to reference the XSLT stylesheet of your choice:</para>
 
        <screen>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &hellip;
&lt;/Location&gt;
</screen>

        <para>Using the <literal>SVNIndexXSLT</literal> directive and
          a creative XSLT stylesheet, you can make your directory
          listings match the color schemes and imagery used in other
          parts of your website.  Or, if you'd prefer, you can use the
          sample stylesheets provided in the Subversion source
          distribution's <filename>tools/xslt/</filename> directory.
          Keep in mind that the path provided to the
          <literal>SVNIndexXSLT</literal> directory is actually a URL
          path&mdash;browsers need to be able to read your stylesheets
          in order to make use of them!</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-4.1.6">
        <title>Miscellaneous Apache Features</title>
  
        <para>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the secure socket layer) and Deflate compression
          (the same algorithm used by the <command>gzip</command> and
          <command>PKZIP</command> programs to <quote>shrink</quote>
          files into smaller chunks of data).  You need only to
          compile support for the features you desire into Subversion
          and Apache, and properly configure the programs to use those
          features.</para>
  
        <para>This means that SSL-enabled Subversion clients can
          access SSL-enabled Apache servers and perform all
          communication using an encrypted protocol, all by using
          <literal>https:</literal> URLs with their Subversion clients
          instead of <literal>http:</literal> ones.  Businesses that
          need to expose their repositories for access outside the
          company firewall should be conscious of the possibility that
          unauthorized parties could be <quote>sniffing</quote> their
          network traffic.  SSL makes that kind of unwanted attention
          less likely to result in sensitive data leaks.  Apache can
          be configured such that only SSL-enabled Subversion clients
          can communicate with the repository.</para>
  
        <para>Deflate compression places a small burden on the client
          and server to compress and decompress network transmissions
          as a way to minimize the size of the actual transmission.
          In cases where network bandwidth is in short supply, this
          kind of compression can greatly increase the speed at which
          communications between server and client can be sent.  In
          extreme cases, this minimized network transmission could be
          the difference between an operation timing out or completing
          successfully.</para>
  
        <para>Less interesting, but equally useful, are other features
          of the Apache and Subversion relationship, such as the
          ability to specify a custom port (instead of the default
          HTTP port 80) or a virtual domain name by which the
          Subversion repository should be accessed, or the ability to
          access the repository through a proxy.  These things are all
          supported by Neon, so Subversion gets that support for
          free.</para>
  
      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.2">
      <title><command>svnserve</command>, a Custom Subversion Server</title>

      <para>As an alternative to Apache, Subversion also provides a
        stand-alone server program, <command>svnserve</command>.  This
        program is considerably more lightweight than Apache, and
        easier to configure.  It speaks a custom protocol with the svn
        client over an ordinary TCP/IP connection, listening for
        incoming requests on port 3690.
        <footnote>
          <para>This port number has been assigned by the Internet Assigned
            Numbers Authority (IANA).</para>
        </footnote>
        Clients access the server with libsvn_ra_svn, using the
        <literal>svn://</literal> URL schema.</para>

      <sect3 id="svn-ch-5-sect-4.2.1">
        <title>Running <command>svnserve</command></title>

        <para>When run with no switches, <command>svnserve</command>
          makes your entire disk available to the network.  In other
          words, if a client tries to checkout <systemitem
          class="url">svn://example.com/usr/local/repos/project</systemitem>,
          an <command>svnserve</command> process running on
          example.com would look for a repository at the absolute path
          <filename>/usr/local/repos/project</filename>.  To increase
          security, you can pass the <option>-r</option> option to
          <command>svnserve</command>, which restricts it to exporting
          only repositories below that path:</para>

        <screen>
$ svnserve -r /usr/local
&hellip;
</screen>

        <para>Using the <option>-r</option> option effectively
          modifies the location that the program treats as the root of
          the versioned filesystem space.  Clients then use URLs that
          have that path portion removed from them, leaving much
          shorter (and much less revealing) URLs:</para>

        <screen>
$ svn checkout svn://example.com/repos/projects
&hellip;
</screen>

        <para>To disable write access for your repositories, start
          <command>svnserve</command> with the <option>-R</option>
          option.  This will permit only read operations on the data
          in your repository.</para>

        <para>You can have <command>svnserve</command> run in one of a
          couple of different ways.  One option is to run as a sort of
          <quote>one-off</quote> server process&mdash;initiated by the
          <command>inetd</command> daemon on Unix systems.  To do
          this, add port 3690 to your
          <filename>/etc/services</filename> file, if not already
          present:</para>

        <screen>
svn    3690/tcp   # Subversion server
</screen>

        <para>Then instruct inetd daemon to launch an
          <command>svnserve</command> process to handle incoming
          requests on that port by adding this line to
          <filename>/etc/inetd.conf</filename>:</para>

        <screen>
svn  stream  tcp  nowait  root  /usr/local/bin/svnserve -r /repos/root
</screen>
      
        <para>Of course, you may not want to launch the
          <command>svnserve</command> process as root.  Depending on
          the ownership and permissions of the repositories you're
          exporting, a different&mdash;perhaps custom&mdash;user might
          be more appropriate.  For example, you might wish to create
          a new user named <literal>svn</literal>, grant that user
          exclusive rights to the Subversion repositories, and
          configure your <command>svnserve</command> processes to run
          as that user.</para>

        <para>Another option is to run <command>svnserve</command> as
          a standalone daemon process.  When started with the
          <option>-d</option> option, <command>svnserve</command> will
          immediately detach from the current shell process, and will
          execute as a background process which runs indefinitely,
          again waiting for incoming requests on port 3690.</para>

        <screen>
$ svnserve -r /usr/local -d
$ # svnserve is still running, but the user is returned to the prompt 
</screen>

      </sect3>

      <sect3 id="svn-ch-5-sect-4.2.2">
        <title>ra_svn authentication</title>

        <para>When a client connects makes a network connection to the
          <command>svnserve</command> process (either as a daemon, or
          launched as a <quote>one-off</quote>), no authentication
          takes place at all.  The server process accesses the
          repository as whatever user it's running as, and if the
          client performs a commit, the new revision uses the username
          <literal>anonymous</literal> as the author of the
          commit.</para>

        <para>Of course, it is generally interesting to know which
          user (of a potentially unbounded number of users) is
          responsible for a set of changes.  To accomplish this,
          clients using libsvn_ra_svn can tunnel their entire session
          over SSH or another similar protocol.  To do this, edit your
          <filename>servers</filename> run-time configuration file to
          instruct your client to tunnel its network communications
          when you are accessing repositories that are served using
          <command>svnserve</command>.  Simply add a new group to the
          <literal>groups</literal> section of that file whose value
          is the name of the server you'll be communicating with, and
          then create a new section using your newly created group's
          name.  Inside the section, define the
          <literal>svn-tunnel-agent</literal> option to mentioned the
          name of the tunneling agent program.  In the case of SSH
          tunneling, this is typically the <command>ssh</command>
          program.</para>

        <example id="svn-ch-5-sect-4.2.2-ex-1">
          <title>Using an ssh tunnel-agent</title>

          <programlisting>
[groups]
mygroup = foo.bar.com
          
[mygroup]
svn-tunnel-agent = ssh
</programlisting>
        </example>
        
        <para>Now when you use your Subversion client to access that
          repository, its network communications with
          <command>svnserve</command> will be tunneled using the
          configured tool.  If that tool requires authentication,
          <command>svnserve</command> will use the authenticated
          username as the author of any modifications you
          perform.</para>

        <para>For more information about setting up the
          <filename>servers</filename> run-time configuration file,
          see <xref linkend="svn-ch-6-sect-1.3.1"/>.</para>

      </sect3>
    </sect2>

    <sect2 id="svn-ch-5-sect-4.3">
      <title>Which server to use?</title>

      <para>When choosing between Apache HTTP Server and the custom
        <command>svnserve</command> program, there is no single
        correct decision.  Depending on your particular requirements,
        one of the available solutions might seem more right for you.
        And in fact, these servers can run in parallel, each accessing
        your repositories in its own way, and each without hindering
        the other.  To recap the previous two sections, here's a brief
        list of the highlist of the two available Subversion
        servers&mdash;choose whatever works best for you and your
        users.</para>
      
      <variablelist>
        <varlistentry>
          <term>Apache/mod_dav_svn</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>No need to create system accounts</para>
              </listitem>
              <listitem>
                <para>No need to open a new firewall port</para>
              </listitem>
              <listitem>
                <para>Built-in repository web browsing (limited)</para>
              </listitem>
              <listitem>
                <para>Limited interoperability with other WebDAV clients</para>
              </listitem>
              <listitem>
                <para>Ability to use caching HTTP proxies</para>
              </listitem>
              <listitem>
                <para>Vastly expandable:  access to numerous existing
                  authentication and authorization methods, encryption,
                  compression, etc.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svnserve</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Vastly easier to configure and run than Apache</para>
              </listitem>
              <listitem>
                <para>Can use existing SSH security infrastructure</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 5:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-5">
    <title>Adding projects</title>

    <para>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <command>svn</command>
      client program's <literal>import</literal> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-5.1">
      <title>Choosing a Repository Layout</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <quote>laying out</quote>
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</para>

      <para>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</para>

     <para>There are benefits to using a single repository for
       multiple projects, most obviously the lack of duplicated
       maintenance.  A single repository means that there is one set
       of hook scripts, one thing to routinely backup, one thing to
       dump and load if Subversion releases an incompatible new
       version, and so on.  Also, you can easily move data between
       projects easily, and without losing any historical versioning
       information.</para>

     <para>The downside of using a single repository is that different
       projects may have different commit mailing lists or different
       authentication and authorization requirements.  Also, remember
       that Subversion uses repository-global revision numbers.  Some
       folks don't like the fact that even though no changes have been
       made to their project lately, the youngest revision number for
       the repository keeps climbing because other projects are
       actively adding new revisions.</para>

     <para>A middle-ground approach can be taken, too.  For example,
       projects can be grouped by how well they relate to each other.
       You might have a few repositories with a handful of projects in
       each repository.  That way, projects that are likely to want to
       share data can do so easily, and as new revisions are added to
       the repository, at least the developers know that those new
       revisions are at least remotely related to everyone who uses
       that repository.</para>

     <para>After deciding how to organize your projects with respect
       to repositories, you'll probably want to think about directory
       hierarchies in the repositories themselves.  Because Subversion
       uses regular directory copies for branching and tagging (see
       <xref linkend="svn-ch-4"/>), the Subversion community
       recommends using one of two different approaches here.  Both
       approaches employ the use of directories named
       <filename>trunk</filename>, meaning the directory under which
       the main project development occurs, and
       <filename>branches</filename>, which is a directory in which to
       create various named branches of the main development line.</para>

     <para>The first is to place each project in a subdirectory of the
       root filesystem directory, with <filename>trunk</filename> and
       <filename>branches</filename> directories immediately under
       each project directory, as demonstrated in Figure 5-1.</para>

      <figure id="svn-ch5-sect5.1-dia1">
        <title>One suggested repository layout.</title>
        <graphic fileref="images/ch05dia1.png"/>
      </figure>

     <para>The second is do the reverse&mdash;to have the
       <filename>trunk</filename> and <filename>branches</filename>
       directories immediately in the top level of the filesystem,
       each with subdirectories for all the projects in the
       repository, as demonstrated in Figure 5-2.</para>

      <figure id="svn-ch5-sect5.1-dia2">
        <title>Another suggested repository layout.</title>
        <graphic fileref="images/ch05dia2.png"/>
      </figure>

      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets your needs and those of the projects that live
        there.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-5.2">
      <title>Creating the Layout, and Importing Initial Data</title>
          
      <para>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <command>svn mkdir</command> command (see <xref
        linkend="svn-ch-8"/><!-- ###TODO fix link -->) to create each directory in
        your skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <command>svn
        import</command> command (see <xref
        linkend="svn-ch-3-sect-7.3"/>.  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</para>
            
      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
&hellip;
$ svn import file:///path/to/repos . --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches

Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <para>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <command>svn import</command>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <command>svn add</command> and <command>svn
        commit</command> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <command>svn</command> client program, see <xref
        linkend="svn-ch-3"/>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  SUMMARY                                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-6">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  We've covered some of the basic Apache configuration
      steps necessary for making your repository accessible over a
      network.  And throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
