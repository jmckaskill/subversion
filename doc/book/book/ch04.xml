<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-4">
<title>Branching and Merging</title>

  <simplesect>

    <para>Branches and tags are general concepts common to almost all
      version control systems.  If you're not familiar with these
      ideas, you can find a good introductory explanation in Karl
      Fogel's free CVS book: <systemitem
      class="url">http://cvsbook.red-bean.com/cvsbook.html#Branching_Basics</systemitem></para><!--
      ###TODO we should write this part, not point to Karl's book. :)
      -Fitz -->

    <para>At this point, you should understand how each commit creates
      an entire new filesystem tree in the repository.  (If not, read
      revisions, <xref linkend="svn-ch-2"/><!-- ###TODO Make this xref
      (Transactions and Revision Numbers) more specific -Fitz -->,
      <xref linkend="svn-ch-2"/><!-- ###TODO Make this xref (Revision
      numbers are different now) more specific -Fitz -->.)</para>

    <para>As you may have suspected, the filesystem doesn't grow 652
      new inodes each time a new revision is created.  Instead, each
      new tree is <emphasis>mostly</emphasis> made of pointers to
      already-existing nodes; new nodes are created only for changed
      items, and all the rest of the revision tree is <quote>shared
      storage</quote> with other revision trees.  This technique
      demonstrates how the filesystem is able to make <quote>cheap
      copies</quote> of things.  These cheap copies are nothing more
      than directory entries that point to existing nodes.  And this
      is the basis of tags and branches.</para>

  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-1">
    <title>Branching with svn cp</title> 
    
    <para>Suppose we have a repository whose head tree is revision 82.
      In this repository is a subdirectory <filename>mooIRC</filename>
      that contains a software project that is ready to be tagged.
      How do we tag it?  Very simple: make a <quote>cheap</quote> copy
      of this directory.  In other words, create a new directory entry
      (somewhere else in the filesystem) that points to this
      <emphasis>specific</emphasis> node that represents directory
      <filename>mooIRC</filename> in revision 82.  Of course, you can
      name the new directory entry whatever you want -- probably a
      tag-name like <filename>mooIRC-beta</filename>.</para>
    
    <para>The easiest way to make this copy is with <command>svn
      cp</command>, which, incidentally, can operate entirely on URLs,
      so that the copy happens only on the server-side:</para>

    <screen>
      $ svn cp http://foo.com/repos/mooIRC http://foo.com/repos/mooIRC-beta
      Committed revision 83.
    </screen>

    <para>Now, as long as you never touch the contents of the
      directory <filename>mooIRC-beta</filename>, that entry will
      forever point to a node that looks the way
      <filename>mooIRC</filename> did at a specific moment in time
      (however it looked in revision 82).  And that's exactly what a
      <firstterm>tag</firstterm> is.</para>

    <para>But suppose <filename>mooIRC-beta</filename> isn't sacred,
      and instead you decide to start making commits to it.  And
      suppose you <emphasis>also</emphasis> continue to make commits
      in the original <filename>mooIRC</filename> directory.  Then you
      have two directories that started out looking identical -- their
      common ancestor was <filename>mooIRC</filename> in revision 82
      -- but now have diverged their contents over time.  In other
      words, they represent different <firstterm>branches</firstterm>
      of the project.</para>

    <para>It's very important to note that the Subversion filesystem
      is <emphasis>not</emphasis> aware of <quote>tags</quote> or
      <quote>branches.</quote> It's only aware of directories, and all
      directories are equal.  The tag and branch concepts are purely
      <emphasis>human</emphasis> meanings attached to particular
      directories.</para>

    <para>For this reason, it's up to users (and the Subversion
      repository administrator) to choose sane policies that help
      elucidate these labels.  For example, here's a good way to lay
      out your repository:</para>

    <screen>
      /
      /projectA
      /projectA/trunk/
      /projectA/branches/
      /projectA/tags/
      /projectB
      /projectB/trunk/
      /projectB/branches/
      /projectB/tags/
    </screen>

    <para>Each time <filename>/projectA/trunk</filename> reaches a
      taggable state, make a copy of the directory somewhere in
      <filename>/projectA/tags/</filename>, and set the copy to
      read-only.  Use the same procedure to create a branch in
      <filename>/projectA/branches/</filename>.</para>

    <para>An alternate way to lay out a repository:</para>

    <screen>
      /
      /trunk
      /trunk/projectA
      /trunk/projectB
      /branches
      /branches/projectA
      /branches/projectB
      /tags
      /tags/projectA
      /tags/projectB
    </screen>

    <para>Or, of course, you could just place each project into a
      dedicated repository.  It's up to you.  For examples on how to
      create a repository with one of these structures, <xref
      linkend="svn-ch-5"/><!-- ###TODO Make this xref (Creating a
      repository) more specific -Fitz -->.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-2">
    <title>Switching to a Branch with svn switch</title>

    <para>The <command>svn switch</command> command allows you to
      <quote>move</quote> some or all of your working copy to a branch
      or tag.  For example, suppose I have a working copy of
      <filename>mooIRC</filename>, and I'd like to work on some
      subsystem as it appears in a subdirectory of
      <filename>mooIRC-beta</filename>.  At the same time, I want the
      rest my working copy to remain on the original
      <filename>mooIRC</filename> branch.  To do this, I switch the
      appropriate subdir to the new branch location:</para>

    <screen>
      $ svn switch http://foo.com/repos/mooIRC-beta/subsystems/renderer \
                   mooIRC/subsystems/renderer
      
      U  mooIRC/subsystems/renderer/foo.c
      U  mooIRC/subsystems/renderer/bar.h
      U  mooIRC/subsystems/renderer/baz.c
    </screen>

    <para>Now my working copy of the <filename>renderer</filename>
      subdirectory represents a different location on the
      server.</para>

    <para>Really, <command>svn switch</command> is just a fancier
      version of <command>svn update</command>.  Whereas <command>svn
      update</command> has the ability to move your working copy
      through time (either by updating to the latest revision, or by
      updating to a specific revision given with
      <option>-r</option>), <command>svn switch</command> is
      able to move your working copy through time
      <emphasis>and</emphasis> space.</para>

    <para>If your working copy contains a number of
      <quote>switched</quote> subtrees from different repository
      locations, it continues to function as normal.  When you update,
      you'll receive patches to each subtree as appropriate.  When you
      commit, your local changes will still be applied as a single,
      atomic change to the repository.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-3">
    <title>Moving changes with svn merge</title>

    <para>Suppose a team of programmers working on the
      <filename>mooIRC-beta</filename> branch have fixed a critical
      bug, and the team working on the original
      <filename>mooIRC</filename> branch would like to apply that
      change as well.</para>

    <para>The <command>svn merge</command> command is the answer.  You
      can think of <command>svn merge</command> as a special kind of
      <command>svn diff</command>; only instead of displaying unified
      diffs to the screen, it <emphasis>applies</emphasis> the
      differences to your working copy as if they were local
      changes.</para>

    <para>For example, suppose the bug fix happened in a commit to the
      <filename>mooIRC-beta</filename> branch in revision 102.</para>
    
    <screen>
      $ svn diff -r 101:102 http://foo.com/repos/mooIRC-beta
      
     &hellip;   # diffs sent to screen
      
      $ svn merge -r 101:102 http://foo.com/repos/mooIRC-beta mooIRC
      U   mooIRC/glorb.c
      U   mooIRC/src/floo.h
    </screen>

    <para>While the output of <command>svn merge</command> looks
      similar to <command>svn update</command> or <command>svn
      switch</command>, it is in fact only applying temporary changes
      to the working files.  Once the differences are applied as local
      changes, you can examine them as usual with <command>svn
      diff</command>, <command>svn status</command>, or undo them with
      <command>svn revert</command> as usual.  If the changes are
      acceptable, you can commit them.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-4">
    <title>Rolling back a change with svn merge</title>

    <para>Another common use for <command>svn merge</command> is for
      rolling back a change that has been committed.  Say you commit
      some changes in revision 10, and later decide that they were a
      mistake.  You can easily revert the tree to the state it was in
      at revision 9 with an <command>svn merge</command>
      command.</para>

    <screen>
      $ svn commit -m "change some stuff"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 10.
      $
      
      &hellip; # developer continues on and realizes he made a mistake
      
      $ svn merge -r 10:9 .
      U ./bar.c
      U ./foo.c
      $ svn commit -m "oops, reverting revision 10"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 11.
    </screen>
    
    <para>If you aren't rolling back the changes to your current
      directory (say you want to roll back one specific file, or all
      the files in one specific subdirectory), then the syntax is
      slightly different, as you have to tell <command>svn
      merge</command> where it should merge the changes into.</para>

    <screen>
      $ svn merge -r 10:9 baz/ baz/
      U ./baz/bar.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 10's changes in baz/"
      Sending        baz/bar.c
      Sending        baz/foo.c
      Transmitting file data ..
      Committed revision 12.
      $
      
      &hellip; # developer continues on and later makes another mistake
      
      $ svn merge -r 13:12 baz/foo.c baz/foo.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 12's change to foo.c"
      Sending        baz/foo.c
      Transmitting file data .
      Committed revision 15.
    </screen>
    
    <para>Keep in mind that rolling back a change like this is just
      like any other <command>svn merge</command> operation, so you
      should use <command>svn status</command> and <command>svn
      diff</command> to confirm that your work is in the state you
      want it to be in, and then use <command>svn commit</command> to
      send the final version to the repository.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-5">
    <title>Removing a Branch or Tag with svn rm</title>

    <para>The <command>svn rm</command> command can operate on URLs.
      A file or directory can be <quote>remotely</quote> deleted from
      the repository, with no working copy present:</para>

    <screen>
      $ svn rm http://foo.com/repos/tags/mooIRC-bad-tag -m "deleting bad tag"
      Committed revision 1023.
    </screen>

    <para>Of course, this is still a form of immediate commit, so some kind of
      log message is still required.</para>

    <para>Enough said!</para>

  </sect1>

</chapter>

<!--
local variables: 
eval: (load-file "../tools/svnbook.el")
sgml-parent-document: ("book.xml" "chapter")
end:
-->


