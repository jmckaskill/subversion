<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-4">
<title>Branching and Merging</title>

  <simplesect>

    <para>Branches and tags are general concepts common to almost all
      revision control systems.  If you're not familiar with these
      ideas, you can find a good introductory explanation in Karl
      Fogel's free CVS book: <systemitem
      class="url">http://cvsbook.red-bean.com/cvsbook.html#Branching_Basics</systemitem></para><!--
      ###TODO we should write this part, not point to Karl's book. :)
      -Fitz -->

    <para>At this point, you should understand how each commit creates
      an entire new filesystem tree in the repository.  (If not, read
      revisions, <xref linkend="svn-ch-2"/><!-- ###TODO Make this xref
      (Transactions and Revision Numbers) more specific -Fitz -->,
      <xref linkend="svn-ch-2"/><!-- ###TODO Make this xref (Revision
      numbers are different now) more specific -Fitz -->.)</para>

    <para>As you may have suspected, the filesystem doesn't grow 652
      new inodes each time a new revision is created.  Instead, each
      new tree is <emphasis>mostly</emphasis> made of pointers to
      already-existing nodes; new nodes are created only for changed
      items, and all the rest of the revision tree is <quote>shared
      storage</quote> with other revision trees.  This technique
      demonstrates how the filesystem is able to make <quote>cheap
      copies</quote> of things.  These cheap copies are nothing more
      than directory entries that point to existing nodes.  And this
      is the basis of tags and branches.</para>

  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-1">
    <title>Branching with svn cp</title> 
    
    <para>Suppose we have a repository whose head tree is revision 82.
      In this repository is a subdirectory <filename>mooIRC</filename>
      that contains a software project that is ready to be tagged.
      How do we tag it?  Very simple: make a <quote>cheap</quote> copy
      of this directory.  In other words, create a new directory entry
      (somewhere else in the filesystem) that points to this
      <emphasis>specific</emphasis> node that represents directory
      <filename>mooIRC</filename> in revision 82.  Of course, you can
      name the new directory entry whatever you want -- probably a
      tag-name like <filename>mooIRC-beta</filename>.</para>
    
    <para>The easiest way to make this copy is with <command>svn
      cp</command>, which, incidentally, can operate entirely on URLs,
      so that the copy happens only on the server-side:</para>

    <screen>
      $ svn cp http://foo.com/repos/mooIRC http://foo.com/repos/mooIRC-beta
      Committed revision 83.
    </screen>

    <para>Now, as long as you never touch the contents of the
      directory <filename>mooIRC-beta</filename>, that entry will
      forever point to a node that looks the way
      <filename>mooIRC</filename> did at a specific moment in time
      (however it looked in revision 82).  And that's exactly what a
      <firstterm>tag</firstterm> is.</para>

    <para>But suppose <filename>mooIRC-beta</filename> isn't sacred,
      and instead you decide to start making commits to it.  And
      suppose you <emphasis>also</emphasis> continue to make commits
      in the original <filename>mooIRC</filename> directory.  Then you
      have two directories that started out looking identical -- their
      common ancestor was <filename>mooIRC</filename> in revision 82
      -- but now have diverged their contents over time.  In other
      words, they represent different <firstterm>branches</firstterm>
      of the project.</para>

    <para>It's very important to note that the Subversion filesystem
      is <emphasis>not</emphasis> aware of <quote>tags</quote> or
      <quote>branches.</quote> It's only aware of directories, and all
      directories are equal.  The tag and branch concepts are purely
      <emphasis>human</emphasis> meanings attached to particular
      directories.</para>

    <para>For this reason, it's up to users (and the Subversion
      repository administrator) to choose sane policies that help
      elucidate these labels.  For example, here's a good way to lay
      out your repository:</para>

    <screen>
      /
      /projectA
      /projectA/trunk/
      /projectA/branches/
      /projectA/tags/
      /projectB
      /projectB/trunk/
      /projectB/branches/
      /projectB/tags/
    </screen>

    <para>Each time <filename>/projectA/trunk</filename> reaches a
      taggable state, make a copy of the directory somewhere in
      <filename>/projectA/tags/</filename>, and set the copy to
      read-only.  Use the same procedure to create a branch in
      <filename>/projectA/branches/</filename>.</para>

    <para>An alternate way to lay out a repository:</para>

    <screen>
      /
      /trunk
      /trunk/projectA
      /trunk/projectB
      /branches
      /branches/projectA
      /branches/projectB
      /tags
      /tags/projectA
      /tags/projectB
    </screen>

    <para>Or, of course, you could just place each project into a
      dedicated repository.  It's up to you.  For examples on how to
      create a repository with one of these structures, <xref
      linkend="svn-ch-5"/><!-- ###TODO Make this xref (Creating a
      repository) more specific -Fitz -->.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-2">
    <title>Switching to a Branch with svn switch</title>

    <para>The <command>svn switch</command> command allows you to
      <quote>move</quote> some or all of your working copy to a branch
      or tag.  For example, suppose I have a working copy of
      <filename>mooIRC</filename>, and I'd like to work on some
      subsystem as it appears in a subdirectory of
      <filename>mooIRC-beta</filename>.  At the same time, I want the
      rest my working copy to remain on the original
      <filename>mooIRC</filename> branch.  To do this, I switch the
      appropriate subdir to the new branch location:</para>

    <screen>
      $ svn switch http://foo.com/repos/mooIRC-beta/subsystems/renderer \
                   mooIRC/subsystems/renderer
      
      U  mooIRC/subsystems/renderer/foo.c
      U  mooIRC/subsystems/renderer/bar.h
      U  mooIRC/subsystems/renderer/baz.c
    </screen>

    <para>Now my working copy of the <filename>renderer</filename>
      subdirectory represents a different location on the
      server.</para>

    <para>Really, <command>svn switch</command> is just a fancier
      version of <command>svn update</command>.  Whereas <command>svn
      update</command> has the ability to move your working copy
      through time (either by updating to the latest revision, or by
      updating to a specific revision given with
      <option>-r</option>), <command>svn switch</command> is
      able to move your working copy through time
      <emphasis>and</emphasis> space.</para>

    <para>If your working copy contains a number of
      <quote>switched</quote> subtrees from different repository
      locations, it continues to function as normal.  When you update,
      you'll receive patches to each subtree as appropriate.  When you
      commit, your local changes will still be applied as a single,
      atomic change to the repository.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-3">
    <title>Moving changes with svn merge</title>

    <para>Suppose a team of programmers working on the
      <filename>mooIRC-beta</filename> branch have fixed a critical
      bug, and the team working on the original
      <filename>mooIRC</filename> branch would like to apply that
      change as well.</para>

    <para>The <command>svn merge</command> command is the answer.  You
      can think of <command>svn merge</command> as a special kind of
      <command>svn diff</command>; only instead of displaying unified
      diffs to the screen, it <emphasis>applies</emphasis> the
      differences to your working copy as if they were local
      changes.</para>

    <para>For example, suppose the bug fix happened in a commit to the
      <filename>mooIRC-beta</filename> branch in revision 102.</para>
    
    <screen>
      $ svn diff -r 101:102 http://foo.com/repos/mooIRC-beta
      
     &hellip;   # diffs sent to screen
      
      $ svn merge -r 101:102 http://foo.com/repos/mooIRC-beta mooIRC
      U   mooIRC/glorb.c
      U   mooIRC/src/floo.h
    </screen>

    <para>While the output of <command>svn merge</command> looks
      similar to <command>svn update</command> or <command>svn
      switch</command>, it is in fact only applying temporary changes
      to the working files.  Once the differences are applied as local
      changes, you can examine them as usual with <command>svn
      diff</command>, <command>svn status</command>, or undo them with
      <command>svn revert</command> as usual.  If the changes are
      acceptable, you can commit them.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-4">
    <title>Rolling back a change with svn merge</title>

    <para>Another common use for <command>svn merge</command> is for
      rolling back a change that has been committed.  Say you commit
      some changes in revision 10, and later decide that they were a
      mistake.  You can easily revert the tree to the state it was in
      at revision 9 with an <command>svn merge</command>
      command.</para>

    <screen>
      $ svn commit -m "change some stuff"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 10.
      $
      
      &hellip; # developer continues on and realizes he made a mistake
      
      $ svn merge -r 10:9 .
      U ./bar.c
      U ./foo.c
      $ svn commit -m "oops, reverting revision 10"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 11.
    </screen>
    
    <para>If you aren't rolling back the changes to your current
      directory (say you want to roll back one specific file, or all
      the files in one specific subdirectory), then the syntax is
      slightly different, as you have to tell <command>svn
      merge</command> where it should merge the changes into.</para>

    <screen>
      $ svn merge -r 10:9 baz/ baz/
      U ./baz/bar.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 10's changes in baz/"
      Sending        baz/bar.c
      Sending        baz/foo.c
      Transmitting file data ..
      Committed revision 12.
      $
      
      &hellip; # developer continues on and later makes another mistake
      
      $ svn merge -r 13:12 baz/foo.c baz/foo.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 12's change to foo.c"
      Sending        baz/foo.c
      Transmitting file data .
      Committed revision 15.
    </screen>
    
    <para>Keep in mind that rolling back a change like this is just
      like any other <command>svn merge</command> operation, so you
      should use <command>svn status</command> and <command>svn
      diff</command> to confirm that your work is in the state you
      want it to be in, and then use <command>svn commit</command> to
      send the final version to the repository.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-5">
    <title>Vendor branches</title>

    <para>Sometimes you want to manage modified third-party source
      code inside your Subversion repository, while still tracking
      upstream releases.  In CVS this would have been called a
      <quote>vendor branch</quote>.  Subversion doesn't have a formal
      <quote>vendor branch</quote>, but it is sufficiently flexible
      that you can still do much the same thing.</para>
    
    <para>The general procedure goes like this.  You create a top
      level directory (we'll use <filename>/vendor</filename>) to hold
      the vendor branches.  Then you import the third party code into
      a subdirectory of <filename>/vendor</filename>, and copy it into
      <filename>/trunk</filename> where you make your local changes.
      With each new release of the code you are tracking you bring it
      into the vendor branch and merge the changes into
      <filename>/trunk</filename>, resolving whatever conflicts occur
      between your local changes and the upstream changes.</para>

    <para>Let's try and make this a bit clearer with an
      example.</para>

    <para>First, the initial import.</para>
    
    <screen>
      $ svn mkdir http://svnhost/repos/vendor/foobar
      $ svn import http://svnhost/repos/vendor/foobar ~/foobar-1.0 current
    </screen>
    
    <para>Now we've got the current version of the foobar project in
      <filename>/vendor/foobar/current</filename>.  We make another
      copy of it so we can always refer to that version, and then copy
      it into the trunk so you can work on it.</para>
    
    <screen>
      $ svn copy http://svnhost/repos/vendor/foobar/current    \
                 http://svnhost/repos/vendor/foobar/foobar-1.0 \
                 -m `tagging foobar-1.0'
      $ svn copy http://svnhost/repos/vendor/foobar/foobar-1.0 \
                 http://svnhost/repos/trunk/foobar             \
                 -m `bringing foobar-1.0 into trunk'
    </screen>

    <para>Now you just check out a copy of
    <filename>/trunk/foobar</filename> and get to work!</para>

    <para>Later on, the developers at FooBar Widgets, Inc release a
      new version of their code, so you want to update the version of
      the code you're using.  First, you check out the
      <filename>/vendor/foobar/current</filename> directory, then copy
      the new release over that working copy, handle any renames,
      additions or removals manually, and then commit.</para>

    <screen>
      $ svn checkout http://svnhost/repos/vendor/foobar/current ~/current
      $ cd ~/foobar-1.1
      $ tar -cf - . | (cd ~/current ; tar -xf -)
      $ cd ~/current
      $ mv foobar.c main.c
      $ svn move main.c foobar.c
      $ svn delete dead.c
      $ svn add doc
      $ svn add doc/*
      $ svn commit -m `importing foobar 1.1 on vendor branch'
    </screen>

    <para>Whoa, that was complicated. Don't worry, most cases are far
      simpler. </para>

    <para>What happened? foobar 1.0 had a file called
      <filename>main.c</filename>.  This file was renamed to
      <filename>foobar.c</filename> in 1.1.  So your working-copy had
      the old <filename>main.c</filename> which Subversion knew about, 
      and the new <filename>foobar.c</filename> which Subversion did 
      not know about.  You rename <filename>foobar.c</filename> to 
      <filename>main.c</filename> and <command>svn mv</command> it 
      back to the new name.  This way, Subversion will know that 
      <filename>foobar.c</filename> is a descendant of 
      <filename>main.c</filename>.  <filename>dead.c</filename> has 
      been removed in 1.1, and they have finally written some 
      documentation, so you add that.</para>

    <para>Next you copy <filename>/vendor/foobar/current</filename> to
      <filename>/vendor/foobar/foobar-1.1</filename> so you can always
      refer back to version 1.1, like this.</para>

    <screen>
      $ svn copy http://svnhost/repos/vendor/foobar/current    \
                 http://svnhost/repos/vendor/foobar/foobar-1.1 \
                 -m `tagging foobar-1.1'
    </screen>

    <para>Now that you have a pristine copy of foobar 1.1 in
      <filename>/vendor</filename>, you just have to merge their
      changes into <filename>/trunk</filename> and you're done.  That
      looks like this.</para>

    <screen>
      $ svn checkout http://svnhost/repos/trunk/foobar ~/foobar
      $ cd ~/foobar
      $ svn merge http://svnhost/repos/vendor/foobar/foobar-1.0 \
                  http://svnhost/repos/vendor/foobar/foobar-1.1
      $
      &hellip; # resolve all the conflicts between their changes and your changes
      $ svn commit -m `merging foobar 1.1 into trunk'
    </screen>
    
    <para>There, you're done.  You now have a copy of foobar 1.1 with
      all your local changes merged into it in your tree.</para>

    <para>Vendor branches that have more than several deletes,
      additions and moves can use the
      <command>svn_load_dirs.pl</command> script that comes with the
      Subversion distribution.  This script automates the above
      importing steps to make sure that mistakes are minimized.  You
      still need to use the merge commands to merge the new versions
      of foobar into your own local copy containing your local
      modifications.</para>

    <para>This script has the following enhancements over <command>svn
    import</command>:</para>

    <itemizedlist>
      <listitem>
        <para>Can be run at any point in time to bring an existing
          directory in the repository to exactly match an external
          directory.  This script runs all the <command>svn
          add</command>, <command>svn rm</command> and optionally any
          <command>svn mv</command> commands as necessary.</para>
      </listitem>

      <listitem>
        <para>Optionally tag the newly imported directory.</para>
      </listitem>

      <listitem>
        <para>Optionally add arbitrary properties to files and
          directories that match a regular expression.</para>
      </listitem>

    </itemizedlist>

    <para>This script takes care of complications where Subversion
      requires a commit before renaming a file or directory twice,
      such as if you had a vendor branch that renamed
      <filename>foobar-1.1/docs/doc.ps</filename> to
      <filename>foobar-1.2/documents/doc-1.2.ps</filename>.  Here, you
      would rename <filename>docs</filename> to
      <filename>documents</filename>, perform a commit, then rename
      <filename>doc.ps</filename> to <filename>doc-1.2.ps</filename>.
      You could not do the two renames without the commit, because
      <filename>doc.ps</filename> was already moved once from
      <filename>docs/doc.ps</filename> to
      <filename>documents/doc.ps</filename>.</para>

    <para>This script always compares the directory being imported to
      what currently exists in the Subversion repository and takes the
      necessary steps to add, delete and rename files and directories
      to make the subversion repository match the imported directory.
      As such, it can be used on an empty subversion directory for the
      first import or for any following imports to upgrade a vendor
      branch.</para>

    <para>For the fqirst foobar-1.0 release located in
      <filename>~/foobar-1.0</filename>:</para>

    <screen>
      $ svn_load_dirs.pl -t foobar-1.0                      \
                         http://svnhost/repos/vendor/foobar \
                         current                            \
                         ~/foobar-1.0
    </screen>

    <para><command>svn_load_dirs.pl</command> takes three mandatory
      arguments.  The first argument, <systemitem
      class="url">http://svnhost/repos/vendor/foobar</systemitem>, is
      the URL to the base Subversion directory to work in.  In this
      case, we're working in the <filename>vendor/foobar</filename>
      part of the Subversion repository.  The next argument,
      <filename>current</filename>, is relative to the first and is
      the directory where the current import will take place, in this
      case <systemitem
      class="url">http://svnhost/repos/vendor/foobar/current</systemitem>.
      The last argument, <filename>~/foobar-1.0</filename>, is the
      directory to import.  Finally, the optional
      <option>-t</option> command line option is also relative
      to <systemitem
      class="url">http://svnhost/repos/vendor/foobar</systemitem> and
      tells <command>svn_load_dirs.pl</command> to create a tag of the
      imported directory in <systemitem
      class="url">http://svnhost/repos/vendor/foobar/foobar-1.0</systemitem>.</para>

    <para>The import of foobar-1.1 would be taken care of in the same
      way:</para>

    <screen>
      $ svn_load_dirs.pl -t foobar-1.1                      \
                         http://svnhost/repos/vendor/foobar \
                         current                            \
                         ~/foobar-1.1
    </screen>

    <para>The script looks in your current <systemitem
      class="url">http://svnhost/repos/vendor/foobar/current</systemitem>
      directory and sees what changes need to take place for it to
      match <filename>~/foobar-1.1</filename>.  The script is kind
      enough to notice that there are files and directories that exist
      in 1.0 and not in 1.1 and asks if you want to perform any
      renames.  At this point, you can indicate that
      <filename>main.c</filename> was renamed to
      <filename>foobar.c</filename> and then indicate that no further
      renames have taken place.</para>

    <para>The script will then delete <filename>dead.c</filename> and
      add <filename>doc</filename> and <filename>doc/*</filename> to
      the Subversion repository and finally create a tag foobar-1.1 in
      <systemitem
      class="url">http://svnhost/repos/vendor/foobar/foobar-1.1</systemitem>.</para>

    <para>The script also accepts a separate configuration file for
      applying properties to specific files and directories matching a
      regular expression that are @emph{added} to the repository.
      This script will not modify properties of already existing files
      or directories in the repository.  This configuration file is
      specified to <command>svn_load_dirs.pl</command> using the
      <option>-p</option> command line option.  The format of
      the file is either two or four columns.</para>

    <para><literal>regular_expression control property_name
        property_value</literal></para>

    <para>The <literal>regular_expression</literal> is a Perl style
      regular expression.  The <literal>control</literal> column must
      either be set to <literal>break</literal> or
      <command>cont</command>.  It is used to tell
      <command>svn_load_dirs.pl</command> if the following lines in
      the configuration file should be examined for a match or if all
      matching should stop.  If <literal>control</literal> is set to
      <command>break</command>, then no more lines from the
      configuration file will be matched.  If
      <literal>control</literal> is set to <command>cont</command>,
      which is short for continue, then more comparisons will be made.
      Multiple properties can be set for one file or directory this
      way.  The last two columns, <literal>property_name</literal> and
      <literal>property_value</literal> are optional and are applied
      to matching files and directories.</para>

    <para>If you have whitespace in any of the
      <literal>regular_expression</literal>,
      <literal>property_name</literal> or
      <literal>property_value</literal> columns, you must surround the
      value with either a single or double quote.  You can protect
      single or double quotes with a \ character.  The \ character is
      removed by this script @emph{only} for whitespace or quote
      characters, so you do not need to protect any other characters,
      beyond what you would normally protect for the regular
      expression.</para>

    <para>This sample configuration file was used to load on a Unix
      box a number of Zip files containing Windows files with
      <literal>CRLF</literal> end of lines.</para>

    <screen>
      \.doc$              break   svn:mime-type   application/msword
      \.ds(p|w)$          break   svn:eol-style   CRLF
      \.ilk$              break   svn:eol-style   CRLF
      \.ncb$              break   svn:eol-style   CRLF
      \.opt$              break   svn:eol-style   CRLF
      \.exe$              break   svn:mime-type   application/octet-stream
      dos2unix-eol\.sh$   break
      .*                  break   svn:eol-style   native
    </screen>

    <para>In this example, all the files should be converted to the
      native end of line style, which the last line of the
      configuration handles.  The exception is
      <command>dos2unix-eol.sh</command>, which contains embedded
      <literal>CR</literal>'s used to find and replace Windows
      <literal>CRLF</literal> end of line characters with Unix's
      <literal>LF</literal> characters.  Since <command>svn</command>
      and <command>svn_load_dirs.pl</command> convert all
      <literal>CR</literal>, <literal>CRLF</literal> and
      <literal>LF</literal>'s to the native end of line style when
      <literal>svn:eol-style</literal> is set to
      <literal>native</literal>, this file should be left untouched.
      Hence, the <command>break</command> with no property
      settings.</para>

    <para>The Windows Visual C++ and Visual Studio files
      (<filename>*.dsp</filename>, <filename>*.dsw</filename>, etc.)
      should retain their <literal>CRLF</literal> line endings on any
      operating system and any <filename>*.doc</filename> files are
      always treated as binary files, hence the
      <literal>svn:mime-type</literal> setting of
      <literal>application/msword</literal>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-6">
    <title>Removing a Branch or Tag with svn rm</title>

    <para>The <command>svn rm</command> command can operate on URLs.
      A file or directory can be <quote>remotely</quote> deleted from
      the repository, with no working copy present:</para>

    <screen>
      $ svn rm http://foo.com/repos/tags/mooIRC-bad-tag -m "deleting bad tag"
      Committed revision 1023.
    </screen>

    <para>Of course, this is still a form of immediate commit, so some kind of
      log message is still required.</para>

    <para>Enough said!</para>

  </sect1>

</chapter>

<!--
local variables: 
eval: (load-file "../tools/svnbook.el")
sgml-parent-document: ("book.xml" "chapter")
end:
-->


