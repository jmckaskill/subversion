<chapter id="svn-ch-6">
  <title>Server Configuration</title>
  
  <simplesect>
    
    <para>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides.  But the typical Subversion setup involves a single
      server machine being accessed from clients on computers all over
      the office&mdash;or, perhaps, all over the world.</para>
    
    <para>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</para>
    
  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-1">
    
    <title>Overview</title>
    
    <para>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client "repository access"
      API allows programmers to write plugins that speak relevant
      network protocols.  In theory, Subversion can sport an infinite
      number of network implementations.  In practice, there are only
      two servers at the time of writing.</para>
    
    <para>Apache is an extremely popular webserver; using the
      <command>mod_dav_svn</command> module, Apache can access a
      repository and make it available to clients via WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <command>svnserve</command>: a small, standalone server
      program that speaks a custom protocol with clients.</para>

    <para>Note that Subversion, as an open-source project, does not
      officially endorse any server as "primary" or "official".
      Neither network implementation is treated as a second-class
      citizen; each server has distinct advantages and disadvantages.
      In fact, it's possible for different servers to run in parallel,
      each accessing your repositories in its own way, and each
      without hindering the other (see <xref
      linkend="svn-ch-6-sect-5"/>).  Here's a brief overview and
      comparsion of of the two available Subversion servers&mdash; as
      an administrator, it's up to you to choose whatever works best
      for you and your users.</para>
      

    <table id="svn-ch-06-table-1">
      <title>Network Server Comparison</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Feature</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentication options</entry>
            
            <entry>HTTP basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</entry>
            
            <entry>CRAM-MD5 or SSH</entry>
          </row>
          
          <row>
            <entry>User account options</entry>
            
            <entry>private 'users' file</entry>
            
            <entry>private 'users' file, or existing system (SSH)
              accounts</entry>
          </row>
          
          <row>
            <entry>Authorization options</entry>
            
            <entry>blanket read/write access, or per-directory access
              control</entry>
            
            <entry>blanket read/write access</entry>
          </row>
          
          <row>
            <entry>Encryption</entry>
            
            <entry>via optional SSL</entry>

            <entry>via SSH only</entry>
          </row>

          <row>
            <entry>Interoperability</entry>
            
            <entry>partially usable by other WebDAV clients</entry>

            <entry>not interoperable</entry>
          </row>

          <row>
            <entry>Web Viewing</entry>
            
            <entry>limited built-in support, or via 3rd-party tools
              such as ViewCVS</entry>

            <entry>via 3rd-party tools such as ViewCVS</entry>
          </row>

          <row>
            <entry>Speed</entry>
            
            <entry>somewhat slower</entry>

            <entry>somewhat faster</entry>
          </row>

          <row>
            <entry>Initial setup</entry>
            
            <entry>somewhat complex</entry>

            <entry>fairly simple</entry>
          </row>

        </tbody>
      </tgroup>      
    </table>
    
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-2">

    <title>Network Model</title>

    <para>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</para>

    <sect2 id="svn-ch-6-sect-2.1">
      <title>Requests and Responses</title>

      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <xref
        linkend="svn-ch-02-sidebar-1"/>).  Users can run <command>svn
        --version</command> to see which URL schemas and protocols the
        client knows how to use.</para>

      <para>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials ("logs in")
        to the server before ever making a request.  In Subversion,
        the server "pulls" credentials by challenging the client at
        the appropriate moment, rather than the client "pushing" them.
        This makes certain operations more elegant.  For example, if a
        server is configured to allow anyone in the world to read a
        repository, then the server will never issue an authentication
        challenge when a client attempts to <command>svn
        checkout</command>.</para>

      <para>If the client's network request writes new data to the
        repository (e.g. <command>svn commit</command>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <literal>svn:author</literal> property on the
        new revision (see <xref linkend="svn-ch-5-sect-1.2"/>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <literal>svn:author</literal> property is empty.
        <footnote><para>This problem is actually a FAQ, resulting from
        a misconfigured server setup.</para></footnote></para>

    </sect2>

    <sect2 id="svn-ch-6-sect-2.2">
      <title>Client Credentials Caching</title>

      <para>Many servers are configured to require authenication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</para>

      <para>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the commandline client
        successfully authenticates itself to a server, it saves the
        credentials in the user's private runtime configuration
        area&mdash; in <literal>~/.subversion/auth/</literal> on
        Unix-like systems or
        <literal>%APPDATA%/Subversion/auth/</literal> on Windows.
        (The runtime area is covered in more detail in <xref
        linkend="svn-ch-7-sect-1"/>.)</para>

      <para>When the client receives an authentication challenge, it
        first looks for the appropriae credentials in the disk cache;
        if not present, or if the cached credenials fail to
        authenticate, then the client simply prompts the user for the
        information.</para>

      <para>The security-paranoid people may be thinking to
        themselves, "caching passwords on disk?  That's terrible!  You
        should never do that!"  But please remain calm.  First, the
        <literal>auth/</literal> caching area is permission-protected
        so that only the user (owner) can read data from it, not the
        world at large.  If that's still not safe enough for you, you
        can disable credential caching.  To disable caching for a
        single command, pass the <literal>--no-auth-cache</literal>
        option:</para>

<screen>
$ svn commit -F log_msg.txt --no-auth-cache
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn rm newfile
$ svn commit -F new_msg.txt
Username:  joe
[...]
</screen>

      <para>Or, if you want to disable credential caching permanently,
        you can edit your runtime <literal>config</literal> file
        (located next to the <literal>auth/</literal> directory).
        Simply set </para>

<screen>
[auth]
store-auth-creds = no
</screen>

      <para>... and no credentials will be cached on disk, ever.</para>

      <para>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <literal>auth/</literal> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <literal>svn:realmstring</literal> key describes
        the particular server realm that the file is associated
        with:</para>

<screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>

      <para>Once you have located the proper cache file, just delete
      it.</para>

      <para>One last word about client authenication behavior: a bit
        of explanation about the <literal>--username</literal> and
        <literal>--password</literal> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these opions <emphasis>does not</emphasis>
        automatically send credentials to the server.  As discussed
        earlier, the server "pulls" credentials from the client when
        it deems necessary; the client cannot "push" them at will.  If
        a username and/or password are passed as options, they will
        <emphasis>only</emphasis> be presented to the server if the
        server requests them.  

          <footnote><para>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <literal>--username</literal> and
           <literal>--password</literal> options to the client,
           they're surprised to see that they're never used, i.e. new
           revisions still appear to have been committed
           anonymously!</para></footnote>
        
        Typically, these options are used when:
      </para>

      <itemizedlist>
        <listitem><para>the user wants to authenticate as a
            different user than her system login name, or</para>
        </listitem>
        <listitem><para>a script wants to authenticate without
            using cached credentials.</para>
        </listitem>
      </itemizedlist>
          

      <para>Here is a final summary that describes how a Subversion
        client behaves when it receives an authenication
        challenge:</para>

      <orderedlist>
        <listitem>
          <para>Check wheher the user specified any credentials as
            commandline options, via <literal>--username</literal>
            and/or <literal>--password</literal>.  If not, or if these
            options fail to authenticate successfully, then</para>
        </listitem>

        <listitem>
          <para>Look up the server's realm in the runtime
            <literal>auth/</literal> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</para>
        </listitem>

        <listitem>
          <para>Resort to prompting the user.</para>
        </listitem>
      </orderedlist>

      <para>If the client successfully authenicates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier.)</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-3">
    
    <title>svnserve, a custom server</title>

    <para>blah</para>

    <sect2 id="svn-ch-6-sect-3.1">
      <title>Modes of Operation</title>

      <para>start at cmdline; daemon (-d) mode; starting via inetd
      (sample inetd entry); setting a root (-r); tunnel mode
      (-t)</para>

    </sect2>

    <sect2 id="svn-ch-6-sect-3.2">
      <title>Built-in authentication and authorization</title>

      <para>creating the users file;  document the svnserve.conf file.</para>

      <para>Explanation of CRAM-MD5 authentication:  server sends a
      bit of data to the client, client uses its password to encrypt
      the data with the MD5 hash algorithm and sends it back;  server
      performs same computation with stored password, and verifies
      that the result is identical.  Footnote:  see RFC 2195.</para>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-3.3">
      <title>SSH authentication and authorization</title>

      <para>uses pre-existing SSH system accounts;  authz is determined
        soley by system permissions on the berkeleydb files;  show
        example of using unix groups</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-4">
    
    <title>httpd, the Apache HTTP server</title>

    <para>in this intro, explain why apache2, not apache1.  also
      explain why it's not a big deal to require apache2.</para>

    <sect2 id="svn-ch-6-sect-4.1">
      <title>SVNPath and SVNParentPath directives</title>

      <para>show simplest possible Location block with these
      directives.</para>

    </sect2>

    <sect2 id="svn-ch-6-sect-4.2">
      <title>Authentication Options</title>

      <para>anonymous auth;  basic auth via AuthUserFile;  certificate
        setup:  ptrs to apache docs on setting up httpd.conf for this,
        and document how to manage client/server certs from client.</para>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-4.3">
      <title>Authorization Options</title>

      <para>blanket access control via 'Require' directive;  per-path
        access control via mod_authz_svn (document the syntax!)</para>

    </sect2>


  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-5">
    
    <title>Using Multiple Servers</title>

    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for
      your repository to be accessed by multiple repository access
      methods simultaneously?  The answer is yes, provided you use a
      bit of foresight.</para>
    
    <para>At any given time, these processes may require read and/or
      write access to your repository:</para>
    
    <itemizedlist>
      <listitem>
        <para>regular system users using a Subversion client (as
          themselves) to access the repository directly;</para>
      </listitem>
      <listitem>
        <para>regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves) which access the repository;</para>
      </listitem>
      <listitem>
        <para>an <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user;</para>
      </listitem>
      <listitem>
        <para>an Apache <command>httpd</command> process, running as a
          particular fixed user.</para>
      </listitem>
    </itemizedlist>
    
    <para>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <literal>svn</literal> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&mdash;one that prevents access by
      other users.</para>
    
    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first sets <command>umask 002</command> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <command>umask
      002</command> command to Apache's own startup script,
      <filename>apachectl</filename>.</para>

    <!-- TODO: example of such a wrapper script? -->
    
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>
    
    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</para>

  </sect1>




</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
