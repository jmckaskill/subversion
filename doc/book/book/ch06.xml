<chapter id="svn-ch-6">
  <title>Server Configuration</title>
  
  <simplesect>
    
    <para>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides.  But the typical Subversion setup involves a single
      server machine being accessed from clients on computers all over
      the office&mdash;or, perhaps, all over the world.</para>
    
    <para>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</para>
    
  </simplesect>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-1">
    
    <title>Overview</title>
    
    <para>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client "repository access"
      API allows programmers to write plugins that speak relevant
      network protocols.  In theory, Subversion can sport an infinite
      number of network implementations.  In practice, there are only
      two servers at the time of writing.</para>
    
    <para>Apache is an extremely popular webserver; using the
      <command>mod_dav_svn</command> module, Apache can access a
      repository and make it available to clients via WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <command>svnserve</command>: a small, standalone server
      program that speaks a custom protocol with clients.</para>

    <para>Note that Subversion, as an open-source project, does not
      officially endorse any server as "primary" or "official".
      Neither network implementation is treated as a second-class
      citizen; each server has distinct advantages and disadvantages.
      In fact, it's possible for different servers to run in parallel,
      each accessing your repositories in its own way, and each
      without hindering the other (see <xref
      linkend="svn-ch-6-sect-5"/>).  Here's a brief overview and
      comparsion of of the two available Subversion servers&mdash; as
      an administrator, it's up to you to choose whatever works best
      for you and your users.</para>
      

    <table id="svn-ch-06-table-1">
      <title>Network Server Comparison</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Feature</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentication options</entry>
            
            <entry>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</entry>
            
            <entry>CRAM-MD5 or SSH</entry>
          </row>
          
          <row>
            <entry>User account options</entry>
            
            <entry>private 'users' file</entry>
            
            <entry>private 'users' file, or existing system (SSH)
              accounts</entry>
          </row>
          
          <row>
            <entry>Authorization options</entry>
            
            <entry>blanket read/write access, or per-directory access
              control</entry>
            
            <entry>blanket read/write access</entry>
          </row>
          
          <row>
            <entry>Encryption</entry>
            
            <entry>via optional SSL</entry>

            <entry>via SSH only</entry>
          </row>

          <row>
            <entry>Interoperability</entry>
            
            <entry>partially usable by other WebDAV clients</entry>

            <entry>not interoperable</entry>
          </row>

          <row>
            <entry>Web Viewing</entry>
            
            <entry>limited built-in support, or via 3rd-party tools
              such as ViewCVS</entry>

            <entry>via 3rd-party tools such as ViewCVS</entry>
          </row>

          <row>
            <entry>Speed</entry>
            
            <entry>somewhat slower</entry>

            <entry>somewhat faster</entry>
          </row>

          <row>
            <entry>Initial setup</entry>
            
            <entry>somewhat complex</entry>

            <entry>fairly simple</entry>
          </row>

        </tbody>
      </tgroup>      
    </table>
    
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-2">

    <title>Network Model</title>

    <para>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</para>

    <sect2 id="svn-ch-6-sect-2.1">
      <title>Requests and Responses</title>

      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <xref
        linkend="svn-ch-02-sidebar-1"/>).  Users can run <command>svn
        --version</command> to see which URL schemas and protocols the
        client knows how to use.</para>

      <para>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials ("logs in")
        to the server before ever making a request.  In Subversion,
        the server "pulls" credentials by challenging the client at
        the appropriate moment, rather than the client "pushing" them.
        This makes certain operations more elegant.  For example, if a
        server is configured to allow anyone in the world to read a
        repository, then the server will never issue an authentication
        challenge when a client attempts to <command>svn
        checkout</command>.</para>

      <para>If the client's network request writes new data to the
        repository (e.g. <command>svn commit</command>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <literal>svn:author</literal> property on the
        new revision (see <xref linkend="svn-ch-5-sect-1.2"/>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <literal>svn:author</literal> property is empty.
        <footnote><para>This problem is actually a FAQ, resulting from
        a misconfigured server setup.</para></footnote></para>

    </sect2>

    <sect2 id="svn-ch-6-sect-2.2">
      <title>Client Credentials Caching</title>

      <para>Many servers are configured to require authenication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</para>

      <para>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the commandline client
        successfully authenticates itself to a server, it saves the
        credentials in the user's private runtime configuration
        area&mdash; in <literal>~/.subversion/auth/</literal> on
        Unix-like systems or
        <literal>%APPDATA%/Subversion/auth/</literal> on Windows.
        (The runtime area is covered in more detail in <xref
        linkend="svn-ch-7-sect-1"/>.)  Successful credentials are
        cached on disk, keyed on a combination of hostname, port, and
        authentication realm.</para>  

      <para>When the client receives an authentication challenge, it
        first looks for the appropriae credentials in the disk cache;
        if not present, or if the cached credenials fail to
        authenticate, then the client simply prompts the user for the
        information.</para>

      <para>The security-paranoid people may be thinking to
        themselves, "caching passwords on disk?  That's terrible!  You
        should never do that!"  But please remain calm.  First, the
        <literal>auth/</literal> caching area is permission-protected
        so that only the user (owner) can read data from it, not the
        world at large.  If that's still not safe enough for you, you
        can disable credential caching.  To disable caching for a
        single command, pass the <literal>--no-auth-cache</literal>
        option:</para>

<screen>
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn rm newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
[...]
</screen>

      <para>Or, if you want to disable credential caching permanently,
        you can edit your runtime <literal>config</literal> file
        (located next to the <literal>auth/</literal> directory).
        Simply set </para>

<screen>
[auth]
store-auth-creds = no
</screen>

      <para>... and no credentials will be cached on disk, ever.</para>

      <para>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <literal>auth/</literal> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <literal>svn:realmstring</literal> key describes
        the particular server realm that the file is associated
        with:</para>

<screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>

      <para>Once you have located the proper cache file, just delete
      it.</para>

      <para>One last word about client authenication behavior: a bit
        of explanation about the <literal>--username</literal> and
        <literal>--password</literal> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these opions <emphasis>does not</emphasis>
        automatically send credentials to the server.  As discussed
        earlier, the server "pulls" credentials from the client when
        it deems necessary; the client cannot "push" them at will.  If
        a username and/or password are passed as options, they will
        <emphasis>only</emphasis> be presented to the server if the
        server requests them.  

          <footnote><para>Again, a common mistake is to misconfigure a
           server so that it never issues an authentication challenge.
           When users pass <literal>--username</literal> and
           <literal>--password</literal> options to the client,
           they're surprised to see that they're never used, i.e. new
           revisions still appear to have been committed
           anonymously!</para></footnote>
        
        Typically, these options are used when:
      </para>

      <itemizedlist>
        <listitem><para>the user wants to authenticate as a
            different user than her system login name, or</para>
        </listitem>
        <listitem><para>a script wants to authenticate without
            using cached credentials.</para>
        </listitem>
      </itemizedlist>
          

      <para>Here is a final summary that describes how a Subversion
        client behaves when it receives an authenication
        challenge:</para>

      <orderedlist>
        <listitem>
          <para>Check wheher the user specified any credentials as
            commandline options, via <literal>--username</literal>
            and/or <literal>--password</literal>.  If not, or if these
            options fail to authenticate successfully, then</para>
        </listitem>

        <listitem>
          <para>Look up the server's realm in the runtime
            <literal>auth/</literal> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</para>
        </listitem>

        <listitem>
          <para>Resort to prompting the user.</para>
        </listitem>
      </orderedlist>

      <para>If the client successfully authenicates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier.)</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-3">
    
    <title>svnserve, a custom server</title>

    <para>The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      schema.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>

    <sect2 id="svn-ch-6-sect-3.1">
      <title>Invoking the Server</title>

      <para>When executed directly on the commandline, the
      <command>svnserve</command> program attempts to speak with a
      Subversion client via <emphasis>stdin</emphasis> and
      <emphasis>stdout</emphasis> using a custom protocol:</para>


<screen>
$ svnserve
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</screen>
      
      <para>This sort of invocation isn't particularly useful unless
        you happen to be trying to debug the program.  This is,
        however, the standard behavior for a program run via
        <command>inetd</command>.  The IANA has reserved TCP port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add a line to <literal>/etc/services</literal> like
        this (if it doesn't already exist):</para>

<screen>
svnserve      3690/tcp                        # Subversion protocol
</screen>

      <para>...and when a client connection comes into your server on
        port 3690, <command>inetd</command> will spawn an
        <command>svnserve</command> process to service it.</para>

      <para>A second option is to run <command>svnserve</command> as a
        standalone "daemon" process.  Use the <option>-d</option>
        option for this:</para>

        <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>

      <para>When running <command>svnserve</command> in daemon mode,
        you can use the <option>--listen-port=</option> and
        <option>--listen-host=</option> options to customize the exact
        port and hostname to "bind" to.</para>

      <sidebar id="svn-ch-6-sidebar-1">
        <title>Servers and Permissions:  A Word of Warning</title>        

        <para>First, remember that a Subversion repository is a
          collection of BerkeleyDB database files; any process which
          accesses the repository directly needs to have proper read
          and write permissions on the entire repository.  If you're
          not careful, this can lead to a number of headaches.  Be
          sure to read <xref linkend="svn-ch-6-sect-5"/>.</para>

      <para>Secondly, when configuring <command>svnserve</command>, Apache
          <command>httpd</command>, or any other server process, keep in
          mind that you might not want to launch the server process as
          the user <literal>root</literal> (or as any other user with
          unlimited permissions).  Depending on the ownership and
          permissions of the repositories you're exporting, it's often
          prudent to use a different&mdash;perhaps custom&mdash;user.
          For example, many administrators create a new user named
          <literal>svn</literal>, grant that user exclusive ownership
          and rights to the exported Subversion repositories, and only
          run their server processes as that user.</para>
      </sidebar>

      <para>There's still a third way to invoke
        <command>svnserve</command>, and that's in "tunnel mode", with
        the <option>-t</option> option.  This mode assumes that a
        remote-service program such as <command>RSH</command> or
        <command>SSH</command> has successfully authenticated a user
        and is now invoking a private <command>svnserve</command>
        process as that user.  The <command>svnserve</command> program
        behaves normally (communicating via <emphasis>stdin</emphasis>
        and <emphasis>stdout</emphasis>), and assumes that the traffic
        is being automatically redirected over some sort of tunnel
        back to the client.  When <command>svnserve</command> is
        invoked by a tunnel agent like this, be sure that the
        authenticated user has full read and write access to the
        repository database files. (See <xref
        linkend="svn-ch-6-sidebar-1"/>.)  It's essentially the same as
        a local user accessing the repository via
        <literal>file:///</literal> URLs. </para>

      <para>Once the <command>svnserve</command> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <emphasis>absolute</emphasis> path in the repository URL.  For
        example, if a repository is located at
        <filename>/usr/local/repositories/project1</filename>, then a
        client would reach it via <systemitem
        class="url">svn://host.example.com/usr/local/repositories/project1
        </systemitem>.  To increase security, you can pass the
        <option>-r</option> option to <command>svnserve</command>,
        which restricts it to exporting only repositories below that
        path:</para>
      
<screen>
$ svnserve -d -r /usr/local/repositories
&hellip;
</screen>

      <para>Using the <option>-r</option> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</para>
      
<screen>
$ svn checkout svn://host.example.com/project1
&hellip;
</screen>
 
    </sect2>

    <sect2 id="svn-ch-6-sect-3.2">
      <title>Built-in authentication and authorization</title>

      <para>When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>

      <itemizedlist>
        <listitem><para>The client selects a specific
        repository.</para></listitem>

        <listitem><para>The server processes the repository's
        <filename>conf/svnserve.conf</filename> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</para></listitem>

        <listitem><para>Depending on the situation and authorization
        policies,</para>

          <itemizedlist>
            <listitem><para>the client may be allowed to make requests
                anonymously, without ever receiving an authentication
                challenge, OR</para></listitem>

            <listitem><para>the client may be challenged for
                authentication at any time, OR</para></listitem>

            <listitem><para>if operating in "tunnel mode", the client
                will declare itself to be already externally
                authenticated.</para></listitem>
          </itemizedlist>
        </listitem>

      </itemizedlist>

      <para>At the time of writing, the server only knows how to send
        a CRAM-MD5 <footnote><para>See RFC 2195.</para></footnote>
        authentication challenge.  In essence, the server sends a bit
        of data to the client.  The client uses its password to
        encrypt the data with the MD5 hash algorithm, and sends it
        back.  The server performs the same computation with the
        stored password to verify that the result is identical.  At no
        point does the actual password travel over the network.</para>

      <para>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <command>SSH</command>.  In that case, the server simply
        examines the user it's running as, and uses it as the
        authenticated username.</para>

      <para>As you've already guessed, a repository's
        <filename>svnserve.conf</filename> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <xref linkend="svn-ch-7-sect-1"/>): section names
        are marked by <literal>[square brackets]</literal>, comments
        begin with "<literal>#</literal>" characters, and each section
        contains specific variables that can be set (<literal>variable
        = value</literal>).  Let's walk through this file and learn
        how to use them.  </para>

      <sect3 id="svn-ch-6-sect-3.2.1">
        <title>Create a 'users' file and realm</title>

        <para>For now, the <literal>[general]</literal> section of the
          <filename>svnserve.conf</filename> has all the variables you
          need.  Begin by defining a file which contains usernames and
          passwords, and an authentication realm:</para>

<screen>
[general]
password-db = userfile
realm = example realm
</screen>

        <para>The <literal>realm</literal> is a name that you define.
            It tells clients which sort of "authentication namespace"
            they're connecting to; the Subversion client displays it
            in the authentication prompt, and uses it as a key (along
            with the server's hostname and port) for caching
            credentials on disk (see <xref
            linkend="svn-ch-6-sect-2.2"/>.)  The
            <literal>password-db</literal> variable points to a
            separate file that contains a list of usernames and
            passwords, using the same familiar format.  For
            example:</para>

<screen>
[users]
harry = foopassword
sally = barpassword
</screen>

        <para>The value of <literal>password-db</literal> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <filename>conf/</filename> area of the repository, alongside
          <filename>svnserve.conf</filename>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Whereever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <command>svnserve</command> will run
          as, restrict read access to the user file as necessary.</para>

      </sect3>

      <sect3 id="svn-ch-6-sect-3.2.1">
        <title>Set access controls</title>

        <para>There are two more variables to set in the
        <filename>svnserve.conf</filename> file: they determine what
        unauthenticated (anonymous) and authenticated users are
        allowed to do.  The variables <literal>anon-access</literal>
        and <literal>auth-access</literal> can be set to the values
        <literal>none</literal>, <literal>read</literal>, or
        <literal>write</literal>.   "<literal>none</literal>"
        restricts all access of any kind, "<literal>read</literal>"
        allows read-only access to the repository, and
        "<literal>write</literal>" allows complete read/write access
        to the repository.  For example:</para>

<screen>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</screen>

        <para>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</para>

<screen>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</screen>

        <para>Notice that <command>svnserve</command> only understands
          "blanket" access control.  A user either has universal
          read/write access, universal read access, or no access.
          There is no detailed control over access to specific paths
          within the repository.  For many projects and sites, this
          level of access control is more than adequate.  However, if
          you need per-directory access control, you'll need to use
          Apache instead of <command>svnserve</command> as your server
          process.</para>

      </sect3>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-3.3">
      <title>SSH authentication and authorization</title>

      <para><command>svnserve</command>'s built-in authentication can
        be very handy, because it avoids the need to create real
        system accounts.  On the other hand, some administrators
        already have well-established SSH authentication frameworks in
        place.  In these situations, all of the project's users
        already have system accounts and the ability to "SSH into" the
        server machine.</para>

      <para>It's easy to use SSH in conjunction with
      <command>svnserve</command>.  The client simply uses the
      <literal>svn+ssh://</literal> URL schema to connect:</para>

<screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  XXXXX

foo
bar
baz
&hellip;
</screen>

      <para>What's happening here is that the Subversion client is
        invoking a local <command>ssh</command> process, connecting to
        <literal>host.example.com</literal>, authenticating as user
        'harry', then spawning a private <command>svnserve</command>
        process on the remote machine, running as user 'harry'.  The
        <command>svnserve</command> command is being invoked in tunnel
        mode (<option>-t</option>) and all network protocol is being
        "tunneled" over the encrypted connection by
        <command>ssh</command>, the tunnel-agent.
        <command>svnserve</command> is aware that it's running as user
        'harry', and if the client performs a commit, the
        authenticated username will be attributed as the author of the
        new revision.</para>

      <para>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if harry were
        accessing the repository directly via a
        <literal>file:///</literal> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks.  (Be sure to read <xref
        linkend="svn-ch-6-sect-5"/>.)  But even in the case of
        tunneling, the <filename>svnserve.conf</filename> file can
        still be used to block access, by simply setting
        <literal>auth-access = read</literal> or <literal>auth-access
        = none</literal>.</para>
      
      <para>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your run-time <filename>config</filename>
        file (see <xref linkend="svn-ch-7-sect-1"/>.)  For example,
        suppose you want to use RSH instead of SSH.  In the
        <literal>[tunnels]</literal> section of your
        <filename>config</filename> file, simply define it like
        this:</para>

<screen>
[tunnels]
rsh = rsh
</screen>

      <para>And now, you can use this new tunnel definition by using a
        URL schema that matches the name of your new variable:
        <literal>svn+rsh://host/path</literal>.  When using the new
        URL schema, the Subversion client will actually be running the
        command <command>rsh host svnserve -t</command> behind the
        scenes.  If you include a username in the URL (for example,
        <literal>svn+rsh://username@host/path</literal>) the client
        will also include that in its command (<command>rsh
        username@host svnserve -t</command>.)  But you can define new
        tunneling schemes to be much more clever than that:</para>

<screen>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</screen>

      <para>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <filename>/opt/alternate/ssh</filename>) with specific
        options.  In this case, accessing a
        <literal>svn+joessh://</literal> URL would invoke the
        particular SSH binary with <option>-p 29934</option> as
        arguments&mdash; useful if you want the tunnel program to
        connect to a non-standard port.  Second, it shows how to
        define a custom environment variable that can override the
        name of the tunneling program.  If we were to set the
        <literal>JOESSH</literal> environment variable to a different
        program, it would be executed instead of
        <filename>/opt/alternate/ssh</filename>.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-4">
    
    <title>httpd, the Apache HTTP server</title>

    <para>in this intro, explain why apache2, not apache1.  also
      explain why it's not a big deal to require apache2.</para>

    <sect2 id="svn-ch-6-sect-4.1">
      <title>SVNPath and SVNParentPath directives</title>

      <para>show simplest possible Location block with these
      directives.</para>

    </sect2>

    <sect2 id="svn-ch-6-sect-4.2">
      <title>Authentication Options</title>

      <para>anonymous auth;  basic auth via AuthUserFile;  certificate
        setup:  ptrs to apache docs on setting up httpd.conf for this,
        and document how to manage client/server certs from client.</para>

    </sect2>
    
    <sect2 id="svn-ch-6-sect-4.3">
      <title>Authorization Options</title>

      <para>blanket access control via 'Require' directive;  per-path
        access control via mod_authz_svn (document the syntax!)</para>

    </sect2>


  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-6-sect-5">
    
    <title>Using Multiple Servers</title>

    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible&mdash;or safe&mdash;for
      your repository to be accessed by multiple repository access
      methods simultaneously?  The answer is yes, provided you use a
      bit of foresight.</para>
    
    <para>At any given time, these processes may require read and/or
      write access to your repository:</para>
    
    <itemizedlist>
      <listitem>
        <para>regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file:///</literal> URLs;</para>
      </listitem>
      <listitem>
        <para>regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves) which access the repository;</para>
      </listitem>
      <listitem>
        <para>an <command>svnserve</command> process&mdash;either a
          daemon or one launched by
          <command>inetd</command>&mdash;running as a particular fixed
          user;</para>
      </listitem>
      <listitem>
        <para>an Apache <command>httpd</command> process, running as a
          particular fixed user.</para>
      </listitem>
    </itemizedlist>
    
    <para>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <literal>svn</literal> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&mdash;one that prevents access by
      other users.</para>
    
    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first sets <command>umask 002</command> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <command>umask
      002</command> command to Apache's own startup script,
      <filename>apachectl</filename>.</para>

    <!-- TODO: example of such a wrapper script? -->
    
    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</para>
    
    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs&mdash;they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server that best meets your needs
      and stick with it!</para>

  </sect1>




</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
