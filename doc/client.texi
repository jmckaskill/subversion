@node Client
@chapter Client

The Subversion client is built on three libraries.  The first two are
low-level: one for local working copy management, the other for
communicating with the server.  The third library provides high-level
wrappers around these low-level operations, to implement basic client
operations such as @code{commit} and @code{update}.

The initial client is a Unix-style command-line tool (like standard
CVS), but there is no reason why that has to be the only client.  The
libraries exist to separate Subversion-specific functionality from
user-interface decisions; a GUI client can use the libraries as easily
as a command-line client can.

This chapter describes the libraries, and the physical layout of working
copies.

@menu
* Terminology
* The working copy management library
* The repository access library
* The high-level client operation library
* The layout of working copies
@end menu

@c todo: make sure skelta gets define somewhere

@c -----------------------------------------------------------------------
@node Terminology
@subsection Terminology

TODO: this should go somewhere else in the document

@example
   "diff"              ===> a textual diff, like the output of GNU diff

   "vdelta", "vdiff"   ===> you know what this is

   "pdelta", "pdiff"   ===> deltas for property lists.  
                            May include vdeltas. 

   "delta"             ===> the lispy encapsulating data structure.
                            May include vdeltas and pdeltas.

   "skelta"            ===> a skeleton delta, holds everything but the
                            actual vdeltas and pdeltas.

@end example

@c -----------------------------------------------------------------------
@node The working copy management library
@subsection The working copy management library

This library performs "offline" operations on the working copy.

@table @code

@item skelta make_skelta (path1, ...)

Returns a skelta -- a delta object describing the changes to PATHs, but
not including the actual content of the changes (i.e., the vdeltas).  In
other words, this is how you get a list of all local modifications.

A PATH can be a directory or a file; if directory, then it's a root from
which to start looking for modifications.  

Takes multiple @code{path} arguments because you might want to do
something like this:

@example
   $ svn commit foo/ bar/ baz/qux.c
@end example

The commit is atomic, and covers some but not necessarily all of the
subdirectories available here.  Therefore, it must be possible to
request a delta for any subset of the working tree.  Although some files
and directories outside that subset might also have been modified, the
delta will not include those changes.

@item delta fill_skelta (skelta)

Turns a skelta into a delta by generating the vdiffs and placing them
into the skelta.

(Note to self: probably okay for this to modify its argument.)

@item make_delta (path1, ...)

Equivalent to 

@example
@code
   fill_skelta (make_skelta (path1, ...))
@end code
@end example

@item apply_delta (delta)

Applies a delta to a tree.

@item add (path)

Add this file (i.e., tweak the administrative files appropriately).

@item remove (path)

Remove this file.

@item rename (old_path, new_path)

Move/rename this file (within the working copy, of course).

@item read_prop (path, name)

Return the value of the property named NAME.

@item write_prop (path, name, value)

Set the value of the property NAME to VALUE.

@end table

@c -----------------------------------------------------------------------
@node The repository access library
@section The repository access library

This library performs operations involving communication with the
repository.

@table @code

@item latest (repository, path)

Report the latest version in the repository for PATH.

@item approve_delta (repository, delta)

@item commit_delta (repository, delta)

@item changes_between (repository, path1, version1, version2)

TODO: Unclear whether path relative to ver1 or ver2, and should we be
using an entity number instead?  No, that hasn't been standard
practice.  Think about the general question of client-visibility of
those numbers...

@item get_property (repository, version)

TODO: yes, but how does it know the repository?  Just using the current
working directory seems kind of lame... :-)

@item find_repository_modified (path1, ...)

@item PLACEHOLDER

TODO: go through the cvs ops now...

@item update (path1, ...)

TODO: update() is complex because not everything has the same base
revision; this interface is hiding a lot of complexity -- the client has
to get a delta from the server that's appropriate for the particular set
of versions the client has.  Look over server section, see what the
server's interface is...

@end table

TODO: mention the combo ops from the yellow sheet...

@c -----------------------------------------------------------------------
@node The layout of working copies
@subsection The layout of working copies

As with CVS, Subversion working copies are simply directory trees with
special administrative subdirectories, in this case named "SVN" instead
of "CVS":

@example

                             myproj
                             / | \
               _____________/  |  \______________
              /                |                 \
            SVN               src                doc
        ___/ | \___           /|\             ___/ \___
       |     |     |         / | \           |         |
      base  ...   ...       /  |  \     myproj.texi   SVN
     / |                   /   |   \              ___/ | \___
    /  |              ____/    |    \____        |     |     |
  src doc            |         |         |      base  ...   ...
                    SVN      foo.c     bar.c     |
                ___/ | \___                      |
               |     |     |                     |
             base   ...   ...               myproj.texi
          ___/ \___
         |         |
       foo.c     bar.c

@end example

Although often it would often be possible to deduce certain information
by examining parent directories, this is avoided in favor of making each
directory be as much a self-contained unit as possible (this will make
it easier to mix subtrees of different projects later on).

For example, immediately after a checkout the administrative information
for the entire working tree @emph{could} be stored in one top-level
file.  But the subdirectories also keep track of their own version and
repository information; this would be necessary anyway once the user
starts committing new versions of particular files, but Subversion does
it right from the beginning, for consistency.

The SVN subdir stores:

@itemize @bullet

@item
A @dfn{base tree}, containing the pristine repository versions of the
files and subdirectories there.  Note that subdirectories are stored
shallowly, solely to record permission information.  The actual base
versions of a subdir's files are stored in "SVN/base/" for that subdir.

@item
A @file{versions} file, the first entry of which records the version
number of this directory (and, by implication, the version number of any
files not otherwise mentioned in the file).  The remaining entries
record version information for files here which are at some version
other than the default.

It may help to think of this file as the functional equivalent of the
CVS/Entries file.  Like Entries, it also holds file metadata that can't
always be stored in the filesystem (properties).

@item
A @file{changes} file, recording uncommitted changes to and from this
directory (adds, removes, renames).

@item
A @file{lock} file, whose presence implies that a CVS client is
currently operating on the adminstrative area.

@item

@end itemize
