@node Client Cookbook
@chapter Client Cookbook

How to make a lovely gumbo with your Subversion client, in 11 easy steps.

This chapter goes into more of the gritty details of client commands.
For a first overview of the client's CVS-like ``copy-modify-merge''
model of development, @xref{Basics}.

Before reading on, here is the most important piece of information
you'll ever need when using Subversion: @samp{svn help}.  The
Subversion command-line client tries to be self-documenting; at any
time, a quick @samp{svn help <subcommand>} will describe the
syntax, switches, and behavior of @command{subcommand}.

This chapter by no means covers every option to every client
subcommand.  Instead, it's a conversational introduction to the most
common tasks you'll encounter.  When in doubt, run @samp{svn help}.

@menu
* Checkout::
* Basic Work Cycle::
* History::
* Branches and Tags::
* Properties::
* Modules::
* Revisions::
* Other Commands::
* Run-time Configuration::
@end menu

@c ------------------------------------------------------------------
@node Checkout
@section Checkout

Most of the time, you will start using a Subversion repository by
doing a @dfn{checkout} of your project.  ``Checking out'' will provide
you with a local copy of the HEAD (latest revision) of the Subversion
repository that you checked out.

@example
$ svn co http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
@dots{}
Checked out revision 2499.
@end example

Although the above example checks out the trunk directory, you can just
as easily checkout any deep subdirectory of a repository by specifying
the subdirectory in the checkout URL:

@example
$ svn co http://svn.collab.net/repos/svn/trunk/doc/handbook
A  handbook/svn-handbook.texi
A  handbook/getting_started.texi
A  handbook/outline.txt
A  handbook/license.texi
A  handbook/repos_admin.texi
A  handbook/client.texi
Checked out revision 2499.
@end example

Since Subversion uses a ``copy-modify-merge'' model instead of
``lock-modify-unlock,'' you're now ready to start making changes to
the files that you've checked out, known collectively as your
@dfn{working copy}. You can even delete the entire working copy and
forget about it entirely -- there's no need to notify the Subversion
server unless you're ready to @dfn{check in} changes, a new file, or
even a directory.

Every directory in a working copy contains an @dfn{administrative
area}, a subdirectory named @file{.svn}.  Normal @command{ls} commands
won't show this subdirectory, but it's vital.  Whatever you do, don't
delete or change anything in the administrative area!  Subversion
depends on it to manage your working copy.

You can run @samp{svn help checkout} for command line options to
checkout, although one option is very common and worth mentioning: you
can specify a directory after your repository url.  This places your working
copy into a new directory that you name.  For example:

@example
$ svn co http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
@dots{}
Checked out revision 2499.
@end example

@c ------------------------------------------------------------------
@node Basic Work Cycle
@section Basic Work Cycle

Subversion has numerous features, options, bells and whistles, but on
a day-to-day basis, odds are that you will only use a few of them. In
this section we'll run through the most common things that you might
find yourself doing with Subversion in the course of a day's work.

The typical work cycle looks like this:

@itemize @bullet
@item
Update your working copy
@item
Make changes
@item
Examine your changes
@item
Merge others' changes
@item
Commit your changes
@end itemize

@c ---------------
@subsection Update your working copy (@samp{svn up})

When working on a project with a team, you'll want to @dfn{update}
your working copy: that is, receive any changes from other developers
on the project.  @samp{svn update} brings your working copy in-sync
with the latest revision in the repository.

@example
$ svn up
U  ./foo.c
U  ./bar.c
Updated to revision 2.
@end example

In this case, someone else checked in modifications to both
@file{foo.c} and @file{bar.c} since the last time you updated, and
Subversion has updated your working copy to include those changes.

Let's examine the output of @samp{svn update} a bit more.  When the
server sends changes to your working copy, a letter code is displayed
next to each item:

@table @b
@item U  @file{foo}
File @file{foo} was (U)pdated (received changes from the server.)
@item A  @file{foo}
File or directory @file{foo} was (A)dded to your working copy.
@item D  @file{foo}
File or directory @file{foo} was (D)eleted from your working copy.
@item R  @file{foo}
File or directory @file{foo} was (R)eplaced in your working copy;
that is, @file{foo} was deleted, and a new item with the same name
was added.  While they may have the same name, the repository
considers them to be distinct objects with distinct histories.
@item G  @file{foo}
File @file{foo} received new changes, but also had changes of your own
to begin with.  The changes did not intersect, however, so Subversion
has mer(G)ed the repository's changes into the file without a problem.
@item C  @file{foo}
File @file{foo} received (C)onflicting changes from the server.  The
changes from the server directly overlap your own changes to the file.
No need to panic, though.  This overlap needs to be resolved by a
human (you); we discuss this situation further down.
@end table



@subsection Make changes  (@samp{svn add}, @samp{svn rm}, @samp{svn cp}, @samp{mv})

Now you can to get to work and make changes in your working copy. It's
usually most convenient to create a ``task'' for yourself, such as
writing a new feature, fixing a bug, etc.

What kinds of changes can you make to your working copy tree?

@table @b
@item File changes
This is the simplest sort of change.  Unlike other revision control
systems, you don't need to tell Subversion that you intend to change a
file; just do it.  Later on, Subversion will be able to automatically
detect which files have been changed.
@item Tree changes
You can ask Subversion to ``mark'' files and directories for scheduled
removal or addition.  Of course, no additions or removals will happen
in the repository until you decide to commit.
@end table

To make file changes, just use your normal editor, word processor, or
whatever.   A file needn't be in text-format; binary files work just
fine.

There are at least four Subversion subcommands for making tree
changes.  Detailed help can be found with @samp{svn help}, but here
is an overview:

@table @command
@item @samp{svn add @file{foo}}
Schedule @file{foo} to be added to the repository.  When you next
commit, @file{foo} will become a permanent child of its parent
directory.  Note that if @file{foo} is a directory, only the directory
itself will be scheduled for addition.  If you want to add its
contents as well, pass the @option{--recursive} switch.
@item @samp{svn rm @file{foo}}
Schedule @file{foo} to be removed from the repository.  If @file{foo}
is a file, it immediately vanishes from the working copy -- but it can
be recovered with @samp{svn revert} (see below).  If @file{foo} is
a directory, it is merely scheduled for deletion.  After you commit,
@file{foo} will no longer exist in the working copy or repository.
@item @samp{svn cp @file{foo} @file{bar}}
Create new item @file{bar} as a duplicate of @file{foo}.  @file{bar}
is automatically scheduled for addition.  When @file{bar} is added to
the repository on the next commit, it's copy-history is recorded (as
having originally come from @file{foo}.)
@item @samp{svn mv @file{foo} @file{bar}}
This command is exactly the same as running @samp{svn cp foo bar;
svn rm foo}.  That is, @file{bar} is scheduled for addition as a copy
of @file{foo}, and @file{foo} is scheduled for removal.
@end table

Let's ammend our original statement: there @emph{are} some use-cases
that immediately commit tree changes to the repository.  This usually
happens when a subcommand is operating directly on a URL, rather than
on a working-copy path. (In particular, specific uses of @samp{svn
mkdir}, @samp{svn cp}, @samp{svn mv}, and @samp{svn rm} can work with
URLs.  See @samp{svn help} on these commands for more details.)

@subsection Examine your changes  (@samp{svn status}, @samp{svn diff}, @samp{svn revert})

So now you've finished your changes@dots{} or so you think.  But what
exactly did you change?  How can you review them?

Subversion has been optimized to help you with this task, and is able
to do many things without talking to the repository or network at all.
In particular, your working copy contains a secret cached ``pristine''
copy of each file within the @file{.svn} area.  Because of this, it
can quickly show you how your working files have changed, or even
allow you to undo your changes.

The @samp{svn status} command is your friend; become intimate with
it.  You'll probably use @samp{svn status} more than any other
command.

If you run @samp{svn status} at the top of your working copy with no
arguments, it will detect all file and tree changes you've made.  This
example is designed to show all the different status codes that
@samp{svn status} can return.  The text in @samp{[]} is not printed by
@samp{svn status}.

@example
$ svn status
_ L    ./abc.c               [svn has a lock in its .svn directory for abc.c]
M      ./bar.c               [the content in bar.c has local modifications]
_M     ./baz.c               [baz.c has property but no content modifications]
?      ./foo.o               [svn doesn't manage foo.o]
!      ./foo.c               [svn knows foo.c but a non-svn program deleted it]
A  +   ./moved_dir           [added with history of where it came from]
M  +   ./moved_dir/README    [added with history and has local modifications]
D      ./stuff/fish.c        [this file is scheduled for deletion]
A      ./stuff/things/bloo.h [this file is scheduled for addition]
@end example

In this output format @samp{svn status} prints four columns of
characters followed by several whitespace characters followed by a file
or directory name.  The first column tells the status of a file or
directory and/or its contents.  The codes printed here are

@table @b
@item _      @file{file_or_dir}
The file or directory has not been added or deleted, nor has
@file{file_or_dir}'s contents been modified if it is a file.
@item A      @file{file_or_dir}
The file or directory @file{file_or_dir} has been scheduled for addition
into the repository.
@item M      @file{file}
The contents of file @file{file} have been modified.
@item D      @file{file_or_dir}
The file or directory @file{file_or_dir} has been scheduled for deletion
from the repository.
@item ?      @file{file_or_dir}
The file or directory @file{file_or_dir} indicates that this file or
directory is not under revision control.  You can silence the question
marks by either passing the @option{--quiet} (@option{-q}) option to
@samp{svn status}, or by setting the @samp{svn:ignore} property on the
parent directory, @xref{Properties}.
@item !      @file{file_or_dir}
The file or directory @file{file_or_dir} is under revision control but
the working copy is missing.  This happens if the file or directory is
removed using a non-Subversion command.  A quick @samp{svn up} or
@samp{svn revert file_or_dir} will restore the missing file from its
cached pristine copy.
@end table

The second column tells the status of a file's or directory's
properties, @xref{Properties}.  If a @samp{M} appears in the second
column, then the properties have been modified, otherwise a whitespace
will be printed.  If only the properties of a file or directory are
modified, then you will get @samp{_M} printed in the first and second
columns.  The first @samp{_} is just printed to make it clear to the eye
that the properties are modified and not the contents.

The third column will only show whitespace or a @samp{L} which means
that @command{svn} has locked item locked in the @file{.svn} working
area.  You will see @samp{L} if you run @samp{svn status} in a directory
you are currently running @samp{svn commit} when you are editing the log
message.  If there are no running @command{svn}'s, then presumably
@command{svn} was forcibly quit or died and the lock needs to be cleaned
up by running @samp{svn cleanup}.  Locks typically appear if a
Subversion command is interrupted before completion.

The forth column will only show whitespace or a @samp{+} which means
that the file or directory is scheduled to be added or modified with
additional attached history.  This typically happens when you @samp{svn
mv} or @samp{svn cp} a file or directory.  If you see @samp{A @ @ +},
this means the item is scheduled for addition-with-history.  It could be
a file, or the root of a copied directory.  @samp{_ @ @ +} means the
item is part of a subtree scheduled for addition-with-history, i.e. some
parent got copied, and it's just coming along for the ride.  @samp{M @ @
+} means the item is part of a subtree scheduled for
addition-with-history, @emph{and} it has local mods.  When you commit,
first some parent will be added-with-history (copied), which means this
file will automatically exist in the copy.  Then the local mods will be
further uploaded into the copy.

By default, @samp{svn status} ignores files matching the regular
expressions @samp{*.o}, @samp{*.lo}, @samp{*.la}, @samp{#*#},
@samp{*.rej}, @samp{*~}, and @samp{.#*}.  If you want additional files
ignored, set the @samp{svn:ignore} property on the parent directory.  If
you want to see the status of all the files in the repository
irrespective of @samp{svn status} and @samp{svn:ignore}'s regular
expressions, then use the @option{--no-ignore} command line option.

If a single path is passed to the command, it will tell you about it:

@example
$ svn status stuff/fish.c
D      stuff/fish.c
@end example

This command also has a @option{--verbose} (@option{-v}) mode, which will
show you the status of @emph{every} item in your working copy:

@example
$ svn status -v
M               44        23    joe       ./README
_               44        30    frank     ./INSTALL
M               44        20    frank     ./bar.c
_               44        18    joe       ./stuff
_               44        35    mary      ./stuff/trout.c
D               44        19    frank     ./stuff/fish.c
_               44        21    mary      ./stuff/things
A                0         ?     ?        ./stuff/things/bloo.h
_               44        36    joe       ./stuff/things/gloo.c
@end example

This is the ``long form'' output of @samp{svn status}.  The first
column is still the same.  The second column shows the
working-revision of the item.  The third and fourth column show the
revision in which the item last changed, and who changed it.

Finally, there is a @option{--show-updates} (@option{-u}) switch, which
contacts the repository and adds information about things that are
out-of-date:

@example
$ svn status -u -v
M      *        44        23    joe       ./README
M               44        20    frank     ./bar.c
_      *        44        35    mary      ./stuff/trout.c
D               44        19    frank     ./stuff/fish.c
A                0         ?     ?        ./stuff/things/bloo.h
@end example

Notice the two asterisks: if you were to run @samp{svn up} at this
point, you would receive changes to @file{README} and @file{trout.c}.
Hmmm, better be careful.  You'll need to absorb those server-changes
on @file{README} before you commit, lest the repository reject your
commit for being out-of-date.  (More on this subject below.)

Another way to examine your changes is with the @samp{svn diff}
command.  You can find out @emph{exactly} how you've modified things
by running @samp{svn diff} with no arguments, which prints out file
changes in unified diff format:

@example
$ svn diff
Index: ./bar.c
===================================================================
--- ./bar.c
+++ ./bar.c	Mon Jul 15 17:58:18 2002
@@ -1,7 +1,12 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <stdio.h>
  
 int main(void) @{
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
   return 0;
 @}

Index: ./README
===================================================================
--- ./README
+++ ./README	Mon Jul 15 17:58:18 2002
@@ -193,3 +193,4 @@ 
+Note to self:  pick up laundry.

Index: ./stuff/fish.c
===================================================================
--- ./stuff/fish.c
+++ ./stuff/fish.c  Mon Jul 15 17:58:18 2002
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: ./stuff/things/bloo.h
===================================================================
--- ./stuff/things/bloo.h
+++ ./stuff/things/bloo.h  Mon Jul 15 17:58:18 2002
+Here is a new file to describe
+things about bloo.
@end example

The @samp{svn diff} command produces this output by comparing your
working files against the cached ``pristine'' copies within the
@file{.svn} area.  Files scheduled for addition are displayed as all
added-text, and files scheduled for deletion are displayed as all
deleted text.

Now suppose you see this output, and realize that your changes to
@file{README} are a mistake; perhaps you accidentally typed that text
into the wrong file in your editor.

The @samp{svn revert} command is exactly for this purpose.  It
throws away all changes to your file:

@example
$ svn revert README
Reverted ./README
@end example

The file is reverted to its pre-modified state by overwriting it with
the cached ``pristine'' copy.  But also note that @samp{svn revert}
can undo any scheduled operations -- in case you decide that you don't
want to add a new file after all, or that you don't want to remove
something.

A final reminder: all three of these commands (@samp{svn status},
@samp{svn diff}, @samp{svn revert}) can be used without any
network access (except for the @option{-u} switch to status).  This
makes it easy to manage your changes-in-progress while traveling on
an airplane, etc.

@subsection Merge others' changes  (conflict resolution)

We've already seen how @samp{svn status -u} can predict conflicts.
Suppose you run @samp{svn update} and some interesting things
occur:

@example
$ svn up
U  ./INSTALL
G  ./README
C  ./bar.c
@end example

The U and G codes are nothing to sweat about; those files cleanly
absorbed changes from the repository.  The @samp{G} stands for mer(G)ed,
which means that the file had local changes to begin with, but the
repository changes didn't overlap in any way.

But the @samp{C} stands for conflict.  This means that the server's changes
overlapped with your own, and now you have to manually choose between
them.

Whenever a conflict occurs:

@itemize @bullet
@item
a @samp{C} is printed during the update, and Subversion remembers that the
file is ``conflicted''.
@item
three fulltext files starting with @file{tmp} are created; these files
are the original three files that could not be merged together.
@item
conflict markers are placed into the file, to visibly demonstrate the
overlapping areas.
@end itemize

At this point, Subversion will @emph{not} allow you to commit the file
until the three temporary files are removed.

If you get a conflict, you need to either (1) hand-merge the
conflicted text (by examining and editing the conflict markers within
the file), (2) copy one of the tmpfiles on top of your working file, or
(3) run @samp{svn revert} to toss all of your changes.

Once you've resolved the conflict, you need to let Subversion know by
removing the three tmpfiles.  (The @samp{svn resolve} command, by
the way, is a shortcut that does nothing but automatically remove the
three tmpfiles for you.)  When the tmpfiles are gone, Subversion no
longer considers the file to be in a state of conflict anymore.


@subsection Commit your changes

Finally!  Your edits are finished, you've merged all updates from the
server, and you're ready to commit your changes.

The @samp{svn commit} command sends all (or some) of your changes
to the repository.  When you commit a change, you need to supply a
@dfn{log message}, describing your change.  Your log message will be
permanently attached to the new revision you create.

@example
$ svn commit -m "Added include lines and corrected # of cheese slices."
Sending        bar.c
Transmitting file data .
Committed revision 3.
$
@end example

Another way to specify a log message is to place it in a file, and
pass the filename with the @option{-F} switch.  If you fail to
specify either the @option{-m} or @option{-F} switch, then Subversion will
automatically launch your favorite @samp{$EDITOR} for composing a log
message.

The repository doesn't know or care if your changes make any sense as
a whole; it only checks to make sure that nobody else has changed any
of the same files that you did when you weren't looking.  If somebody
@emph{has} done that, the entire commit will fail with a message
informing that one or more of your files is out-of-date.  At this
point, you need to run @samp{svn update} again, deal with any
merges or conflicts that result, and attempt your commit again.

That covers the most basic work cycle for using Subversion. Run
@samp{svn help @var{commandname}} for help on any of the commands
covered in this section.


@c ------------------------------------------------------------------
@node History
@section History

As we mentioned earlier, the repository is like a time machine.  It
remembers every revision ever committed, and allows you to explore
this history.

There are two commands that mine historical data from the repository.
@samp{svn log} shows you broad information: log messages attached
to revisions, and which paths changed in each revision.  @samp{svn
diff}, on the other hand, can show you the specific details of how a
file changed over time.

@subsection @samp{svn log}

To find out information about the history of a file or directory, you
use the @samp{svn log} command. @samp{svn log} will tell you who
made changes to a file and at what revision, the time and date of that
revision, and the log message that accompanied the commit.

@example
$ svn log
------------------------------------------------------------------------
rev 3:  fitz | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
rev 2:  someguy | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
rev 1:  fitz | Mon, 15 Jul 2002 17:40:08 -0500 | 2 lines

Initial import
------------------------------------------------------------------------
@end example

Note that the log messages are printed in reverse chronological order
by default.  If you wish to see a different range of revisions in a
particular order, or just a single revision, pass the
@option{--revision} (@option{-r}) switch:

@example
$ svn log -r 5:19
@dots{}  # shows logs 5 through 19 in chronological order
$ svn log -r 19:5
@dots{}  # shows logs 5 through 19 in reverse order
$ svn log -r 8
@dots{}
@end example

You can also examine the log history on a single file or directory.
The commands

@example
$ svn log foo.c
@dots{}
$ svn log http://foo.com/svn/trunk/code/foo.c
@dots{}
@end example

will display log messages @emph{only} for those revisions in which the
working file (or URL) changed.

And while we're on the subject, @samp{svn log} also takes a
@option{--verbose} (@option{-v}) option too; it includes a list of
changed-paths in each revision:

@example
$ svn log -r 8 -v
------------------------------------------------------------------------
rev 8:  jrandom | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
   U /trunk/code/foo.c
   U /trunk/code/bar.h
   A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
@end example

@subsection @samp{svn diff}

We've already seen @samp{svn diff} in an previous section; it
displays file differences in unified diff format.  Earlier, it was
used to show the local modifications made to our working copy.

In fact, it turns out that there are @emph{three} distinct uses of
@samp{svn diff}:

@subsubsection Examining local changes
Invoking @samp{svn diff} with no switches will compare your working
files to the cached ``pristine'' copies in the @file{.svn} area:

@example
$ svn diff foo
Index: ./foo
===================================================================
--- ./foo
+++ ./foo	Tue Jul 16 15:19:53 2002
@@ -1 +1,2 @@
 An early version of the file
+...extra edits
@end example

@subsubsection Comparing working copy to repository
If a single @option{--revision} (@option{-r}) number is passed, then your
working files are compared to a particular revision in the repository.

@example
$ svn diff -r 3 foo
Index: ./foo
===================================================================
--- ./foo
+++ ./foo	Tue Jul 16 15:19:53 2002
@@ -1,2 +1,2 @@
 An early version of the file
-Second version of the file
+...extra edits
@end example

@subsubsection Comparing repository to repository
If two revision numbers are passed via @option{-r}, then the two
revisions are directly compared.

@example
$ svn diff -r 2:3 foo

Index: ./foo
===================================================================
--- ./foo
+++ tmp.280.00001	Tue Jul 16 15:22:19 2002
@@ -1 +1,2 @@
 An early version of the file
+Second version of the file
@end example


If you read the help for @samp{svn diff}, you'll discover that you
can supply URLs instead of working copy paths as well.  This is
especially useful if you wish to inspect changes when you have no
working copy available:

@example
$ svn diff -r 23:24 http://foo.com/some/project
@dots{}
@end example


@c ------------------------------------------------------------------
@node Branches and Tags
@section Branches and Tags

Branches and tags are general concepts common to almost all revision
control systems.  If you're not familiar with these ideas, you can
find a good introductory explanation in Karl Fogel's free CVS
book: @uref{http://cvsbook.red-bean.com/cvsbook.html#Branching_Basics}

At this point, you should understand how each commit creates an entire
new filesystem tree in the repository.  (If not, read about
@dfn{revisions}, @xref{Transactions and Revision Numbers}, or
@xref{Revision numbers are different now}.)

As you may have suspected, the filesystem doesn't grow 652 new inodes
each time a new revision is created.  Instead, each new tree is
@emph{mostly} made of pointers to already-existing nodes; new nodes
are created only for changed items, and all the rest of the revision
tree is ``shared storage'' with other revision trees.  This technique
demonstrates how the filesystem is able to make ``cheap copies'' of
things.  These cheap copies are nothing more than directory entries
that point to existing nodes.  And this is the basis of tags and
branches.


@subsection Branching with @samp{svn cp} 

Suppose we have a repository whose head tree is revision 82.  In this
repository is a subdirectory @file{mooIRC} that contains a software
project that is ready to be tagged.  How do we tag it?  Very simple:
make a ``cheap'' copy of this directory.  In other words, create a new
directory entry (somewhere else in the filesystem) that points to this
@emph{specific} node that represents directory @file{mooIRC} in
revision 82.  Of course, you can name the new directory entry whatever
you want -- probably a tag-name like @file{mooIRC-beta}.

The easiest way to make this copy is with @samp{svn cp}, which,
incidentally, can operate entirely on URLs, so that the copy happens
only on the server-side:

@example
$ svn cp http://foo.com/repos/mooIRC \
         http://foo.com/repos/mooIRC-beta
Committed revision 83.
@end example

Now, as long as you never touch the contents of the directory
@file{mooIRC-beta}, that entry will forever point to a node that looks
the way @file{mooIRC} did at a specific moment in time (however it
looked in revision 82).  And that's exactly what a @dfn{tag} is.

But suppose @file{mooIRC-beta} isn't sacred, and instead you decide to
start making commits to it.  And suppose you @emph{also} continue to
make commits in the original @file{mooIRC} directory.  Then you have
two directories that started out looking identical -- their common
ancestor was @file{mooIRC} in revision 82 -- but now have diverged
their contents over time.  In other words, they represent different
@dfn{branches} of the project.

It's very important to note that the Subversion filesystem is
@emph{not} aware of ``tags'' or ``branches.''  It's only aware of
directories, and all directories are equal.  The tag and branch
concepts are purely @emph{human} meanings attached to particular
directories.

For this reason, it's up to users (and the Subversion repository
administrator) to choose sane policies that help elucidate these
labels.  For example, here's a good way to lay out your repository:

@example
   /
   /projectA
   /projectA/trunk/
   /projectA/branches/
   /projectA/tags/
   /projectB
   /projectB/trunk/
   /projectB/branches/
   /projectB/tags/
@end example

Each time @file{/projectA/trunk} reaches a taggable state, make a copy
of the directory somewhere in @file{/projectA/tags/}, and set the copy
to read-only.  Use the same procedure to create a branch in
@file{/projectA/branches/}.

An alternate way to lay out a repository:

@example
   /
   /trunk
   /trunk/projectA
   /trunk/projectB
   /branches
   /branches/projectA
   /branches/projectB
   /tags
   /tags/projectA
   /tags/projectB
@end example

Or, of course, you could just place each project into a dedicated
repository.  It's up to you.  (@xref{FAQ}.) @c ###


@subsection Switching to a branch with @samp{svn switch}

The @samp{svn switch} command allows you to ``move'' some or all of
your working copy to a branch or tag.  For example, suppose I have a
working copy of @file{mooIRC}, and I'd like to work on some subsystem
as it appears in a subdirectory of @file{mooIRC-beta}.  At the same
time, I want the rest my working copy to remain on the original
@file{mooIRC} branch.  To do this, I switch the appropriate subdir to
the new branch location:

@example
$ svn switch http://foo.com/repos/mooIRC-beta/subsystems/renderer \
             mooIRC/subsystems/renderer

U  mooIRC/subsystems/renderer/foo.c
U  mooIRC/subsystems/renderer/bar.h
U  mooIRC/subsystems/renderer/baz.c
@end example

Now my working copy of the @file{renderer} subdirectory represents a
different location on the server.

Really, @samp{svn switch} is just a fancier version of @samp{svn
update}.  Whereas @samp{svn update} has the ability to move your
working copy through time (either by updating to the latest revision,
or by updating to a specific revision given with @option{-r}),
@samp{svn switch} is able to move your working copy through time
@emph{and} space.

If your working copy contains a number of ``switched'' subtrees from
different repository locations, it continues to function as normal.
When you update, you'll receive patches to each subtree as
appropriate.  When you commit, your local changes will still be
applied as a single, atomic change to the repository.

@subsection Moving changes with @samp{svn merge}

Suppose a team of programmers working on the @file{mooIRC-beta} branch
have fixed a critical bug, and the team working on the original
@file{mooIRC} branch would like to apply that change as well.

The @samp{svn merge} command is the answer.  You can think of
@samp{svn merge} as a special kind of @samp{svn diff}; only
instead of displaying unified diffs to the screen, it @emph{applies}
the differences to your working copy as if they were local changes.  

For example, suppose the bug fix happened in a commit to the
@file{mooIRC-beta} branch in revision 102.

@example
$ svn diff -r 101:102 http://foo.com/repos/mooIRC-beta

@dots{}   # diffs sent to screen

$ svn merge -r 101:102 http://foo.com/repos/mooIRC-beta mooIRC
U   mooIRC/glorb.c
U   mooIRC/src/floo.h
@end example

While the output of @samp{svn merge} looks similar to
@samp{svn update} or @samp{svn switch}, it is in fact only applying
temporary changes to the working files.  Once the differences are
applied as local changes, you can examine them as usual with
@samp{svn diff}, @samp{svn status}, or undo them with
@samp{svn revert} as usual.  If the changes are acceptable, you can
commit them.

@subsection Rolling back a change with @samp{svn merge}

Another common use for @samp{svn merge} is for rolling back a change 
that has been committed.  Say you commit some changes in revision 10, and 
later decide that they were a mistake.  You can easily revert the tree to 
the state it was in at revision 9 with an @samp{svn merge} command.

@example
$ svn commit -m "change some stuff"
Sending        bar.c
Sending        foo.c
Transmitting file data ..
Committed revision 10.
$

@dots{} # developer continues on and realizes he made a mistake

$ svn merge -r 10:9 .
U ./bar.c
U ./foo.c
$ svn commit -m "oops, reverting revision 10"
Sending        bar.c
Sending        foo.c
Transmitting file data ..
Committed revision 11.
@end example

If you aren't rolling back the changes to your current directory (say you 
want to roll back one specific file, or all the files in one specific 
subdirectory), then the syntax is slightly different, as you have to tell
@samp{svn merge} where it should merge the changes into.

@example
$ svn merge -r 10:9 baz/ baz/
U ./baz/bar.c
U ./baz/foo.c
$ svn commit -m "reverting revision 10's changes in baz/"
Sending        baz/bar.c
Sending        baz/foo.c
Transmitting file data ..
Committed revision 12.
$

@dots{} # developer continues on and later makes another mistake

$ svn merge -r 13:12 baz/foo.c baz/foo.c
U ./baz/foo.c
$ svn commit -m "reverting revision 12's change to foo.c"
Sending        baz/foo.c
Transmitting file data .
Committed revision 15.
@end example

Keep in mind that rolling back a change like this is just like any other 
@samp{svn merge} operation, so you should use @samp{svn status} and 
@samp{svn diff} to confirm that your work is in the state you want it 
to be in, and then use @samp{svn commit} to send the final version to 
the repository.

@subsection Vendor branches

Sometimes you want to manage modified third-party source code inside your 
Subversion repository, while still tracking upstream releases.  In CVS 
this would have been called a ``vendor branch''.  Subversion doesn't have 
a formal ``vendor branch'', but it is sufficiently flexible that you can 
still do much the same thing.

The general procedure goes like this.  You create a top level 
directory (we'll use @file{/vendor}) to hold the vendor branches.  Then you 
import the third party code into a subdirectory of @file{/vendor}, and copy it 
into @file{/trunk} where you make your local changes.  With each new
release of the code you are tracking you bring it into the vendor branch
and merge the changes into @file{/trunk}, resolving whatever conflicts occur
between your local changes and the upstream changes.

Let's try and make this a bit clearer with an example.

First, the initial import.

@example
$ svn mkdir http://svnhost/repos/vendor/foobar
$ svn import http://svnhost/repos/vendor/foobar ~/foobar-1.0 current
@end example

Now we've got the current version of the foobar project in 
@file{/vendor/foobar/current}.  We make another copy of it so we can
always refer to that version, and then copy it into the trunk so you can
work on it.

@example
$ svn copy http://svnhost/repos/vendor/foobar/current    \
           http://svnhost/repos/vendor/foobar/foobar-1.0 \
           -m `tagging foobar-1.0'
$ svn copy http://svnhost/repos/vendor/foobar/foobar-1.0 \
           http://svnhost/repos/trunk/foobar             \
           -m `bringing foobar-1.0 into trunk'
@end example

Now you just check out a copy of @file{/trunk/foobar} and get to work!

Later on, the developers at FooBar Widgets, Inc release a new version of 
their code, so you want to update the version of the code you're using.  
First, you check out the @file{/vendor/foobar/current} directory, then
copy the new release over that working copy, handle any renames,
additions or removals manually, and then commit.

@example
$ svn co http://svnhost/repos/vendor/foobar/current ~/current
$ cd ~/foobar-1.1
$ tar -cf - . | (cd ~/current ; tar -xf -)
$ cd ~/current
$ mv foobar.c main.c
$ svn mv main.c foobar.c
$ svn rm dead.c
$ svn add doc
$ svn add doc/*
$ svn commit -m `importing foobar 1.1 on vendor branch'
@end example

Whoa, that was complicated. Don't worry, most cases are far simpler. 

What happened? foobar 1.0 had a file called @file{main.c}.  This file
was renamed to @file{foobar.c} in 1.1.  So your working-copy had the old
@file{main.c} which @command{svn} knew about, and the new
@file{foobar.c} which @command{svn} did not know about.  You rename
@file{foobar.c} to @file{main.c} and @samp{svn mv} it back to the new
name.  This way, @command{svn} will know that @file{foobar.c} is a
descendant of @file{main.c}.  @file{dead.c} has vanished in 1.1, and
they have finally written some documentation, so you add that.

Next you copy @file{/vendor/foobar/current} to
@file{/vendor/foobar/foobar-1.1} so you can always refer back to version
1.1, like this.

@example
$ svn copy http://svnhost/repos/vendor/foobar/current    \
           http://svnhost/repos/vendor/foobar/foobar-1.1 \
           -m `tagging foobar-1.1'
@end example

Now that you have a pristine copy of foobar 1.1 in @file{/vendor}, you
just have to merge their changes into @file{/trunk} and you're done.
That looks like this.

@example
$ svn co http://svnhost/repos/trunk/foobar ~/foobar
$ cd ~/foobar
$ svn merge http://svnhost/repos/vendor/foobar/foobar-1.0 \
            http://svnhost/repos/vendor/foobar/foobar-1.1
$
@dots{} # resolve all the conflicts between their changes and your changes
$ svn commit -m `merging foobar 1.1 into trunk'
@end example

There, you're done.  You now have a copy of foobar 1.1 with all your local 
changes merged into it in your tree.

Vendor branches that have more than several deletes, additions and moves
can use the @command{svn_load_dirs.pl} script that comes with the
Subversion distribution.  This script automates the above importing
steps to make sure that mistakes are minimized.  You still need to use
the merge commands to merge the new versions of foobar into your own
local copy containing your local modifications.

This script takes care of complications where Subversion requires a
commit before renaming a file or directory twice, such as if you had a
vendor branch that renamed @file{foobar-1.1/docs/doc.ps} to
@file{foobar-1.2/documents/doc-1.2.ps}.  Here, you would rename
@file{docs} to @file{documents}, perform a commit, then rename
@file{doc.ps} to @file{doc-1.2.ps}.  You could not do the two renames
without the commit, because @file{doc.ps} was already moved once from
@file{docs/doc.ps} to @file{documents/doc.ps}.

This script always compares the directory being imported to what
currently exists in the Subversion repository and takes the necessary
steps to add, delete and rename files and directories to make the
subversion repository match the imported directory.  As such, it can be
used on an empty subversion directory for the first import or for any
following imports to upgrade a vendor branch.

For the first foobar-1.0 release located in @file{~/foobar-1.0}:

@example
$ svn_load_dirs.pl -t foobar-1.0                      \
                   http://svnhost/repos/vendor/foobar \
                   current                            \
                   ~/foobar-1.0
@end example

@command{svn_load_dirs.pl} takes three mandatory arguments.  The first
argument, @url{http://svnhost/repos/vendor/foobar}, is the URL to the
base Subversion directory to work in.  In this case, we're working in
the @file{vendor/foobar} part of the Subversion repository.  The next argument,
@file{current}, is relative to the first and is the directory where the
current import will take place, in this case
@url{http://svnhost/repos/vendor/foobar/current}.  The last argument,
@file{~/foobar-1.0}, is the directory to import.  Finally, the optional
@option{-t} command line option is also relative to
@url{http://svnhost/repos/vendor/foobar} and tells
@command{svn_load_dirs.pl} to create a tag of the imported directory in
@url{http://svnhost/repos/vendor/foobar/foobar-1.0}.

The import of foobar-1.1 would be taken care of in the same way:

@example
$ svn_load_dirs.pl -t foobar-1.1                      \
                   http://svnhost/repos/vendor/foobar \
                   current                            \
                   ~/foobar-1.1
@end example

The script looks in your current
@url{http://svnhost/repos/vendor/foobar/current} directory and sees
what changes need to take place for it to match @file{~/foobar-1.1}.
The script is kind enough to notice that there are files and directories
that exist in 1.0 and not in 1.1 and asks if you want to perform any
renames.  At this point, you can indicate that @file{main.c} was renamed to
@file{foobar.c} and then indicate that no further renames have taken place.

The script will then delete @file{dead.c} and add @file{doc} and
@file{doc/*} to the Subversion repository and finally create a tag
foobar-1.1 in @url{http://svnhost/repos/vendor/foobar/foobar-1.1}.

@subsection Removing a branch or tag with @samp{svn rm}

The @samp{svn rm} command can operate on URLs.  A file or directory
can be ``remotely'' deleted from the repository, with no working copy
present:

@example
$ svn rm http://foo.com/repos/tags/mooIRC-bad-tag -m "deleting bad tag"
Committed revision 1023.
@end example

Of course, this is still a form of immediate commit, so some kind of
log message is still required.

Enough said!


@c ------------------------------------------------------------------
@node Properties
@section Properties

Subversion allows you to attach arbitrary ``metadata'' to files and
directories.  We refer to this data as @dfn{properties}, and they can
be thought of as collections of name/value pairs (hash-tables) attached
to each item in your working copy.
  
To set or get a property on a file or directory, use the @samp{svn
propset} and @samp{svn propget} commands.  To list all properties
attached to an item, use @samp{svn proplist}.  To delete a
property, use @samp{svn propdel}.

@example
$ svn propset color green foo.c
property `color' set on 'foo.c'

$ svn propget color foo.c
green

$ svn propset height "5 feet" foo.c
property `height' set on 'foo.c'

$ svn proplist foo.c
Properties on 'foo.c':
  height
  color

$ svn proplist foo.c --verbose
Properties on 'foo.c':
  height : 5 feet
  color : green

$ svn propdel color foo.c
property `color' deleted from 'foo.c'
@end example

Properties are @emph{versioned}, just like file contents.  This means
that new properties can be merged into your working files, and can
sometimes come into conflict too.  Property values need not be text,
either.  For example, you could attach a binary property-value by
using the @option{-F} switch:

@example
$ svn propset x-face -F joeface.jpg foo.c
property `x-face' set on 'foo.c'
@end example

Subversion also provides a great convenience method for editing
existing properties: @samp{svn propedit}. When you invoke it,
Subversion will open the value of the property in question in your
favorite editor (or at least the editor that you've defined as @samp{$EDITOR}
in your shell), and you can edit the value just as you would edit any
text file. This is exceptionally convenient for properties that are a
newline-separated array of values. (See below.)

Property changes are still considered ``local modifications'', and
aren't permanent until you commit.  Like textual changes, property
changes can be seen by @samp{svn diff}, @samp{svn status}, and
reverted altogether with @samp{svn revert}:

@example
$ svn diff
Property changes on: foo.c
___________________________________________________________________
Name: color
   + green

$ svn status
_M   foo.c
@end example

Notice that a 2nd column has appeared in the status output; the
leading underscore indicates that you've not made any textual changes,
but the @samp{M} means you've modified the properties.  @samp{svn
status} tries to hide the 2nd ``property'' column when an item has no
properties at all; this was a design choice, to ease new users into
the concept.  When properties are created, edited, or updated on an
item, that 2nd column appears forever after.

Also: don't worry about the non-standard way that Subversion currently
displays property differences.  You can still run @samp{svn diff}
and redirect the output to create a usable patch file.  The
@command{patch} program will ignore property patches; as a rule, it
ignores any noise it can't understand.  (In future versions of
Subversion, though, we may start using a new patch format that
describes property changes and file copies/renames.)

@subsection Special properties

Subversion has no particular policy regarding properties; they can be
used for any purpose.  The only restriction is that Subversion has
reserved the @samp{svn:} name prefix for itself.  A number of special
``magic'' properties begin with this prefix.  We'll cover these
features here.

@subsubsection @samp{svn:executable}

This is a file-only property, and can be set to any value.  Its mere
existence causes a file's permissions to be executable.

@subsubsection @samp{svn:mime-type}

At the present time, Subversion examines the @samp{svn:mime-type} property
to decide if a file is text or binary.  If the file has no
@samp{svn:mime-type} property, or if the property's value matches
@samp{text/*}, then Subversion assumes it is a text file.  If the file
has the @samp{svn:mime-type} property set to anything other than
@samp{text/*}, it assumes the file is binary.

If Subversion believes that the file is binary, it will not attempt to
perform contextual merges during updates.  Instead, Subversion creates
two files side-by-side in your working copy; the one containing your
local modifications is renamed with an @file{.orig} extension.

Subversion also helps users by running a binary-detection algorithm in
the @samp{svn import} and @samp{svn add} subcommands.  These subcommands try to
make a good guess at a file's binary-ness, and then (possibly) set a
@samp{svn:mime-type} property of @samp{application/octet-stream} on the file
being added.  (If Subversion guesses wrong, you can always remove or
hand-edit the property.)

Finally, if the @samp{svn:mime-type} property is set, then mod_dav_svn will
use it to fill in the @samp{Content-type:} header when responding to an
http GET request.  This makes files display more nicely when perusing
a repository with a web browser.


@subsubsection @samp{svn:ignore}

If you attach this property to a directory, it causes certain file
patterns within the directory to be ignored by @samp{svn status}.
For example, suppose I don't want to see object files or backup files
in my status listing:

@example
$ svn status
M  ./foo.c
?  ./foo.o
?  ./foo.c~
@end example

Using @samp{svn propedit}, I would set the value of
@samp{svn:ignore} to a newline-delimited list of patterns:

@example
$ svn propget svn:ignore .
*.o
*~
@end example


@subsubsection @samp{svn:keywords}

Subversion has the ability to substitute useful strings into special
``keywords'' within text files.  For example, if I placed this text
into a file:

@example
Here is the latest report from the front lines.
$LastChangedDate$
Cumulus clouds are appearing more frequently as summer approaches.
@end example

Subversion is able substitute the @samp{$LastChangedDate$} string with
the actual date in which this file last changed.  The keyword string is
not removed in the replacement, just the specific information is placed
after the keyword string:

@example
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
Cumulus clouds are appearing more frequently as summer approaches.
@end example

All in all, there are four special keywords that Subversion knows how
to substitute:

@table @b
@item LastChangedDate
The last time this file changed.  Can also be abbreviated as @samp{Date}.
The keyword substitution of @samp{$LastChangedDate$} will look something
like
@samp{$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $}.

@item LastChangedRevision
The last revision in which this file changed.  Can be abbreviated as
@samp{Rev}.  The keyword substitution of @samp{$LastChangedRevision} will
look something like @samp{$LastChangedRevision: 144 $}.

@item LastChangedBy
The last user to change this file.  Can be abbreviated as @samp{Author}.  The
keyword substitution of @samp{$LastChangedBy$} will look something like
@samp{$LastChangedBy: joe $}.

@item HeadURL
A full URL to the latest version of the file in the repository.  Can be
abbreviated as @samp{URL}.  The keyword substitution of @samp{$HeadURL$} will
look something like
@samp{$HeadURL: http://svn.collab.net/repos/trunk/README $}.
@end table

To activate a keyword, or set of keywords, you merely need to set the
@samp{svn:keywords} property to a list of keywords you want replaced.
Keywords not listed in @samp{svn:keywords} will not be replaced.

@example
$ svn propset svn:keywords "Date Author" foo.c
property `svn:keywords' set on 'foo.c'
@end example

And when you commit this property change, you'll discover that all
occurrences of @samp{$Date$}, @samp{$LastChangedDate$},
@samp{$Author$}, and @samp{$LastChangedBy$} will have substituted
values within @file{foo.c}.


@subsubsection @samp{svn:eol-style}

By default, Subversion doesn't pay any attention to line endings.  If
a text file has either LF, CR, or CRLF endings, then those are the
line endings that will exist on the file in both the repository and
working copy.

But if developers are working on different platforms, line endings can
sometimes become troublesome.  For example, if a Win32 developer and
Unix developer took turns modifying a file, its line endings might
flip-flop back and forth from revision to revision in the repository.
This makes examining or merging differences very difficult, as
@emph{every} line appears to be changed in each version of the file.

The solution here is to set the @samp{svn:eol-style} property to
``native''.  This makes the file always appear with the ``native''
line endings of each developer's operating system.  Note, however,
that the file will always contain LF endings in the repository.  This
prevents the line-ending ``churn'' from revision to revision.

Alternately, you can force files to always retain a fixed, specific
line ending: set a file's @samp{svn:eol-style} property to one of
@samp{LF}, @samp{CR} or @samp{CRLF}.  A Win32 @file{.dsp} file, for
example, which is used by Microsoft development tools, should always
have CRLF endings.


@subsubsection @samp{svn:externals}

@xref{Modules}.


@c ------------------------------------------------------------------
@node Modules
@section Modules

Sometimes it's useful to construct a working copy that is made out of
a number of different checkouts.  For example, you may want different
sub-directories to come from different locations in a repository.

On the one hand, you could begin by checking out a working copy, and
then run @samp{svn switch} on various subdirectories.  But this is
a bit of work.  Wouldn't it be nice to define -- in a single place --
exactly how you want the final working copy to be?

This is known as a @dfn{module}.  You can define a module by attaching
another special ``magic'' @samp{svn:} property to a directory: the
@samp{svn:externals} property.

The value of this property is a list of subdirectories and
their corresponding URLs:

@example
$ svn propget svn:externals projectdir
subdir1/foo       http://url.for.external.source/foo
subdir1/bar       http://blah.blah.blah/repositories/theirproj
subdir1/bar/baz   http://blorg.blorg.blorg/basement/code
@end example

Assuming that this property is attached to the directory
@file{projectdir}, then when we check it out, we'll get everything
else defined by the property.

@example
$ svn checkout http://foo.com/repos/projectdir
A  projectdir/blah.c
A  projectdir/gloo.c
A  projectdir/trout.h
Checked out revision 128.

Fetching external item into projectdir/subdir1/foo
A  projectdir/subdir1/foo/rho.txt
A  projectdir/subdir1/foo/pi.txt
A  projectdir/subdir1/foo/tau.doc
Checked out revision 128.
@dots{}
@end example

By tweaking the value of the @samp{svn:externals} property, the
definition of the module can change over time, and subsequent calls to
@samp{svn update} will update working copies appropriately.

@c ### Karl, anything else to add here?  I'm suspicious that this
@c feature doesn't work as I expect just yet; when I run @samp{svn up} at
@c the top of the wc, nothing happens in the external directory at
@c all, because (I guess) it's not linked to the parent. 


@c ------------------------------------------------------------------
@node Revisions
@section Revisions

As you may have noticed, many Subversion commands are able to process
the @option{-r} switch.  Here we describe some special ways to specify
revisions.

The Subversion client understands a number of @dfn{revision keywords}.
These keywords can be used instead of integer arguments to the
@option{-r} switch, and are resolved into specific revision numbers:

@table @b
@item HEAD
The latest revision in the repository.
@item BASE
The ``pristine'' revision of an item in a working copy.
@item COMMITTED
The last revision in which an item changed.
@item PREV
The revision just @emph{before} the last revision in which an item
changed.  (Technically, COMMITTED - 1).
@end table

Here are some examples of revision keywords in action:

@example
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working file (with local mods) to the latest version
# in the repository.

$ svn diff -r BASE:HEAD foo.c
# compares your "pristine" foo.c (no local mods) with the latest version
# in the repository

$ svn log -r BASE:HEAD
# shows all commit logs since you last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c.
# (foo.c's working revision is decreased.)
@end example





@c ------------------------------------------------------------------
@node Other Commands
@section Other Commands


@subheading @samp{svn cleanup}

When Subversion modifies your working copy (or any information within
@file{.svn}), it tries to do so as safely as possible.  Before
changing anything, it writes its intentions to a logfile, then
executes the commands in the logfile.  It's similar in design to a
journaled filesystem; if the user hits Control-C or if the machine
crashes, the logfiles are left lying around.  By re-executing the
logfiles, the work can complete, and your working copy can get itself
back into a consistent state.

And this is exactly what @samp{svn cleanup} does: it searches your
working copy and re-runs any leftover logs, removing locks in the
process.  Use this command if Subversion ever tells you that some part
of your working copy is ``locked''.  Also, @samp{svn status} will
display an @samp{L} next to locked items:

@example
$ svn st
  L    ./somedir
M      ./somedir/foo.c 

$ svn cleanup
$ svn st
M      ./somedir/foo.c
@end example

@subheading @samp{svn info}

In general, we try to discourage users from directly reading the
@file{.svn/entries} file used to track items.  Instead, curiosity can
be quelled by using the @samp{svn info} to display most of the
tracked information:

@example
$ svn info client.texi
Path: client.texi
Name: client.texi
Url: http://svn.collab.net/repos/svn/trunk/doc/handbook/client.texi
Revision: 2548
Node Kind: file
Schedule: normal
Last Changed Author: fitz
Last Changed Rev: 2545
Last Changed Date: 2002-07-15 23:03:54 -0500 (Mon, 15 Jul 2002)
Text Last Updated: 2002-07-16 08:48:04 -0500 (Tue, 16 Jul 2002)
Properties Last Updated: 2002-07-16 08:48:03 -0500 (Tue, 16 Jul 2002)
Checksum: 8sfaU+5dqyOgkhuSdyxGrQ==
@end example


@subheading @samp{svn import}

The import command is a quick way to move an unversioned tree of files
into a repository.

There are two ways to use this command:

@example
$ svnadmin create /usr/local/svn/newrepos
$ svn import file:///usr/local/svn/newrepos mytree
Adding  mytree/foo.c
Adding  mytree/bar.c
Adding  mytree/subdir
Adding  mytree/subdir/quux.h
Transmitting file data....
Committed revision 1.
@end example

The above example places the contents of directory @file{mytree}
directly into the root of the repository:

@example
/foo.c
/bar.c
/subdir
/subdir/quux.h
@end example

If you give @samp{svn import} a third argument, it will use the
argument as the name of a new subdirectory to create within the URL.

@example
$ svnadmin create /usr/local/svn/newrepos
$ svn import file:///usr/local/svn/newrepos mytree fooproject
Adding  mytree/foo.c
Adding  mytree/bar.c
Adding  mytree/subdir
Adding  mytree/subdir/quux.h
Transmitting file data....
Committed revision 1.
@end example

The repository would now look like

@example
/fooproject/foo.c
/fooproject/bar.c
/fooproject/subdir
/fooproject/subdir/quux.h
@end example


@subheading @samp{svn export}

The export command is a quick way to create an unversioned tree of
files from a repository directory.

@example
$ svn export file:///usr/local/svn/newrepos/fooproject
A  fooproject/foo.c
A  fooproject/bar.c
A  fooproject/subdir
A  fooproject/subdir/quux.h
Checked out revision 3.
@end example

The resulting directory will not contain any @file{.svn}
administrative areas, and all property metadata will be lost.  (Hint:
don't use this tecnique for backing up; it's probably better for
rolling source distributions.)


@subheading @samp{svn ls}

The ls command lets you find what files are in a repository directory.

@example
$ svn ls http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
@end example

If you want a more detailed listing, pass the @option{-v} flag and you 
will get output like this.

@example
$ svn ls -v http://svn.collab.net/repos/svn
_    2755   kfogel     1331 Jul 28 02:07 README
_    2773  sussman        0 Jul 29 15:07 branches/
_    2769 cmpilato        0 Jul 29 12:07 clients/
_    2698   rooneg        0 Jul 24 18:07 tags/
_    2785    brane        0 Jul 29 19:07 trunk/
@end example

The columns tell you if there file has any properties (``P'' if it does, 
``_'' if it doesn't), the revision it was last updated at, the user who 
last updated it, it's size, the date it was last updated, and the filename.
 
@subheading @samp{svn mkdir}

This is another convenience command, and it has two uses.

First, it can be used to simultaneously create a new working copy
directory and schedule it for addition:

@example
$ svn mkdir new-dir
A     new-dir
@end example

Or, it can be used to instantly create a directory in a repository (no
working copy needed):

@example
$ svn mkdir file:///usr/local/svn/newrepos/branches -m "made new dir"
Committed revision 1123.
@end example

Again, this is a form of immediate commit, so some sort of log message
is required.


@c ------------------------------------------------------------------
@node Run-time Configuration
@section Run-time Configuration

When you first run the @command{svn} command-line client, it creates a
per-user @dfn{configuration area}.  On Unix-like systems, a
@file{.subversion/} directory is created in the user's home
directory.  On Win32 systems, a @file{Subversion} folder is created
wherever it's appropriate to do so (typically somewhere within
@file{Documents and Settings\username}, although it depends on the
system.)

@subsection Proxies

At the time of writing, the configuration area only contains one item:
a @file{proxies} file.  By setting values in this file, your Subversion
client can operate through an http proxy.  (Read the file itself for
details; it should be self-documenting.)

@subsection Config

Soon -- very soon -- a @file{config} file will exist in this area for
defining general user preferences.  For example, the preferred
@samp{$EDITOR} to use, options to pass through to @samp{svn diff},
preferences for date/time formats, and so on.  See issue #668 for
details
(@uref{http://subversion.tigris.org/issues/show_bug.cgi?id=668}).

@subsection Multiple config areas

On Unix, an administrator can create``global'' Subversion preferences
by creating and populating an @file{/etc/subversion/} area.  The
per-user @file{~/.subversion/} configuration will still override these
defaults, however.

On Win32, an administrator has the option of creating three other
locations: a global @file{Subversion} folder in the ``All Users''
area, a collection of global registry settings, or a collection of
per-user registry settings.  The registry settings are set in:

@example
HKCU\Software\Tigris.org\Subversion\Proxies
HKCU\Software\Tigris.org\Subversion\Config
etc.
@end example

To clarify, here is the order Subversion searches for run-time
settings on Win32.  Each subsequent location overrides the previous
one:

@itemize @bullet
@item global registry
@item global @file{Subversion} folder
@item user registry
@item user @file{Subversion} folder
@end itemize
