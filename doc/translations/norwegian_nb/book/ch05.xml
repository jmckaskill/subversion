<chapter id="svn-ch-5">
<!-- @ENGLISH {{{
<title>Repository Administration</title>
@ENGLISH }}} -->
<title>Depotadministrasjon</title>

  <simplesect>

    <!-- @ENGLISH {{{
    <para>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems are safely resolved.</para>
    @ENGLISH }}} -->
    <para>Subversiondepotet er den sentrale lagringsplassen for 
      versjonerte data for ethvert antall prosjekter.
      Som s&#229;dan blir det en opplagt kandidat for all kj&#230;rlighet og 
      oppmerksomhet en administrator kan tilby.
      Selv om depotet vanligvis er et element som krever lite 
      vedlikehold, er det viktig &#229; forst&#229; hvordan du kan konfigurere og 
      passe p&#229; det s&#229; potensielle problemer blir unng&#229;tt, og aktuelle 
      problemer l&#248;st p&#229; en trygg m&#229;te.</para>

    <!-- @ENGLISH {{{
    <para>In this chapter, we'll discuss how to create and configure
      a Subversion repository.  We'll also talk about repository
      maintenance, including the use of the <command>svnlook</command>
      and <command>svnadmin</command> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</para>
    @ENGLISH }}} -->
    <para>I dette kapittelet vil vi diskutere hvordan du kan opprette og 
      konfigurere et Subversiondepot.
      Vi vil ogs&#229; snakke om depotvedlikehold, inkludert bruken av 
      verkt&#248;yene <command>svnlook</command> og 
      <command>svnadmin</command> (som f&#248;lger med Subversion).
      Vi vil adressere vanlige sp&#248;rsm&#229;l og feilgrep, og komme med noen 
      forslag til hvordan du kan legge opp dataene i depotet.</para>

    <!-- @ENGLISH {{{
    <para>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <footnote>
        <para>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</para>
      </footnote>
      you should definitely pay attention to this chapter.</para>
    @ENGLISH }}} -->
    <para>Hvis du planlegger &#229; aksessere et Subversiondepot bare i 
      rollen som en bruker som har data under versjonskontroll (det vil 
      si via en Subversionklient), kan du hoppe over hele dette 
      kapitlet.
      Hvis du derimot er, eller vil bli, en administrator for et 
      Subversiondepot,<footnote>
      <para>Dette kan h&#248;res <!-- &#164; -->r&#229;flott ut, men vi snakker bare om 
        enhver som er interessert i mystikken <!-- &#164; realm -->omkring 
        arbeidskopien hvor alles data ligger.</para></footnote>
      b&#248;r du s&#229; absolutt f&#248;lge med i dette kapittelet.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY BASICS                               *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <!-- @ENGLISH {{{
    <title>Repository Basics</title>
    @ENGLISH }}} -->
    <title>Det grunnleggende ved et depot</title>

    <!-- @ENGLISH {{{
    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a logical perspective&mdash;dealing with how data is represented
      inside the repository&mdash;and from a physical nuts-and-bolts
      perspective&mdash;how a repository looks and acts with respect
      to non-Subversion tools.  The following section covers some of
      these basic concepts at a very high level.</para>
    @ENGLISH }}} -->
    <para>F&#248;r vi hopper inn i det mer generelle innen emnet 
      depotadministrasjon, la oss definere videre hva et depot er.
      Hvordan ser det ut?
      Hvordan f&#248;les det?
      Vil det ha teen sin varm eller med is, s&#248;t, og med sitron?
      Som en administrator, blir det forventet at du m&#229; forst&#229; 
      sammensetningen i et depot b&#229;de fra et logisk perspektiv &#8212; det &#229; 
      styre med hvordan data er representert i depotet &#8212; og fra et 
      fysisk skrue-og-mutter-perspektiv &#8212; hvordan et depot ser ut og 
      oppf&#248;rer seg i sammenheng med verkt&#248;y <!-- &#164; -->som ikke h&#248;rer med 
      til Subversion-pakken.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <!-- @ENGLISH {{{
      <title>Understanding Transactions and Revisions</title>
      @ENGLISH }}} -->
      <title>Forst&#229;else av transaksjoner og revisjoner</title>
        
      <!-- @ENGLISH {{{
      <para>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</para>
      @ENGLISH }}} -->
      <para>Konseptmessig sagt, er et Subversiondepot en sekvens av 
        tr&#230;r.
        Hvert tre er et &#248;yeblikksbilde av hvordan filene og katalogene 
        s&#229; ut p&#229; et spesielt tidspunkt.
        Disse &#248;yeblikksbildene er opprettet som et resultat av 
        klientoperasjoner og blir kalt revisjoner.</para>

      <!-- @ENGLISH {{{
      <para>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</para>
      @ENGLISH }}} -->
      <para>Hver revisjon begynner livet som et transaksjonstre.
        N&#229;r du gj&#248;r en innlegging, bygger en klient en 
        Subversiontransaksjon som avspeiler deres lokale forandringer 
        (pluss eventuelle forandringer som er blitt lagt inn i tillegg 
        til depotet siden begynnelsen av innleggingsprosessen), og 
        instruerer deretter depotet om &#229; lagre dette treet som det neste 
        &#248;yeblikksbildet i sekvensen.
        Hvis innleggingen lykkes, blir transaksjonen <!-- &#164; effectively 
        promoted -->innlemmet i et nytt revisjonstre, og blir tildelt et 
        nytt revisjonsnummer.
        Hvis innleggingen av en eller annen grunn ikke lykkes, blir 
        transaksjonen &#248;delagt og klienten informeres om feilen.</para>
            
      <!-- @ENGLISH {{{
      <para>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or <quote>youngest</quote> tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</para>
      @ENGLISH }}} -->
      <para>Oppdateringer fungerer p&#229; en lignende m&#229;te.
        Klienten bygger et midlertidig transaksjonstre som avspeiler 
        tilstanden til arbeidskopien.
        Depotet sammenligner deretter dette transaksjonstreet med 
        revisjonstreet i den forespurte revisjonen (vanligvis det 
        nyeste, eller <quote>yngste</quote> treet), og sender tilbake 
        informasjon som forteller klienten om hvilke forandringer som er 
        n&#248;dvendig for &#229; forandre deres arbeidskopi til et replikat av 
        det aktuelle revisjonstreet.
        Etter at oppdateringen er fullf&#248;rt, blir den midlertidige 
        transaksjonen slettet.</para>
          
      <!-- @ENGLISH {{{
      <para>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</para>
      @ENGLISH }}} -->
      <para>Bruken av transaksjonstr&#230;r er den eneste m&#229;ten &#229; gj&#248;re 
        permanente forandringer til et depots versjonskontrollerte 
        filsystem.
        Det er imidlertid viktig &#229; forst&#229; at livl&#248;pet til en transaksjon 
        er komplett fleksible.
        I tilfellet med oppdateringer er transaksjoner midlertidige tr&#230;r 
        som blir &#248;yeblikkelig &#248;delagt.
        I tilfellet med innlegginger, blir transaksjoner transformert 
        inn i permanente revisjoner (eller fjernet hvis innleggingen 
        feiler).
        I tilfelle en generell feil eller programfeil oppst&#229;r, er det 
        mulig at en transaksjon kan bli liggende igjen i depotet (uten &#229; 
        p&#229;virke noe som helst, men tar opp diskplass).</para>

     <!-- @ENGLISH {{{
      <para>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</para>
     @ENGLISH }}} -->
      <para>I teorien vil kanskje <!-- &#164; -->hele 
        arbeidsflytapplikasjoner en gang gi mer n&#248;yaktig kontroll med 
        levetiden til en transaksjon.
        Det er mulig &#229; tenke seg et system som ved hver transaksjon 
        beregnet p&#229; &#229; bli en revisjon blir lagt <!-- &#164; -->p&#229; vent etter 
        at klienten er <!-- &#164; -->ferdig med &#229; beskrive sine forandringer 
        til depotet.
        Dette ville muliggj&#248;re at hver ny innlegging kan bli sett over 
        av noen andre, kanskje en manager eller <!-- &#164; -->ledende 
        utvikler, som kan velge &#229; forfremme transaksjonen til en 
        revisjon eller avbryte den.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <!-- @ENGLISH {{{
      <title>Unversioned Properties</title>
      @ENGLISH }}} -->
      <title>Uversjonerte egenskaper</title>

      <!-- @ENGLISH {{{
      <para>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are generally used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</para>
      @ENGLISH }}} -->
      <para>Transaksjoner og revisjoner i Subversiondepotet kan ha 
        vedlagte egenskaper.
        Disse egenskapene er generiske <!-- &#164; 
        --><quote>n&#248;kkel-til-verdi</quote>-mappinger, og blir vanligvis 
        brukt til &#229; lagre informasjon om treet som de er vedlagt.
        Navnene og verdiene til disse egenskapene er lagret i depotets 
        filsystem, sammen med resten av dataene for treet.</para>

      <!-- @ENGLISH {{{
      <para>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree&mdash;the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <literal>svn:date</literal>&mdash;a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<literal>svn:author</literal>) and a
        property to store the log message attached to that revision
        (<literal>svn:log</literal>).</para>
      @ENGLISH }}} -->
      <para>Revisjons- og transaksjonsegenskaper er nyttige for &#229; 
        assosiere informasjon sammen med et tre som ikke er spesifikt 
        relatert til filene og katalogene i dette treet &#8213; den typen 
        informasjon som ikke er behandlet av arbeidskopier for klienten.
        For eksempel, n&#229;r en ny innleggingstransaksjon er opprettet i 
        depotet, legger Subversion en egenskap til denne transaksjonen 
        kalt <literal>svn:date</literal> &#8212; et tidsmerke som 
        representerer tidspunktet transaksjonen ble opprettet.
        N&#229;r innleggingsprosessen er fullf&#248;rt, og transaksjonen blir 
        forfremmet til en permanent revisjon, har treet ogs&#229; f&#229;tt en 
        egenskap for &#229; lagre brukernavnet til revisjonens forafatter 
        (<literal>svn:author</literal>) og en egenskap for &#229; lagre 
        loggmeldingen som h&#248;rer til denne revisjonen 
        <literal>svn:log</literal>.</para>

      <!-- @ENGLISH {{{
      <para>Revision and transaction properties are
        <firstterm>unversioned properties</firstterm>&mdash;as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <literal>svn:log</literal> property with a new, corrected log
        message.</para>
      @ENGLISH }}} -->
      <para>Revisjons- og transaksjonsegenskaper er 
        <firstterm>uversjonerte egenskaper</firstterm> &#8212; n&#229;r de blir 
        modifisert blir den foreg&#229;ende verdien permanent forkastet.
        Selv om revisjonstr&#230;r er uforanderlige, gjelder ikke dette 
        egenskapene som er vedlagt disse tr&#230;rne.
        Du kan legge til, fjerne, og modifisere revisjonsegenskaper til 
        enhver tid i fremtide.
        Hvis du legger inn en ny revisjon og senere finner ut at du la 
        inn feil informasjon eller skrivefeil i loggmeldingen, kan du 
        enkelt forandre verdien i <literal>svn:log</literal>-egenskapen 
        med en ny, rettet loggmelding.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.3">
      <!-- @ENGLISH {{{
      <title>Repository Data-Stores</title>
      @ENGLISH }}} -->
      <title>Datalagring i depotet</title>

      <!-- @ENGLISH {{{
      <para>As of Subversion 1.1, there are two options for storing
        data in a Subversion repository.  One type of repository
        stores everything in a Berkeley DB database; the other kind
        stores data in ordinary flat files, using a custom
        format.  Because Subversion developers often refer to a
        repository as <quote>The [Versioned] Filesystem</quote>, they have
        adopted the habit of referring to the latter type of repository as
        <firstterm>FSFS</firstterm>: that is, it's a versioned
        filesystem implementation that uses the native OS filesystem
        to store data.</para>
      @ENGLISH }}} -->
      <para>I Subversion 1.1 er det to valg for &#229; lagre data i et 
        Subversiondepot.
        En depottype lagrer alt i en Berkeley DB-database; den andre 
        typen lagrer data som ordin&#230;re <quote>flate filer</quote> i et 
        tilpasset format.
        Fordi Subversionutvilkere ofte referer til et depot som 
        <quote>det [versjonerte] filsystemet</quote>, har de lagt seg 
        til vanen med &#229; refere til den sistnevnte typen depot som 
        <firstterm>FSFS</firstterm>:
        Det vil si, det er en versjonert filsystemimplementasjon som 
        bruker det vanlige filsystemet til operativsystemet for &#229; lagre 
        data.</para>

      <!-- @ENGLISH {{{
      <para>When a repository is created, an administrator must decide
        whether it will use Berkeley DB or FSFS.  There are advantages
        and disadvantages to each, which we'll describe in a bit.
        Neither back-end is more <quote>official</quote> than another,
        and programs which access the repository are insulated from
        this implementation detail.  Programs have no idea how a
        repository is storing data; they only see revision and
        transaction trees through the repository API.</para>
      @ENGLISH }}} -->
      <para>N&#229;r et depot er opprettet, m&#229; administratoren bestemme om 
        Berkeley DB eller FSFS skal brukes.
        Det er fordeler og ulemper med begge to, som vi vil g&#229; gjennom 
        ganske snart.
        Ingen av de bakenforliggende depotene er mer 
        <quote>offisielt</quote> enn det andre, og programmer som 
        aksesserer depotet er isolert fra denne implementasjonsdetaljen.
        Programmer har ingen formening om hvordan depotet lagrer data; 
        de ser bare revisjons- og transaksjonstr&#230;r gjennom 
        depotgrensesnittet.</para>

      <!-- @ENGLISH {{{
      <para>Here is a table that gives a comparative overview of
        Berkeley DB and FSFS repositories.  The next sections go into
        detail.</para>
      @ENGLISH }}} -->
      <para>Her er en tabell som gir en oversikt over forskjellene 
        mellom depoter av typen Berkeley DB og FSFS.
        De neste seksjonene g&#229;r inn i detalj.</para>

      <table id="svn-ch-5-table-1">
        <!-- @ENGLISH {{{
        <title>Repository Data-Store Comparison</title>
        @ENGLISH }}} -->
        <title>Sammenligning av datalagring i <!-- &#164; &#171;depot&#187; i flertall. 
          Vil gjerne skrive &#171;depoter&#187;, men er det noe som heter det? 
          -->depot</title>
        <tgroup cols="3">
          <thead>
            <row>
              <!-- @ENGLISH {{{
              <entry>Feature</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
              @ENGLISH }}} -->
              <entry>Funksjonalitet</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <!-- @ENGLISH {{{
              <entry>Sensitivity to interruptions</entry>
              @ENGLISH }}} -->
              <entry>F&#248;lsom for avbrytelser</entry>
              
              <!-- @ENGLISH {{{
              <entry>very;  crashes and permission problems can leave the
                database <quote>wedged</quote>, requiring journaled
                recovery procedures.</entry>
              @ENGLISH }}} -->
              <entry>veldig;
              krasj og problemer med rettigheter kan etterlate databasen 
              i en <quote>fastkilt</quote> (Engelsk: 
              <foreignphrase>wedged</foreignphrase>) tilstand som krever 
              <!-- &#164; -->prosedyrer for journalgjenoppretting.</entry>
              
              <!-- @ENGLISH {{{
              <entry>quite insensitive.</entry>
              @ENGLISH }}} -->
              <entry>ganske uf&#248;lsom.</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Usable from a read-only mount</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Kan brukes fra et ikke-skrivbart medium</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Platform-independent storage</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Plattformuavhengig lagring</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Usable over network filesystems</entry>
              
              <entry>no</entry>
              
              <entry>yes</entry>
              @ENGLISH }}} -->
              <entry>Brukbar over nettverksfilsystem</entry>

              <entry>nei</entry>

              <entry>ja</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Repository size</entry>
              
              <entry>slightly larger</entry>
              
              <entry>slightly smaller</entry>
              @ENGLISH }}} -->
              <entry>Depotst&#248;rrelse</entry>

              <entry>litt st&#248;rre</entry>

              <entry>litt mindre</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Scalability: number of revision trees</entry>
              
              <entry>database;  no problems</entry>
              
              <entry>some older native filesystems don't scale well with
                thousands of entries in a single directory.</entry>
              @ENGLISH }}} -->
              <entry>Skalerbarhet:
                Antall revisjonstr&#230;r</entry>

              <entry>database; ingen problemer</entry>

              <entry>ytelsen p&#229; noen eldre filsystemer blir d&#229;rligere 
                med tusenvis av elementer i en katalog.</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Scalability: directories with many files</entry>
              
              <entry>slower</entry>
              
              <entry>faster</entry>
              @ENGLISH }}} -->
              <entry>Skalerbarhet:
                Kataloger med mange filer</entry>

              <entry>langsommere</entry>

              <entry>raskere</entry>
            </row>
                        
            <row>
              <!-- @ENGLISH {{{
              <entry>Speed:  checking out latest code</entry>
              
              <entry>faster</entry>
              
              <entry>slower</entry>
              @ENGLISH }}} -->
              <entry>Hastighet:
                Uthenting av nyeste kode</entry>

              <entry>raskere</entry>

              <entry>langsommere</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Speed:  large commits</entry>
              
              <entry>slower, but work is spread throughout commit</entry>
              
              <entry>faster, but finalization delay may cause client
                timeouts</entry>
              @ENGLISH }}} -->
              <entry>Hastighet:
                Store innlegginger</entry>

              <entry>langsommere, men arbeidet blir spredt ut over 
                innleggingen</entry>

              <entry>raskere, men forsinkelse i avslutningen kan 
                for&#229;rsake tidsavbrudd for klienten.</entry>
            </row>
            
            <row>
              <!-- @ENGLISH {{{
              <entry>Group permissions handling</entry>
              
              <entry>sensitive to user umask problems;  best if accessed
                by only one user.</entry>
              
              <entry>works around umask problems</entry>
              @ENGLISH }}} -->
              <entry>Behandling av grupperettigheter</entry>

              <entry>f&#248;lsom for problemer med umask; det beste er om den 
                blir aksessert av bare en bruker.</entry>

              <entry>jobber seg rundt problemer med umask</entry>
            </row>

            <row>
              <!-- @ENGLISH {{{
              <entry>Code maturity</entry>
              
              <entry>in use since 2001</entry>
              
              <entry>in use since 2004</entry>
              @ENGLISH }}} -->
              <entry><!-- &#164; -->Kodemodenhet</entry>

              <entry>i bruk siden 2001</entry>

              <entry>i bruk siden 2004</entry>
            </row>

          </tbody>
        </tgroup>      
      </table>
      
    <!-- ***************************************************************** -->
      <sect3 id="svn-ch-5-sect-1.3.1">
        <title>Berkeley DB</title>
        
        <!-- @ENGLISH {{{
        <para>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open-source license,
          transaction support, reliability, performance, API
          simplicity, thread-safety, support for cursors, and so
          on.</para>
        @ENGLISH }}} -->
        <para>I den innledende designfasen av Subversion bestemte 
          utviklerne seg for &#229; bruke Berkeley DB av diverse grunner, 
          blant annet dens &#229;pne lisens, transaksjonsst&#248;tte, stabilitet, 
          effektivitet, enkelt grensesnitt, tr&#229;dsikkerhet, st&#248;tte for 
          &#164;cursors og s&#229; videre.</para>

        <!-- @ENGLISH {{{
        <para>Berkeley DB provides real transaction
          support&mdash;perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database&mdash;not a database that
          is constantly changing at the hand of some other
          process&mdash;and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as if
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</para>
        @ENGLISH }}} -->
        <para>Berkeley DB tilbyr reell st&#248;tte for transaksjoner &#8212; 
          kanskje dens kraftigste funksjonalitet.
          Flere prosesser som aksesserer Subversiondepotene dine trenger 
          ikke &#229; tenke p&#229; faren ved &#229; rote til hverandres data.
          Isolasjonen som transaksjonssystemet tilbyr er slik at for 
          enhver operasjon ser Subversions depotkode et statisk bilde av 
          en database &#8212; ikke en database som konstant forandres av en 
          annen prosess &#8212; og kan foreta avgj&#248;relser basert p&#229; dette 
          bildet.
          Hvis avgj&#248;relsen kommer i konflikt med det en annen prosess 
          gj&#248;r, blir hele operasjonen rullet tilbake som om den aldri 
          skjedde, og Subversion pr&#248;ver <!-- &#164; -->forsiktig operasjonen  
          mot et nytt, oppdatert (og fortsatt statisk) bilde av 
          databasen.</para>

        <!-- @ENGLISH {{{
        <para>Another great feature of Berkeley DB is <firstterm>hot
          backups</firstterm>&mdash;the ability to backup the database
          environment without taking it <quote>offline</quote>.  We'll
          discuss how to backup your repository in <xref
          linkend="svn-ch-5-sect-3.6"/>, but the benefits of being
          able to make fully functional copies of your repositories
          without any downtime should be obvious.</para>
        @ENGLISH }}} -->
        <para>En annen fin funksjonalitet med Berkeley DB er 
          <firstterm>varme backuper</firstterm> (<foreignphrase>hot 
          backups</foreignphrase>) &#8212; muligeten til &#229; ta sikkerhetskopi 
          av databasen uten &#229; ta den ned.
          Vi vil diskutere hvordan du tar backup av depotet i <xref 
          linkend="svn-ch-5-sect-3.6"/>, men fordelene med &#229; kunne ta 
          fullstendige fungerende kopier av depotene dine uten nedetid 
          er innlysende.</para>

        <!-- @ENGLISH {{{
        <para>Berkeley DB is also a very reliable database system.
          Subversion uses Berkeley DB's logging facilities, which
          means that the database first writes to on-disk log files a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if anything goes wrong, the database system can back up to
          a previous <firstterm>checkpoint</firstterm>&mdash;a
          location in the log files known not to be corrupt&mdash;and
          replay transactions until the data is restored to a usable
          state.  See <xref linkend="svn-ch-5-sect-3.3"/> for more
          about Berkeley DB log files.</para>
        @ENGLISH }}} -->
        <para>Berkeley DB er ogs&#229; et veldig sikkert databasesystem.
          Subversion bruker Berkeley DBs loggefasiliteter, som betyr at 
          databasen f&#248;rst skriver en beskrivelse til loggfiler p&#229; disken 
          om hva den er i ferd med &#229; gj&#248;re, og foretar deretter selve 
          modifiseringen.
          Dette er for &#229; forsikre om at i tilfelle noe g&#229;r galt, kan 
          databasesystemet hente tilbake et tidligere 
          <firstterm>sjekkpunkt</firstterm> &#8212; en posisjon i loggfilene 
          som den vet ikke er &#248;delagt &#8212; <xref 
          linkend="svn-ch-5-sect-3.3"/></para>

        <!-- @ENGLISH {{{
        <para>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture independent,
          there are other aspects of the environment that are not.
          Secondly, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems&mdash;if you need to house
          a repository on a Windows machine, stick with Windows 2000
          or Windows XP.  Also, you should never keep a Berkeley DB
          repository on a network share.  While Berkeley DB promises
          to behave correctly on network shares that meet a particular
          set of specifications, almost no known shares actually meet
          all those specifications.</para>
        @ENGLISH }}} -->
        <para>Men alle roser har torner, og derfor m&#229; vi v&#230;re klar over 
          noen kjente begrensninger i Berkeley DB.
          For det f&#248;rste er ikke Berkeley DB-milj&#248;er portable.
          Du kan ikke bare kopiere et Subversiondepot som er laget p&#229; et 
          UNIX-system til et Windows-system og forvente at det skal 
          virke.
          Selv om mye av Berkely DB-formatet er arkitekturuavhengig, er 
          det andre aspekter med milj&#248;et som ikke er det.
          For det andre bruker Subersion Berkeley DB p&#229; en m&#229;te som ikke 
          vil fungere i Windows 95/98 &#8212; hvis du m&#229; ha depotet p&#229; en 
          Windowsmaskin, bruk Windows 2000 eller Windows XP.
          Legg heller aldri et Berkeley DB-depot p&#229; en nettverksdisk.
          Selv om Berkeley DB lover &#229; oppf&#248;re seg korrekt p&#229; 
          nettverksdisker som oppfyller spesielle kriterier, er det 
          nesten ingen kjente nettverksdelinger som faktisk oppfyller 
          alle disse spesifikasjonene.</para>

        <!-- @ENGLISH {{{
        <para>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and clean up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <quote>wedge</quote>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.  So while a
          BerkeleyDB repository is quite fast and scalable, it's best
          used by a single server process running as one
          user&mdash;such as Apache's <command>httpd</command> or
          <command>svnserve</command> (see <xref
          linkend="svn-ch-6"/>)&mdash;rather than accessing it as
          many different users via <literal>file:///</literal> or
          <literal>svn+ssh://</literal> URLs.  If using a Berkeley DB
          repository directly as multiple users, be sure to read <xref
          linkend="svn-ch-6-sect-5"/>.</para>
        @ENGLISH }}} -->
        <para>Til sist, fordi Berkeley DB er et bibliotek linket direkte 
          inn i Subversion, er det mer sensibelt for avbrudd enn et 
          typisk relasjonsdatabesestystem.
          De fleste SQL-systemer har for eksempel en dedikert 
          tjenerprosess som fordeler all tilgang til tabeller.
          Hvis et program som aksesserer databasen krasjer av en eller 
          annen grunn, oppdager daemonen som styrer databasen dette og 
          ordner opp i eventuelt rot som blir liggende igjen.
          Og fordi databasedaemonen er den eneste prosessen som 
          aksesserer tabellene, trenger ikke applikasjoner &#229; tenke p&#229; 
          rettighetskonflikter.
          Disse tingene er imidlertid ikke tilfelle med Berkeley DB.
          Subversion (og programmer som bruker Subversionbiblioteker) 
          aksesserer databasetabellene direkte, noe som betyr at et 
          programkrasj kan etterlate databasen i en midlertidig, 
          utilgjengelig tilstand.
          N&#229;r dette skjer, m&#229; en administrator be Berkeley DB om 
          gjenoppretting til et sjekkpunnkt, noe som er litt plagsomt.
          Andre ting kan f&#248;re til at et depot <quote>kiler seg 
          fast</quote> 
          (<quote><foreignphrase>wedge</foreignphrase></quote>) sammen 
          med krasjede prosesser, som for eksempel programmer som kommer 
          i konflikt ang&#229;ende eierskap og tilgang til databasefilene.
          S&#229; mens et Berkeley DB-depot er ganske raskt og skalerbart, 
          fungerer det best n&#229;r det kun blir brukt av &#233;n enkelt 
          tjenerprosess som kj&#248;rer som &#233;n bruker &#8212; som for eksempel 
          Apaches <command>httpd</command> eller 
          <command>svnserve</command> (se <xref linkend="svn-ch-6"/>) &#8212; 
          istedenfor &#229; aksessere det med mange forskjellige brukere via 
          <literal>file:///</literal> eller 
          <literal>svn+ssh://</literal>-URLer.
          Hvis et Berkeley DB-depot blir brukt direkte med flere 
          forskjellige brukere, pass p&#229; at du har lest <xref 
          linkend="svn-ch-6-sect-5"/>.</para>

      </sect3>
      
    <!-- ***************************************************************** -->
      <sect3 id="svn-ch-5-sect-1.3.2">
        <title>FSFS</title>

        <!-- @ENGLISH {{{
        <para>In mid-2004, a second type of repository storage system
          came into being: one which doesn't use a database at all.
          An FSFS repository stores a revision tree in a single file,
          and so all of a repository's revisions can be found in a
          single subdirectory full of numbered files.  Transactions
          are created in separate subdirectories.  When complete, a
          single transaction file is created and moved to the
          revisions directory, thus guaranteeing that commits are
          atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <quote>hot</quote>, just like a Berkeley DB repository.</para>
        @ENGLISH }}} -->
        <para>I midten av 2004 ble et nytt lagringsformat for depotet 
          laget, et som ikke bruker en database i det hele tatt.
          Et FSFS-depot lagrer et revisjonstre i en enkelt fil, og alle 
          depotets revisjoner kan dermed finnes i en enkelt underkatalog 
          full av nummererte filer.
          Transaksjoner blir opprettet i separate underkataloger.
          N&#229;r den er komplett, blir en enkelt transaksjonsfil opprettet 
          og flyttet til revisjonskatalogen og garanterer dermed at 
          innleggingen blir atomisk.
          Og fordi en revisjonsfil er permanent og uforanderlig, kan 
          depotet ogs&#229; bli tatt backup av mens det er i bruk, akkurat 
          som et Berkeley DB-depot.</para>

        <!-- @ENGLISH {{{
        <para>The revision-file format represents a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          there's no journaling or shared-memory files being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means that the overall repository
          size is a bit smaller.</para>
        @ENGLISH }}} -->
        <para>Revisjonsfilformatet representerer en revisjons 
          katalogstruktur, filinnhold, og forskjeller i forhold til 
          filer i andre revisjonstr&#230;r.
          Ulikt en Berkeley DB-database, er dette lagringsformatet 
          portabelt mellom forskjellige operativsystemer og er ikke 
          sensitiv ovenfor CPU-arkitektur.
          Fordi det ikke blir brukt journalfiler eller filer som bruker 
          delt hukommelse, kan depotet trygt aksesseres via et 
          nettverksfilsystem og bli utforsket i et skrivebeskyttet 
          milj&#248;.
          Mangelen p&#229; databaseoverhead betyr ogs&#229; at den samlede 
          depotst&#248;rrelsen blir en del mindre.</para>

        <!-- @ENGLISH {{{
        <para>FSFS has different performance characteristics too.
          When committing a directory with a huge number of files, FSFS
          uses an O(N) algorithm to append entries, while Berkeley DB
          uses an O(N^2) algorithm to rewrite the whole directory.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the fulltexts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time-out when
          waiting for a response.</para>
        @ENGLISH }}} -->
        <para>FSFS har ogs&#229; forskjellige karakteristikker n&#229;r det 
          gjelder <!-- &#164; -->effektivitet. N&#229;r en katalog med mange filer 
          legges inn, bruker FSFS en O(N) algoritme for &#229; legge til 
          poster, mens Berkeley DB bruker en O(N^2) algoritme for &#229; 
          skrive hele katalogen en gang til.
          P&#229; den annen side skriver FSFS den seneste versjonen av en fil 
          som en delta (forskjell) mot en tidligere versjon, noe som 
          betyr at det &#229; hente ut det seneste treet er litt langsommere 
          enn &#229; hente fullteksten lagret i en HEAD-revisjon i Berkeley 
          DB.
          FSFS har ogs&#229; en lengre forsinkelse n&#229;r en innlegging skal 
          fullf&#248;res, noe som i ekstreme tilfeller kan f&#248;re til at 
          klienter f&#229;r et tidsavbrudd under venting p&#229; respons.</para>

        <!-- @ENGLISH {{{
        <para>The most important distinction, however, is FSFS's
          inability to be <quote>wedged</quote> when something goes
          wrong.  If a process using a Berkeley DB database runs into
          a permissions problem or suddenly crashes, the database is
          left unusable until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</para>
        @ENGLISH }}} -->
        <para>Men den viktigste forskjellen er FSFSs evne til &#229; ikke bli 
          <quote>fastkilt</quote> hvis noe g&#229;r galt.
          Hvis en prosess som bruker en Berkeley DB-database f&#229;r 
          problemer med rettigheter eller plutselig krasjer, er ikke 
          databasen brukbar f&#248;r en administrator gjenoppretter den.
          Hvis det samme skjer med en prosess som bruker et FSFS-depot, 
          blir ikke depotet p&#229;virket i det hele tatt.
          I verste fall blir bare noen transaksjonsdata liggende 
          igjen.</para>

        <!-- @ENGLISH {{{
        <para>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  It hasn't been used or
          stress-tested nearly as much, and so a lot of these
          assertions about speed and scalability are just that:
          assertions, based on good guesses.  In theory, it promises a
          lower barrier to entry for new administrators and is less
          susceptible to problems.  In practice, only time will
          tell.</para>
        @ENGLISH }}} -->
        <para>Det eneste virkelige argumentet mot FSFS er fartstiden det 
          har hatt i forhold til Berkeley DB.
          Det er ikke like mye brukt og har ikke blitt stresstestet like 
          mye, s&#229; derfor er mange av disse antakelsene om hastighet og 
          skalerbarhet nettopp det:
          Antakelser, basert p&#229; gode gjetninger.
          I teorien lover den en lavere barriere &#229; forsere for nye 
          administratorer &#229; forsere og er forventet &#229; skape mindre 
          problemer.
          I praksis vil bare tiden vise om dette stemmer.</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-2">
    <!-- @ENGLISH {{{
    <title>Repository Creation and Configuration</title>
    @ENGLISH }}} -->
    <title>Opprettelse og konfigurering av depotet</title>

    <!-- @ENGLISH {{{
    <para>Creating a Subversion repository is an incredibly simple
      task.  The <command>svnadmin</command> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</para>
    @ENGLISH }}} -->
    <para>Det &#229; opprette et Subversiondepot er en utrolig enkel oppgave.
      <command>svnadmin</command>-verkt&#248;yet som f&#248;lger med Subversion 
      har en delkommando som gj&#248;r akkurat det.
      For &#229; opprette et nytt depot, er det bare &#229; kj&#248;re:</para>
          
    <!-- @ENGLISH {{{
    <screen>
$ svnadmin create /path/to/repos
</screen>
    @ENGLISH }}} -->
    <screen>
$ svnadmin create /sti/til/depot
</screen>
          
    <!-- @ENGLISH {{{
    <para>This creates a new repository in the directory
      <filename>/path/to/repos</filename>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<filename>/</filename>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <literal>svn:date</literal>, set to the time at which
      the repository was created.</para>
    @ENGLISH }}} -->
    <para>Dette oppretter et nytt depot i katalogen 
      <filename>/sti/til/depot</filename>.
      Dette nye depotet starter livet ved revisjon 0, som er definert 
      til &#229; bare innholde en rot p&#229; toppniv&#229; (<filename>/</filename>) i 
      filsystemet.
      Revisjon 0 har ogs&#229; en enkelt revisjonsegenskap satt 
      innledningsvis, <literal>svn:date</literal>, som er satt til 
      tidspunktet depotet ble opprettet.</para>

    <!-- @ENGLISH {{{
    <para>In Subversion 1.1, a repository is created with a Berkeley
      DB back-end by default.  This behavior may change in future
      releases.  Regardless, the type can be explicitly chosen with
      the <option>-&#64738;-fs-type</option> argument:</para>
    @ENGLISH }}} -->
    <para>I Subversion 1.1 blir et depot opprettet med en 
      bakenforliggende Berkeley DB-database som standard.
      Denne oppf&#248;rselen kan forandre seg i fremtidige releaser.
      Uansett, typen kan bli eksplisitt valgt med 
      <option>--fs-type</option>-valget:</para>

    <!-- @ENGLISH {{{
    <screen>
$ svnadmin create -&#64738;-fs-type fsfs /path/to/repos
$ svnadmin create -&#64738;-fs-type bdb /path/to/other/repos
</screen>
    @ENGLISH }}} -->
    <screen>
$ svnadmin create --fs-type fsfs /sti/til/depot
$ svnadmin create --fs-type bdb /sti/til/annet/depot
</screen>


    <warning>
      <!-- @ENGLISH {{{
      <para>Do not create a Berkeley DB repository on a network
        share&mdash;it <emphasis>cannot</emphasis> exist on a remote
        filesystem such as NFS, AFS, or Windows SMB.  Berkeley DB
        requires that the underlying filesystem implement strict POSIX
        locking semantics, and more importantly, the ability to map
        files directly into process memory.  Almost no network
        filesystems provide these features.  If you attempt to use
        Berkeley DB on a network share, the results are
        unpredictable&mdash;you may see mysterious errors right away,
        or it may be months before you discover that your repository
        database is subtly corrupted.</para>
      @ENGLISH }}} -->
      <para>Opprett ikke et Berkeley DB-depot p&#229; en nettverksdisk &#8212; det 
        <emphasis>kan ikke</emphasis> eksistere p&#229; et fjerntliggende 
        filsystem som NFS, AFS eller Windows SMB.
        Berkeley DB krever at det underliggende filsystemet har 
        implementert streng POSIX l&#229;sesemantikk, og enda viktigere, 
        muligheten til &#229; mappe filer direkte inn i prosesshukommelsen.
        Nesten ingen nettverksfilsystemer tilbyr disse mulighetene.
        Hvis du fors&#248;ker &#229; bruke Berkeley DB p&#229; en nettverksdisk, er 
        resultatene uforutsigelige &#8212; du kan se mystiske feilmeldinger 
        med en gang, eller det kan g&#229; m&#229;nedsvis f&#248;r du oppdager at 
        depotet i all stillhet blir herpa.</para>

      <!-- @ENGLISH {{{
      <para>If you need multiple computers to access the repository,
        you create an FSFS repository on the network share, not a
        Berkeley DB repository.  Or better yet, set up a real server
        process (such as Apache or <command>svnserve</command>), store
        the repository on a local filesystem which the server can
        access, and make the repository available over a network.
        <xref linkend="svn-ch-6"/> covers this process in
        detail.</para>
      @ENGLISH }}} -->
      <para>Hvis du trenger flere datamaskiner for &#229; aksessere depotet, 
        lager du et FSFS-depot p&#229; nettverksdisken, ikke et Berkeley 
        DB-depot.
        Eller enda bedre, sett opp en skikkelig tjenerprosess (som for 
        eksempel Apache eller <command>svnserve</command>), legg depotet 
        i et lokalt filsystem som tjeneren aksessere, og gj&#248;r depotet 
        tilgjengelig over et nettverk. <xref linkend="svn-ch-6"/> dekker 
        denne prosessen i detalj.</para>
    </warning>
          
    <!-- @ENGLISH {{{
    <para>You may have noticed that the path argument to
      <command>svnadmin</command> was just a regular filesystem path
      and not a URL like the <command>svn</command> client program
      uses when referring to repositories.  Both
      <command>svnadmin</command> and <command>svnlook</command> are
      considered server-side utilities&mdash;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even <quote>local</quote>
      <literal>file:</literal> ones) to these two programs.</para>
    @ENGLISH }}} -->
    <para>Du har kanskje lagt merke til at stiargumentet til 
      <command>svnadmin</command> bare var en vanlig filsystemsti og 
      ikke en URL lik det <command>svn</command>-klienten bruker n&#229;r den 
      refererer til depot.
      B&#229;de <command>svnadmin</command> og <command>svnlook</command> 
      ansees som tjenerside-verkt&#248;y &#8212; de blir brukt p&#229; maskinen hvor 
      depotet ligger for &#229; unders&#248;ke og modifisere aspekter ved depotet, 
      og er faktisk ikke i stand til &#229; utf&#248;re oppgaver over nettverket.
      En vanlig feil som blir gjort av nybakte Subversionbrukere er &#229; gi 
      URLer (til og med av typene <quote>local</quote> og 
      <literal>file:</literal>) til disse to programmene.</para>

    <!-- @ENGLISH {{{
    <para>So, after you've run the <command>svnadmin create</command>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</para>
    @ENGLISH }}} -->
    <para>S&#229;, etter at du har kj&#248;rt <command>svnadmin 
      create</command>-kommandoen, har du et skinnende nytt depot i sin 
      egen katalog.
      La oss ta en kikk p&#229; hva som egentlig er laget i denne 
      katalogen.</para>
            
    <!-- @ENGLISH {{{
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
    @ENGLISH }}} -->
    <screen>
$ ls depot
conf/  dav/  db/  format  hooks/  locks/  README.txt
</screen>
      
    <!-- @ENGLISH {{{
    <para>With the exception of the <filename>README.txt</filename> and
      <filename>format</filename> files,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</para>
    @ENGLISH }}} -->
    <para>Med unntak av filene <filename>README.txt</filename> og 
      <filename>format</filename>, er depotkatalogen en samling av 
      underkataloger.
      Som i andre omr&#229;der av Subversion-designet er modularitet gitt 
      stor oppmerksomhet, og hierarkisk organisering er foretrukket 
      framfor <!-- cluttered -->rotete kaos.
      Her er en rask beskrivelse av alle elementene som du ser i den nye 
      depotkatalogen:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory containing repository configuration files.</para>
          @ENGLISH }}} -->
          <para>En katalog som inneholder konfigurasjonsfiler for 
            depotet.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dav</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</para>
          @ENGLISH }}} -->
          <para>En katalog der Apache og mod_dav_svn lagrer sine 
            husholdningsdata.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>Where all of your versioned data resides.  This
            directory is either a Berkeley DB environment (full of DB
            tables and other things), or is an FSFS environment
            containing revision files.</para>
          @ENGLISH }}} -->
          <para>Hvor alle dine versjonerte data ligger.
            Denne katalogen er enten et Berkeley DB-milj&#248; (full av 
            databasetabeller og andre ting), eller i et FSFS-milj&#248; som 
            inneholder revisjonsfiler.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</para>
          @ENGLISH }}} -->
          <para>En fil som inneholder en enkelt heltallsverdi som 
            spesifiserer versjonsnummeret til depotlayouten.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</para>
          @ENGLISH }}} -->
          <para>En katalog full av maler for p&#229;hakningsskript (Engelsk: 
            <foreignphrase>hooks</foreignphrase>) (og 
            p&#229;hakningsskriptene selv, n&#229;r du har installert 
            noen).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</para>
          @ENGLISH }}} -->
          <para>En katalog for Subversions l&#229;sedata, brukt for &#229; f&#248;lge 
            <!-- &#164; -->tilganger til depotet.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <!-- @ENGLISH {{{
          <para>A file which merely informs its readers that they
            are looking at a Subversion repository.</para>
          @ENGLISH }}} -->
          <para>En fil som bare informerer sine lesere om at de ser p&#229; 
            et Subversiondepot.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <!-- @ENGLISH {{{
    <para>In general, you shouldn't tamper with your repository
      <quote>by hand</quote>.  The <command>svnadmin</command> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</para>
    @ENGLISH }}} -->
    <para>Generelt sett skal du ikke fikle med depotet <quote>for 
      h&#229;nd</quote>.
      <command>svnadmin</command>-verkt&#248;yet skal v&#230;re nok til alle 
      n&#248;dvendige forandringer i depotet, eller du kan se p&#229; 
      tredjeparti-verkt&#248;y (som Berkeley DBs verkt&#248;ysamling) for &#229; 
      finpusse relevante subseksjoner av depotet.
      Noen unntak gjelder imidlertid, og disse skal vi g&#229; gjennom 
      her.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <!-- @ENGLISH {{{
      <title>Hook Scripts</title>
      @ENGLISH }}} -->
      <title>P&#229;hakningsskript</title>

      <!-- @ENGLISH {{{
      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</para>
      @ENGLISH }}} -->
      <para>Et <!-- &#164; --><firstterm>p&#229;hakningsskript</firstterm> (p&#229; 
        engelsk kalt <foreignphrase>hooks</foreignphrase>) er et program 
        som blir utl&#248;st av en hendelse i depotet, som for eksempel 
        opprettelsen av en ny revisjon eller modifiseringen av en 
        uversjonert egenskap.
        Hver p&#229;hakning blir gitt nok informasjon til &#229; fortelle hva 
        denne hendelsen er, hvilke m&#229;l den opererer p&#229;, og brukernavnet 
        til personen som satte i gang hendelsen.
        Avhengig av p&#229;hakningens utdata eller returstatus, kan 
        p&#229;hakningsprogrammet fortsette hendelsen, stoppe den, eller 
        utsette den p&#229; en eller annen m&#229;te.</para>
            
      <!-- @ENGLISH {{{
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks.</para>
      @ENGLISH }}} -->
      <para><filename>hooks</filename>-katalogen er, som standard, fylt 
        med maler for diverse depotp&#229;hakninger.</para>
            
      <!-- @ENGLISH {{{
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</screen>
      @ENGLISH }}} -->
      <screen>
$ ls depot/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl
</screen>
            
      <!-- @ENGLISH {{{
      <para>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory
        which can be executed as the name (like
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>
      @ENGLISH }}} -->
      <para>Det er en mal for hver p&#229;hakning som Subversiondepotet 
        implementerer, og ved &#229; unders&#248;ke innholdet til disse 
        eksempelskriptene, kan du se hva som f&#248;rer til at hvert av disse 
        skriptene begynner &#229; kj&#248;re og hvilke data som blir levert til 
        dette skriptet.
        Det som ogs&#229; ligger i mange av disse malene er eksempler p&#229; 
        hvordan man kan bruke skriptet, i sammenheng med andre 
        Subversion-<!-- &#164; -->st&#248;ttede programmer, for &#229; utf&#248;re vanlige, 
        nyttige oppgaver.
        For &#229; faktisk installere en p&#229;hakning som virker, trenger du 
        bare &#229; plassere et kj&#248;rbart program eller skript i 
        <filename>depot/hooks</filename>-katalogen som kan bli kj&#248;rt 
        basert p&#229; navnet (som for eksempel 
        <command>start-commit</command> eller 
        <command>post-commit</command>) til p&#229;hakningen.</para>

      <!-- @ENGLISH {{{
      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <literal>.tmpl</literal> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> or <filename>.com</filename> for
        programs, and <filename>.bat</filename> for batch
        files.</para>
      @ENGLISH }}} -->
      <para>P&#229; Unix-plattformer betyr dette &#229; legge inn et skript eller 
        program (som kan v&#230;re et <!-- &#164; -->shellskript, et 
        Pythonprogram, et kompilert C-program, eller hva som helst 
        annet) som heter akkurat det samme som p&#229;hakningen.
        Selvf&#248;lgelig, malfilene er der for mer enn bare 
        informasjonsverdien &#8212; den letteste m&#229;ten &#229; installere en 
        p&#229;hakning p&#229; Unixplattformer er &#229; bare kopiere den riktige 
        malfilen til en ny fil som mangler 
        <literal>.tmpl</literal>-etternavnet, finpusse p&#229; innholdet, og 
        forsikre deg om at skriptet er kj&#248;rbart.
        Men Windows bruker filetternavn til &#229; avgj&#248;re hvorvidt et 
        program er kj&#248;rbart eller ikke, s&#229; da m&#229; du legge inn et program 
        der hovednavnet er navnet p&#229; p&#229;hakningen, og der etternavnet er 
        en av de spesielle etternavnene som Windows kjenner igjen som 
        kj&#248;rbare, for eksempel <filename>.exe</filename> eller 
        <filename>.com</filename> for programmer, og 
        <filename>.bat</filename> for batchfiler.</para>

      <tip>
        <!-- @ENGLISH {{{
        <para>For security reasons, the Subversion repository executes
        hook scripts with an empty environment&mdash;that is, no
        environment variables are set at all, not even
        <literal>$PATH</literal> or <literal>%PATH%</literal>.
        Because of this, a lot of administrators are baffled when
        their hook script runs fine by hand, but doesn't work when run
        by Subversion.  Be sure to explicitly set environment
        variables in your hook and/or use absolute paths to
        programs.</para>
        @ENGLISH }}} -->
        <para>Av sikkerhetsgrunner kj&#248;rer Subversion p&#229;hakningsskript 
          med et tomt milj&#248; (environment) &#8212; det betyr, ingen 
          milj&#248;variabler er satt i det hele tatt, ikke engang 
          <literal>$PATH</literal> eller <literal>%PATH%</literal>.
          P&#229; grunn av dette blir mange adminstratorer forvirret n&#229;r 
          p&#229;hakningsskriptet kj&#248;rer fint for h&#229;nd, men virker ikke n&#229;r 
          det blir kj&#248;rt av Subversion.
          Pass p&#229; &#229; eksplisitt sette variabler i skriptet og/eller bruk 
          absolutte stier til programmer.</para>
      </tip>

      <!-- @ENGLISH {{{
      <para>Currently there are five hooks implemented by the
        Subversion repository:</para>
      @ENGLISH }}} -->
      <para>Forel&#248;pig er det fem p&#229;hakninger som er lagt inn i 
        Subversiondepotet:</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.  If the
              hook program writes data to stderr, it will be
              marshalled back to the client.</para>
            @ENGLISH }}} -->
            <para>Denne blir kj&#248;rt allerede f&#248;r innleggingstransaksjonen 
              er opprettet.
              Det blir vanligvis brukt til &#229; avgj&#248;re om brukeren har 
              innleggingsprivilegier i det hele tatt.
              Depotet leverer to argumenter til dette programmet:
              Stien til depotet, og brukernavnet som fors&#248;ker seg p&#229; 
              innleggingen.
              Hvis programmet returnerer en verdi som ikke er null, blir 
              denne innleggingen stoppet allerede f&#248;r transaksjonen blir 
              laget.
              Hvis p&#229;hakningen skriver data til <!-- &#164; Det h&#248;res bedre 
              ut enn &#171;standard feil&#187;. -->stderr, vil det bli <!-- &#164; 
              marshalled -->sendt tilbake til klienten.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and the transaction is removed.  If the hook
              program writes data to stderr, it will be marshalled
              back to the client.</para>
            @ENGLISH }}} -->
            <para>Dette blir kj&#248;rt n&#229;r transaksjonen er komplett, men 
              f&#248;r den er lagt inn.
              Vanligvis blir denne p&#229;hakningen brukt til &#229; beskytte mot 
              innlegginger som er forbudt p&#229; grunn av innhold eller 
              beliggenhet (for eksempel kan <!-- &#164; site -->tjeneren 
              kreve at alle innlegginger til en spesiell gren inneholder 
              et billettnummer fra feildatabasen, eller at den 
              innkommende loggmeldingen ikke er tom).
              Depotet leverer to argumenter til dette programmet:
              Stien til depotet, og navnet p&#229; transaksjonen som legges 
              inn.
              Hvis programmet returnerer en verdi som ikke er null, 
              avbrytes innleggingen og transaksjonen blir fjernet.
              Hvis programmet skriver data til stderr, vil dette bli 
              <!-- marshalled -->sendt tilbake til klienten.</para>

            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes some access
              control scripts (located in the
              <filename>tools/hook-scripts</filename> directory of the
              Subversion source tree) that can be called from
              <command>pre-commit</command> to implement fine-grained
              write-access control.  Another option is to use the
              <command>mod_authz_svn</command> Apache httpd module,
              which provides both read and write access control on
              individual directories (see <xref
              linkend="svn-ch-6-sect-4.4.2"/>).  In a future version
              of Subversion, we plan to implement access control lists
              (ACLs) directly in the filesystem.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inneholder noen 
              aksesskontrollskript (i 
              <filename>tools/hook-scripts</filename>-katalogen i 
              kildekodefiltreet til Subversion) som kan bli kalt fra 
              <command>pre-commit</command> for &#229; kunne legge inn 
              finjustert kontroll for skriveaksess.
              En annen mulighet er &#229; bruke Apache-modulen 
              <command>mod_authz_svn</command>, som gir b&#229;de lese- og 
              skrivekontroll i individuelle kataloger (se <xref 
              linkend="svn-ch-6-sect-4.4.2"/>).
              I en fremtidig versjon av Subversion planlegger vi &#229; legge 
              inn lister for aksesskontroll (ACL) direkte inn i 
              filsystemet.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</para>
            @ENGLISH }}} -->
            <para>Dette blir kj&#248;rt etter at transaksjonen er lagt inn, 
              og en ny revisjon er opprettet.
              De fleste vil bruke denne p&#229;hakningen til &#229; sende ut 
              beskrivende emailer om innleggingen eller for &#229; ta backup 
              av depotet.
              Depotet gir to argumenter til dette programmet:
              Stien til depotet, og det nye revisjonsnummeret som ble 
              opprettet.
              Returverdien fra programmet blir ignorert.</para>
                
            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes
              <command>mailer.py</command> and
              <command>commit-email.pl</command> scripts (located in
              the <filename>tools/hook-scripts/</filename> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inneholder skriptene
              <command>mailer.py</command> og 
              <command>commit-email.pl</command> (i 
              <filename>tools/hook-scripts/</filename>-katalogen i 
              Subversiontreet) som kan bli brukt til &#229; sende email med 
              (og/eller legge til en loggfil) en beskrivelse av en 
              mottatt innlegging.
              Denne mailen inneholder en liste over de stiene som ble 
              forandret, loggmeldingen som er vedlagt innleggingen, 
              forfatteren og datoen til innleggingen, sammen med en GNU 
              diff-visning av forandringene som ble gjort til diverse 
              filer som del av innleggingen.</para>

            <!-- @ENGLISH {{{
            <para>Another useful tool provided by Subversion is the
              <command>hot-backup.py</command> script (located in the
              <filename>tools/backup/</filename> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</para>
            @ENGLISH }}} -->
            <para>Et annet nyttig verkt&#248;y som f&#248;lger med Subversion er 
              skriptet <command>hot-backup.py</command> (i 
              <filename>tools/backup/</filename>-katalogen i 
              kildekodetreet til Subversion).
              Dette skriptet utf&#248;rer varme backuper av Subversiondepotet 
              (en funksjonalitet st&#248;ttet av den bakenforliggende 
              Berkeley DB-databasen), og kan bli brukt til &#229; foreta en 
              &#248;yeblikkslagring av depotet mellom hver innlegging for 
              arkiverings- eller sikkerhetsform&#229;l.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <literal>svn:log</literal> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <filename>post-revprop-change</filename>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.  As a precaution against losing
              unversioned property data, Subversion clients will not
              be allowed to remotely modify revision properties at all
              unless this hook is implemented for your repository.</para>
            @ENGLISH }}} -->
            <para>Fordi Subversions revisjonsegenskaper ikke er 
              versjonerte, vil det &#229; forandre slike egenskaper (for 
              eksempel <literal>svn:log</literal>-egenskapen som 
              inneholder loggmeldingen for innleggingen) overskrive den 
              forrige verdien for alltid.
              Siden data kan g&#229; tapt her, har Subversion denne 
              p&#229;hakningen (og dens <!-- &#164; -->motstykke 
              <filename>post-revprop-change</filename>) s&#229; 
              depotadministratorer kan lage logger med forandringer til 
              disse elementene ved bruk av eksterne hjelpemidler hvis de 
              vil det.
              Som en forholdsregel mot &#229; miste uversjonerte data, vil 
              ikke Subversionklienter f&#229; lov til &#229; forandre 
              revisjonsegenskaper i det hele tatt hvis ikke denne 
              p&#229;hakningen er aktivisert i depotet ditt.</para>

            <!-- @ENGLISH {{{
            <para>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and the name of the property itself.</para>
            @ENGLISH }}} -->
            <para>Denne p&#229;hakningen kj&#248;rer like f&#248;r en slik modifisering 
              blir lagt inn i depotet.
              Depotet leverer fire argumenter til denne p&#229;hakningen:
              Stien til depotet, revisjonen som egenskapen som skal 
              forandres befinner seg p&#229;, det godkjente brukernavnet til 
              personen som gj&#248;r forandringen, og navnet p&#229; selve 
              egenskapen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-revprop-change</filename></term>
          <listitem>
            <!-- @ENGLISH {{{
            <para>As mentioned earlier, this hook is the counterpart
              of the <filename>pre-revprop-change</filename> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <filename>pre-revprop-change</filename> hook
              exists.  When both of these hooks are present, the
              <filename>post-revprop-change</filename> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and the name of
              the property itself.</para>
            @ENGLISH }}} -->
            <para>Som nevnt tidligere, er denne p&#229;hakningen motstykket 
              til <filename>pre-revprop-change</filename>-p&#229;hakningen.
              Faktisk, for paranoiaens skyld vil ikke dette skriptet 
              kj&#248;re uten at 
              <filename>pre-revprop-change</filename>-skriptet finnes.
              N&#229;r begge disse skriptene finnes, kj&#248;rer 
              <filename>post-revprop-change</filename>-p&#229;hakningen like 
              etter en revisjonsegenskap er blitt forandret, og blir 
              vanligvis brukt til &#229; sende en mail som inneholder den nye 
              verdien til den forandrede egenskapen.
              Depotet leverer fire argumenter til denne p&#229;hakningen:
              Stien til depotet, revisjonen som egenskapen tilh&#248;rer, det 
              godkjente brukernavnet til personen som gj&#248;r forandringen, 
              og navnet p&#229; selve egenskapen.</para>

            <!-- @ENGLISH {{{
            <para>The Subversion distribution includes a
              <command>propchange-email.pl</command> script (located
              in the <filename>tools/hook-scripts/</filename>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</para>
            @ENGLISH }}} -->
            <para>Subversiondistribusjonen inkluderer skriptet 
              <command>propchange-email.pl</command> (i 
              <filename>tools/hook-scripts/</filename>-katalogen i 
              Subversions kildekodetre) som kan bli brukt til &#229; sende 
              mail med (og/eller legge til en loggfil) detaljene om en 
              egenskapsforandring.
              Denne mailen inneholder revisjonen og navnet til den 
              forandrede egenskapen, brukeren som gjorde forandringen, 
              og den nye verdien til egenskapen.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <warning>
        <!-- @ENGLISH {{{
        <para>Do not attempt to modify the transaction using hook
          scripts. A common example of this would be to automatically
          set properties such as <literal>svn:eol-style</literal> or
          <literal>svn:mime-type</literal> during the commit.  While
          this might seem like a good idea, it causes problems.  The
          main problem is that the client does not know about the
          change made by the hook script, and there is no way to
          inform the client that it is out-of-date.  This
          inconsistency can lead to surprising and unexpected
          behavior.</para>
        @ENGLISH }}} -->
        <para>Ikke fors&#248;k &#229; forandre transaksjonen ved &#229; bruke 
          p&#229;hakningsskript.
          Et vanlig eksempel p&#229; dette ville v&#230;re &#229; automatisk sette 
          egenskaper som <literal>svn:eol-style</literal> eller 
          <literal>svn:mime-type</literal> under innleggingen.
          Selv om dette kan se ut som en god id&#233;, f&#248;rer det til 
          problemer.
          Hovedproblemet er at klienten ved ikke om forandringen gjort 
          av p&#229;hakningsscriptet, og det er ingen m&#229;te &#229; informere 
          klienten om at den er utdatert.
          Denne inkonsekventheten kan f&#248;re til overraskende og uventet 
          oppf&#248;rsel.</para>

        <!-- @ENGLISH {{{
        <para>Instead of attempting to modify the transaction, it is
          much better to <emphasis>check</emphasis> the transaction in
          the <filename>pre-commit</filename> hook and reject the
          commit if it does not meet the desired requirements.</para>
        @ENGLISH }}} -->
        <para>Istedenfor &#229; fors&#248;ke &#229; modifisere transaksjonen, er det 
          mye bedre &#229; <emphasis>sjekke</emphasis> transaksjonen i 
          <filename>pre-commit</filename> og nekte innlegging hvis den 
          ikke m&#248;ter de &#248;nskede kravene.</para>
      </warning>

      <para>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</para>
      @ENGLISH }}} -->
      <para>Subversion vil fors&#248;ke &#229; kj&#248;re p&#229;hakningsskriptene som den 
        samme brukeren som eier prosessen som aksesserer 
        Subversiondepotet.
        I de fleste tilfeller blir depotet aksessert via Apache 
        HTTPD-tjeneren og mod_dav_svn, s&#229; denne brukeren er den samme 
        som Apache kj&#248;rer som.
        Selve p&#229;hakningen m&#229; bli satt opp med rettigheter p&#229; 
        operativsystemniv&#229; som tillater denne brukeren &#229; kj&#248;re dem.
        Dette betyr ogs&#229; at enhver fil eller program (inkludert selve 
        Subversiondepotet) aksessert direkte eller indirekte av 
        p&#229;hakningen vil bli aksessert som den samme brukeren.
        Med andre ord, v&#230;r obs p&#229; mulig rettighetsproblematikk som kan 
        forhindre p&#229;hakningsskriptet fra &#229; utf&#248;re de oppgavene du har 
        satt det til.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <!-- @ENGLISH {{{
      <title>Berkeley DB Configuration</title>
      @ENGLISH }}} -->
      <title>Konfigurasjon av Berkeley DB</title>

      <!-- @ENGLISH {{{
      <para>A Berkeley DB environment is an encapsulation of one or
        more databases, log files, region files and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things like the number of locks
        allowed to be taken out at any given time, or the maximum size
        of the journaling log files, etc.  Subversion's filesystem
        code additionally chooses default values for some of the
        Berkeley DB configuration options.  However, sometimes your
        particular repository, with its unique collection of data and
        access patterns, might require a different set of
        configuration option values.</para>
      @ENGLISH }}} -->
      <para>Et Berkeley DB-milj&#248; er en innkapsling av en eller flere 
        databaser, loggfiler, regionfiler og konfigurasjonsfiler.
        Berkeley DB-milj&#248;et har sitt eget sett med konfigurasjonsverdier 
        for ting som antallet l&#229;ser som er tillatt brukt p&#229; en gang, 
        maksimal st&#248;rrelse p&#229; journalloggfiler og s&#229; videre.
        Subversions filsystemkode velger i tillegg standardverdier for 
        noen av konfigurasjonsvalgene i Berkeley DB.</para>

      <!-- @ENGLISH {{{
      <para>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        overriding at runtime many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <filename>DB_CONFIG</filename> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</para>
      @ENGLISH }}} -->
      <para>Folkene i Sleepycat (produsentene av Berkeley DB) innser at 
        forskjellige databaser har forskjellige krav, og de har derfor 
        lagt inn en mekanisme for &#229; overstyre mange av 
        konfigurasjonsverdiene til Berkeley DB under kj&#248;ring.
        Berkeley sjekker at filen <filename>DB_CONFIG</filename> finnes 
        i hver milj&#248;katalog, og leser valgene som er i denne filen for 
        bruk med akkurat dette Berkeley-milj&#248;et.</para>

      <!-- @ENGLISH {{{
      <para>The Berkeley configuration file for your repository is
        located in the <filename>db</filename> environment directory,
        at <filename>repos/db/DB_CONFIG</filename>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <filename>DB_CONFIG</filename> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <filename>DB_CONFIG</filename> won't take effect until you
        recover the database environment (using <command>svnadmin
        recover</command>).</para>
      @ENGLISH }}} -->
      <para>Berkeley-konfigurasjonsfilen for ditt depot ligger i 
        milj&#248;katalogen <filename>db</filename> i 
        <filename>depot/db/DB_CONFIG</filename>.
        Subversion oppretter selv denne filen n&#229;r den lager resten av 
        depotet.
        Filen inneholder innledningsvis noen standardvalg sammen med 
        pekere til dokumentasjonen til Berkeley DB som ligger online s&#229; 
        du kan lese om hva disse valgene gj&#248;r.
        Selvf&#248;lgelig kan du legge til alle st&#248;ttede Berkeley DB-valg til 
        <filename>DB_CONFIG</filename>-filen.
        Pass bare p&#229; at mens Subversion aldri pr&#248;ver &#229; lese eller forst&#229; 
        innholdet i filen og bruker ingen av valgene i den, vil du unng&#229; 
        &#229; gj&#248;re forandringer i konfigurasjonen som f&#229;r Berkeley DB seg 
        til &#229; oppf&#248;re seg annerledes enn det Subversionkoden forventer.
        I tillegg vil ikke forandringer gjort i 
        <filename>DB_CONFIG</filename> aktiviseres f&#248;r du gjenoppretter 
        databasemilj&#248;et (ved bruk av <command>svnadmin 
        recover</command>.</para>
    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-3">
    <!-- @ENGLISH {{{
    <title>Repository Maintenance</title>
    @ENGLISH }}} -->
    <title>Vedlikehold av depotet</title>

    <!-- @ENGLISH {{{
    <para>Maintaining a Subversion repository can be a daunting task,
      mostly due to the complexities inherent in systems which have a
      database backend.  Doing the task well is all about knowing the
      tools&mdash;what they are, when to use them, and how to use
      them.  This section will introduce you to the repository
      administration tools provided by Subversion, and how to wield
      them to accomplish tasks such as repository migrations,
      upgrades, backups and cleanups.</para>
    @ENGLISH }}} -->
    <para>&#197; vedlikeholde et Subversiondepot kan v&#230;re en skremmende 
      oppgave, mest p&#229; grunn av kompleksiteten innebygget i systemer som 
      har en bakenforliggende database.
      &#197; utf&#248;re oppgaven godt handler om &#229; kjenne verkt&#248;yene &#8212; hva de er, 
      n&#229;r de skal brukes, og hvordan de brukes.
      Denne seksjonen vil introdusere deg for administrasjonsverkt&#248;y som 
      f&#248;lger med Subversion, og hvordan <!-- &#164; wield -->f&#229; dem til &#229; 
      utf&#248;re oppgaver som flytting av depot, oppgraderinger, 
      sikkerhetskopier og opprydding.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.1">
      <!-- @ENGLISH {{{
      <title>An Administrator's Toolkit</title>
      @ENGLISH }}} -->
      <title>En administrators verkt&#248;ykasse</title>

      <!-- @ENGLISH {{{
      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</para>
      @ENGLISH }}} -->
      <para>Subversion har en h&#229;ndfull programmer nyttige for &#229; 
        opprette, inspisere, modifisere og reparere depotet ditt.
        La oss se litt n&#230;rmere p&#229; hvert av disse verkt&#248;yene.
        Etterp&#229; vil vi g&#229; raskt over noen av de programmene som er 
        inkludert i Berkeley DB-distribusjonen som tilbyr funksjonalitet 
        spesifikk til databasedelen i depotet som ikke Subversions egne 
        verkt&#248;y tar seg av.</para>

      <sect3 id="svn-ch-5-sect-3.1.1">
        <title>svnlook</title>
            
        <!-- @ENGLISH {{{
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository&mdash;it's a
          <quote>read-only</quote> tool.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> er et verkt&#248;y som f&#248;lger med 
          Subversion. Det er beregnet for &#229; utforske de forskjellige 
          revisjonene og transaksjonene i et depot.
          Ingen deler av dette programmet pr&#248;ver &#229; forandre depotet &#8212; 
          det er et <quote>bare for lesing</quote>-verkt&#248;y.
          <command>svnlook</command> blir vanligvis brukt av 
          p&#229;hakningene i depotet for &#229; rapportere forandringene som er i 
          ferd med &#229; bli lagt inn (i tilfellet med 
          <command>pre-commit</command>-p&#229;hakningen) eller det som 
          nettopp ble lagt inn (i tilfellet med 
          <command>post-commit</command>-p&#229;hakningen) i depotet.
          En depotadministrator kan bruke dette verkt&#248;yet for 
          diagnoseform&#229;l.</para>
            
        <!-- @ENGLISH {{{
        <para><command>svnlook</command> has a straightforward
          syntax:</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> har en <!-- &#164; -->likefrem 
          syntaks:</para>
            
        <!-- &#164; Legg inn norsk versjon -->
        <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
&hellip;
</screen>

        <!-- @ENGLISH {{{
        <para>Nearly every one of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>-&#64738;-revision</option> and
          <option>-&#64738;-transaction</option> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</para>
        @ENGLISH }}} -->
        <para>Nesten hver eneste av delkommandoene til 
          <command>svnlook</command> kan operere p&#229; enten et revisjons- 
          eller transaksjonstre og skrive ut informasjon om selve treet, 
          eller hvordan det skiller seg ut fra den forrige revisjonen i 
          depotet.
          Du bruker valgene <option>--revision</option> og 
          <option>--transaction</option> for &#229; spesifisere henholdsvis 
          hvilken revisjon eller transaksjon som skal unders&#248;kes.
          Legg merke til at mens revisjonsnumre fremst&#229;r som naturlige 
          tall, er transaksjonsnavn alfanumeriske strenger.
          Husk at filsystemet bare tillater gjennomgang av transaksjoner 
          som enda ikke er lagt inn (transaksjoner som ikke har 
          resultert i en ny revisjon).
          De fleste depot vil ikke ha noen slike transaksjoner, fordi 
          transaksjoner vanligvis enten er lagt inn (som diskvalifiserer 
          dem fra visning) eller avbrutt og fjernet.</para>

        <!-- @ENGLISH {{{
        <para>In the absence of both the <option>-&#64738;-revision</option>
          and <option>-&#64738;-transaction</option> options,
          <command>svnlook</command> will examine the youngest (or
          <quote>HEAD</quote>) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <filename>/path/to/repos</filename>:</para>
        @ENGLISH }}} -->
        <para>Hvis b&#229;de valgene <option>--revision</option> og 
          <option>--transaction</option> mangler, vil 
          <command>svnlook</command> unders&#248;ke den yngste (eller 
          <quote>HEAD</quote>) revisjonen i depotet.
          S&#229; de f&#248;lgende to kommandoene gj&#248;r akkurat det samme n&#229;r 19 er 
          den yngste revisjonen i depotet som ligger i 
          <filename>/sti/til/depot</filename>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos -&#64738;-revision 19
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook info /sti/til/depot
$ svnlook info /sti/til/depot --revision 19
</screen>

        <!-- @ENGLISH {{{
        <para>The only exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options, and simply prints out the
          <literal>HEAD</literal> revision number.</para>
        @ENGLISH }}} -->
        <para>Det eneste unntaket fra disse reglene om delkommandoer er 
          <command>svnlook youngest</command>-delkommandoen, som ikke 
          tar noen valg, og bare skriver ut nummeret for 
          <literal>HEAD</literal>-revisjonen.</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook youngest /path/to/repos
19
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook youngest /sti/til/depot
19
</screen>
            
        <!-- @ENGLISH {{{
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <literal>info</literal> subcommand:</para>
        @ENGLISH }}} -->
        <para>Utdata fra <command>svnlook</command> er designet for &#229; 
          v&#230;re b&#229;de for menneske og maskin.
          Som et eksempel kan vi ta utdataene fra delkommandoen 
          <literal>info</literal>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>
        @ENGLISH }}} -->
        <!-- &#164; Fornorsk den --><screen>
$ svnlook info /sti/til/depot
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</screen>

        <!-- @ENGLISH {{{
        <para>The output of the <literal>info</literal> subcommand is
          defined as:</para>
        @ENGLISH }}} -->
        <para>Utdataene fra <literal>info</literal>-delkommandoen er 
          definert som:</para>

        <orderedlist>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The author, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Forfatteren, etterfulgt av linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The date, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Datoen, etterfulgt av linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The number of characters in the log message,
              followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Antallet tegn i loggmeldingen, etterfulgt av 
              linjeslutt.</para>
          </listitem>
          <listitem>
            <!-- @ENGLISH {{{
            <para>The log message itself, followed by a newline.</para>
            @ENGLISH }}} -->
            <para>Selve loggmeldingen, etterfulgt av linjeslutt.</para>
          </listitem>
        </orderedlist>

        <!-- @ENGLISH {{{
        <para>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&mdash;because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>
        @ENGLISH }}} -->
        <para>Disse utdataene er leselige for det menneskelige &#248;ye, det 
          vil si at elementer som datoen blir vist som tekst istedenfor 
          noe mer obskurt (som antall nanosekunder siden <!-- &#164; Henviser 
          dette til noe spesifikt, eller kan man la kreativiteten rulle? 
          --> <quote>Tasy Freeze</quote>-fyren kj&#248;rte forbi).
          Men disse utdataene er ogs&#229; lesbare for en datamaskin &#8212; fordi 
          loggmeldingen kan inneholde flere linjer og ha ubegrenset 
          lengde, skriver <command>svnlook</command> lengden p&#229; denne 
          meldingen f&#248;r selve meldingen.
          Dette tillater skript og andre programmer som bruker denne 
          kommandoen &#229; gj&#248;re intelligente valg ang&#229;ende loggmeldingen, 
          som hvor mye hukommelse som skal reserveres for meldingen, 
          eller i det minste hvor mange byte som m&#229; hoppes over n&#229;r 
          disse utdataene ikke er den siste datadelen i str&#248;mmen.</para>

        <!-- @ENGLISH {{{
        <para>Another common use of <command>svnlook</command> is to
          actually view the contents of a revision or transaction
          tree.  The <command>svnlook tree</command> command displays
          the directories and files in the requested tree.  If you
          supply the <option>-&#64738;-show-ids</option> option, it will also
          show the filesystem node revision IDs for each of those
          paths (which is generally of more use to developers than to
          users).</para>
        @ENGLISH }}} -->
        <para>En annen vanlig bruk av <command>svnlook</command> er &#229; 
          faktisk vise innholdet i et revisjons- eller transaksjonstre.
          Kommandoen <command>svnlook tree</command> viser katalogene og 
          filene i det forespurte treet.
          Hvis du angir valget <option>--show-ids</option>, vil den ogs&#229; 
          vise noderevisjons-ID for hver av disse stiene (som vanligvis 
          er mer nyttige for utviklere enn vanlige brukere).</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnlook tree /path/to/repos -&#64738;-show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnlook tree /sti/til/depot --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</screen>

        <!-- @ENGLISH {{{
        <para>Once you've seen the layout of directories and files in
          your tree, you can use commands like <command>svnlook
          cat</command>, <command>svnlook propget</command>, and
          <command>svnlook proplist</command> to dig into the details
          of those files and directories.</para>
        @ENGLISH }}} -->
        <para>N&#229;r du har sett p&#229; layouten for kataloger og filer i treet 
          ditt, kan du bruke kommandoer som <command>svnlook 
          cat</command>, <command>svnlook propget</command> og 
          <command>svnlook proplist</command> for &#229; grave dypere inn i 
          detaljene om disse filene og katalogene.</para>

        <!-- @ENGLISH {{{
        <para><command>svnlook</command> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <command>svnlook</command>,
          and the output of those subcommands:</para>
        @ENGLISH }}} -->
        <para><command>svnlook</command> kan utf&#248;re en rekke andre 
          foresp&#248;rsler, vise <!-- &#164; -->delsett av biter av informasjon 
          vi tidligere har nevnt, rapportere hvilke stier som ble 
          modifisert i en gitt revisjon eller transaksjon, vise tekst- 
          og egenskapsforskjeller gjort med filer og kataloger og s&#229; 
          videre.
          Det f&#248;lgende er en rask beskrivelse av den n&#229;v&#230;rende listen 
          med delkommandoer som <command>svnlook</command> aksepterer, 
          og utdataene fra disse delkommandoene:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's author.</para>
              @ENGLISH }}} -->
              <para>Skriv treets forfatter.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>cat</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the contents of a file in the tree.</para>
              @ENGLISH }}} -->
              <para>Skriv innholdet av en fil i treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List all files and directories that changed in the 
                tree.</para>
              @ENGLISH }}} -->
              <para>List alle filer og kataloger som forandret seg i 
                treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's datestamp.</para>
              @ENGLISH }}} -->
              <para>Skriv dato og klokkeslett for treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print unified diffs of changed files.</para>
              @ENGLISH }}} -->
              <para>Lag <foreignphrase>unified diff</foreignphrase> 
                (forskjellsfil) av forandrede filer.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</para>
              @ENGLISH }}} -->
              <para>List katalogene i treet som enten selv forandret 
                seg, eller der en <!-- &#164; -->fil under den forandret 
                seg.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>history</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</para>
              @ENGLISH }}} -->
              <para>Vis interessante punkter i historien for en 
                versjonert sti (steder der modifiseringer eller 
                kopieringer skjedde).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's author, datestamp, log message
                character count, and log message.</para>
              @ENGLISH }}} -->
              <para>Skriv treets forfatter, tidspunkt, antall tegn i 
                loggmeldingen og selve loggmeldingen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree's log message.</para>
              @ENGLISH }}} -->
              <para>Skriv treets loggmelding.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>propget</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the value of a property on a path in the
                tree.</para>
              @ENGLISH }}} -->
              <para>Skriv verdien for en egenskap p&#229; en sti i 
                treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>proplist</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the names and values of properties set on paths
                in the tree.</para>
              @ENGLISH }}} -->
              <para>Skriv navnene og verdiene av egenskapene satt p&#229; 
                stier i treet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</para>
              @ENGLISH }}} -->
              <para>Skriv en liste over treet, med valgfri visning av 
                filsystemets noderevisions-ID assosiert med hver 
                sti.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>uuid</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the repository's UUID&mdash;
                <emphasis>U</emphasis>niversal <emphasis>U</emphasis>nique
                <emphasis>ID</emphasis>entifier.</para>
              @ENGLISH }}} -->
              <para>Skriv depotets UUID &#8212; <emphasis>U</emphasis>niversal 
                <emphasis>U</emphasis>nique
                <emphasis>ID</emphasis>entifier.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>youngest</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Print the youngest revision number.</para>
              @ENGLISH }}} -->
              <para>Skriv det yngste revisjonsnummeret.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.2">
        <title>svnadmin</title>

        <!-- @ENGLISH {{{
        <para>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of
          <command>svnlook</command>:</para>
        @ENGLISH }}} -->
        <para>Programmet <command>svnadmin</command> er 
          depotadministratorens beste venn.
          Ved siden av &#229; gi muligheten til &#229; opprette Subversiondepot, 
          tillater dette programmet deg &#229; utf&#248;re flere 
          vedlikeholdsoperasjoner p&#229; disse depotene.
          Syntaksen p&#229; <command>svnadmin</command> er lik den i 
          <command>svnlook</command>:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
&hellip;
</screen>
        @ENGLISH }}} -->
        <!-- &#164; --><screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
&#8230;
</screen>

        <!-- @ENGLISH {{{
        <para>We've already mentioned <command>svnadmin</command>'s
          <literal>create</literal> subcommand (see <xref
          linkend="svn-ch-5-sect-2"/>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</para>
        @ENGLISH }}} -->
        <para>Vi har allerede nevnt delkommandoen 
          <literal>create</literal> i <command>svnadmin</command> (se 
          <xref linkend="svn-ch-5-sect-2"/>).
          De fleste andre vil vi g&#229; grundigere gjennom senere i dette 
          kapitlet.
          N&#229; n&#248;yer vi oss med &#229; ta en rask kikk p&#229; hva de forskjellige 
          delkommandoene tilbyr.</para>

        <variablelist>
          <varlistentry>
            <term><literal>create</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Create a new Subversion repository.</para>
              @ENGLISH }}} -->
              <para>Opprett et nytt Subversiondepot.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>deltify</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <literal>HEAD</literal> revision.</para>
              @ENGLISH }}} -->
              <para>G&#229; over et spesifisert revisjonsomr&#229;de og utf&#248;r 
                forl&#248;per-deltifisering p&#229; stiene som forandret seg i 
                disse revisjonene.
                Hvis ingen revisjoner er spesifisert, vil denne 
                kommandoen rett og slett bare deltifisere 
                <literal>HEAD</literal>-revisjonen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>dump</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Dump the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</para>
              @ENGLISH }}} -->
              <para>Dump innholdet av depotet, begrenset av et 
                spesifisert sett av revisjoner, i et portabelt 
                dumpformat.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>hotcopy</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Make a hot copy of a repository.  You can run
                this command at any time and make a safe copy of the
                repository, regardless if other processes are using
                the repository.</para>
              @ENGLISH }}} -->
              <para>Lag en <quote>varm kopi</quote> av et depot.
                Du kan kj&#248;re denne kommandoen til enhver tid og lage en 
                trygg kopi av depotet, selv om andre prosesser bruker 
                depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-dblogs</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with the
                repository.  This list includes all log
                files&mdash;those still in use by Subversion, as well
                as those no longer in use.</para>
              @ENGLISH }}} -->
              <para>(Bare Berkeley DB-depot.)
                List stiene for Berkeley DB-loggfiler assosiert med 
                depotet.
                Denne listen inkluderer alle loggfiler &#8213; de som fortsatt 
                brukes av Subversion, sammen med de som ikke lenger er i 
                bruk.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>list-unused-dblogs</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with, but no
                longer used by, the repository.  You may safely remove
                these log files from the repository layout, possibly
                archiving them for use in the event that you ever need
                to perform a catastrophic recovery of the
                repository.</para>
              @ENGLISH }}} -->
              <para>(Bare Berkeley DB-depot.)
                List stiene for Berkeley DB-loggfiler assosiert med, men 
                ikke lenger brukt av depotet.
                Du kan trygt fjerne disse loggfilene fra depotet og 
                muligens arkivere dem for senere bruk i tilfelle du en 
                gang f&#229;r bruk for katastrofe-gjenoppretting av 
                depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>load</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Load a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <literal>dump</literal> subcommand.</para>
              @ENGLISH }}} -->
              <para>Last et sett revisjoner inn i et depot fra en str&#248;m 
                av data som bruker det samme portable dumpformatet 
                generert av 
                <literal>dump</literal>-delkommandoen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>lstxns</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>List the names of uncommitted Subversion
                transactions that currently exist in the repository.</para>
              @ENGLISH }}} -->
              <para>List navnene p&#229; Subversiontransaksjonene som ikke er 
                lagt inn, men som eksisterer i depotet.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>recover</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred that prevented a process from cleanly
                shutting down its communication with the repository.</para>
              @ENGLISH }}} -->
              <para>Utf&#248;r gjenoppretting p&#229; et depot som trenger dette, 
                vanligvis etter at en fatal feil er oppst&#229;tt som 
                forhindret en prosess fra &#229; lukke kommunikasjonen med 
                depotet p&#229; en skikkelig m&#229;te.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>rmtxns</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <literal>lstxns</literal> subcommand).</para>
              @ENGLISH }}} -->
              <para>Fjern Subversiontransaksjoner fra depotet p&#229; en 
                renslig m&#229;te <!-- &#164; -->(kan bruke utdataene fra 
                <literal>lstxns</literal>-delkommandoen).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>setlog</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Replace the current value of the
                <literal>svn:log</literal> (commit log message)
                property on a given revision in the repository with a
                new value.</para>
              @ENGLISH }}} -->
              <para>Erstatt den n&#229;v&#230;rende verdien i 
                <literal>svn:log</literal>-egenskapen (loggmelding) for  
                en angitt revisjon i depotet med en ny verdi.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>verify</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</para>
              @ENGLISH }}} -->
              <para>Verifiser innholdet i et depot.
                Dette inkluderer blant annet sjekk av kontrollsummer til 
                de versjonerte dataene som er lagret i depotet.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.3">
        <title>svndumpfilter</title>

        <!-- @ENGLISH {{{
        <para>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <footnote>
            <para>That, by the way, is a <emphasis>feature</emphasis>,
              not a bug.</para>
          </footnote>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories&mdash;the
          Subversion repository dump format.</para>
        @ENGLISH }}} -->
        <para>Siden Subversion lagrer alt i et skjult databasesystem, er 
          det &#229; pr&#248;ve p&#229; manuelle forandringer ikke spesielt lurt, for 
          ikke &#229; si vanskelig.
          Og n&#229;r dataene er lagret i depotet, har ikke Subversion noen 
          enkel m&#229;te &#229; fjerne disse dataene.<footnote>
          <para>Og det er for&#248;vrig en innebygget 
            <emphasis>funksjonalitet</emphasis> og ikke en 
            feil.</para></footnote>
          Men det er ikke til &#229; komme forbi at det er noen ganger du vil 
          manipulere historien til depotet ditt.
          Det kan v&#230;re at du vil fjerne alle spor etter en fil som ble 
          lagt til ved en ulykke (og som av en eller annen grunn ikke 
          skal v&#230;re der).
          Eller du har kanskje flere prosjekter som deler et enkelt 
          depot, og du bestemmer deg for &#229; dele dem opp i sine egne 
          depot.
          For &#229; utf&#248;re oppgaver som dette, trenger administratorer en 
          mer h&#229;ndterlig og formbar representasjon av dataene i deres 
          egne depot &#8212; dumpformatet for Subversiondepot.</para>

        <!-- @ENGLISH {{{
        <para>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <command>svnadmin dump</command> command to generate the
          dump data, and <command>svnadmin load</command> to populate
          a new repository with it (see <xref
          linkend="svn-ch-5-sect-3.5"/>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dump file, it could take you a
          long, long time to manually inspect and modify it.</para>
        @ENGLISH }}} -->
        <para>Dumpformatet for Subversiondepot er en representasjon av 
          forandringene som du har gjort i dine versjonerte data over 
          tid, i et menneskelig lesbart format.
          Du bruker kommandoen <command>svnadmin dump</command> for &#229; 
          generere dumpdataene, og <command>svnadmin load</command> for 
          &#229; legge disse dataene inn i et nytt depot (se <xref 
          linkend="svn-ch-5-sect-3.5"/></para>).
          Den fine tingen med det menneskelesbare dumpformatet er at du 
          kan inspisere og modifisere det hvis du er forsiktig.
          Selvf&#248;lgelig, bakdelen er at hvis du har to &#229;r med 
          depotaktivitet pakket inn i en stor dumpfil, vil det ta deg 
          lang, lang tid &#229; manuelt inspisere og modifisere den.

        <!-- @ENGLISH {{{
        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality&mdash;the ability to quickly and easily modify
          that dump data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</para>
        @ENGLISH }}} -->
        <para>Selv om det ikke vil v&#230;re det vanligste verkt&#248;yet til bruk 
          for depotadministratoren, git <command>svndumpfilter</command> 
          en veldig spesiell type nyttig funksjonalitet &#8212; muligheten til 
          &#229; raskt og enkelt modifisere disse dumpdataene bet &#229; fungere 
          som et stibasert filter.
          Du gir programmet ganske enkelt en liste over stier som du vil 
          beholde, eller en liste med stier som du vil fjerne, og sender 
          deretter dumpdataene fra depotet via et r&#248;r gjennom dette 
          filteret.
          Resultatet er en modifisert str&#248;m av dumpdata som kun 
          inneholder de versjonerte stiene som du (eksplisitt eller 
          implisitt) ba om.</para>

        <!-- @ENGLISH {{{
        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>
        @ENGLISH }}} -->
        <para>Syntaksen for <command>svndumpfilter</command> er som 
          f&#248;lger:</para>

        <!-- &#164; -->
        <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</screen>

        <!-- @ENGLISH {{{
        <para>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</para>
        @ENGLISH }}} -->
        <para>Her er det bare to interessante delkommandoer.
          De gir deg valget mellom eksplisitt eller implisitt 
          inkludering av stier i str&#248;mmen:</para>

        <variablelist>
          <varlistentry>
            <term><literal>exclude</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Filter out a set of paths from the dump data
                stream.</para>
              @ENGLISH }}} -->
              <para>Filtrer bort et sett med stier fra 
                dumpdatastr&#248;mmen.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>include</literal></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Allow only the requested set of paths to pass
                through the dump data stream.</para>
              @ENGLISH }}} -->
              <para>Tillat bare de angitte stiene &#229; slippe gjennom 
                dumpdatastr&#248;mmen.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <!-- @ENGLISH {{{
        <para>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <xref
          linkend="svn-ch-5-sect-6.1"/>) the process of deciding how to
          choose a layout for the data in your
          repositories&mdash;using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</para>
        @ENGLISH }}} -->
        <para>La oss se p&#229; et realistisk eksempel p&#229; hvordan du vil 
          bruke dette programmet.
          Vi diskuterer en annen plass (se <xref 
          linkend="svn-ch-5-sect-6.1"/>) prosessen med &#229; bestemme deg 
          for hvordan dataene i depotene dine skal legges opp &#8212; om du 
          vil bruke ett depot for hvert prosjekt eller kombinere dem, 
          hvordan du arrangerer ting innenfor depotet og s&#229; videre.
          Men noen ganger etter at nye revisjoner begynner &#229; komme inn, 
          tenker du p&#229; nytt over layouten og vil gj&#248;re noen 
          forandringer.
          En vanlig forandring er &#229; bestemme seg for &#229; flytte flere 
          prosjekter som deler et enkelt depot inn i separate depot for 
          hvert prosjekt.</para>

        <!-- @ENGLISH {{{
        <para>Our imaginary repository contains three projects:
          <literal>calc</literal>, <literal>calendar</literal>, and
          <literal>spreadsheet</literal>.  They have been living
          side-by-side in a layout like this:</para>
        @ENGLISH }}} -->
        <para>V&#229;rt hypotetiske depot inneholder tre prosjekter:
          <!-- &#164; F&#229;r se om disse navnene blir fornorsket p&#229; et eller 
          annen tidspunkt. --><literal>calc</literal>, 
          <literal>calendar</literal> og <literal>spreadsheet</literal>.
        De har levd ved siden av hverandre som f&#248;lger:</para>

        <screen>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</screen>

        <!-- @ENGLISH {{{
        <para>To get these three projects into their own repositories,
          we first dump the whole repository:</para>
        @ENGLISH }}} -->
        <para>For &#229; f&#229; disse tre prosjektene inn i deres egne depot, 
          dumper vi f&#248;rst hele depotet:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&#8230;
$
</screen>

        <!-- @ENGLISH {{{
        <para>Next, run that dump file through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dump files:</para>
        @ENGLISH }}} -->
        <para>S&#229; kj&#248;rer vi denne dumpfilen gjennom filteret og for hver 
          gang inkluderer vi bare en av katalogene p&#229; toppniv&#229;, noe som 
          resulterer i tre nye dumpfiler:</para>

        <!-- @ENGLISH {{{
        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&hellip;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&#8230;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&#8230;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&#8230;
$
</screen>

        <!-- @ENGLISH {{{
        <para>At this point, you have to make a decision.  Each of
          your dump files will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <literal>calc</literal>
          project, that repository would still have a top-level
          directory named <filename>calc</filename>.  If you want
          your <filename>trunk</filename>, <filename>tags</filename>,
          and <filename>branches</filename> directories to live in the
          root of your repository, you might wish to edit your
          dump files, tweaking the <literal>Node-path</literal> and
          <literal>Copyfrom-path</literal> headers to no longer have
          that first <filename>calc/</filename> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <filename>calc</filename> directory.  It will look
          something like:</para>
        @ENGLISH }}} -->
        <para>P&#229; dette punktet m&#229; du ta en avgj&#248;relse.
          Hver av dumpfilene fine vil lage et gyldig depot, men vil 
          gjenskape stiene n&#248;yaktig som de var i det opprinnelige 
          depotet.
          Dette betyr at selv om du vil ha et depot kun for 
          <literal>calc</literal>-prosjektet, vil dette depotet fortsatt 
          ha en toppkatalog kalt <filename>calc</filename>.
          Hvis du vil at katalogene <filename>trunk</filename>, 
          <filename>tags</filename> og branches<filename> skal v&#230;re i 
          roten av depotet, vil du kanskje &#248;nske &#229; redigere dumpfilene 
          og forandre </filename>Node-path<literal> og 
          </literal>Copyfrom-path<literal> i headerne s&#229; de ikke lengre 
          inneholder denne </literal>calc/<filename>-komponenten i 
          stien.
          I tillegg &#248;nsker du &#229; fjerne seksjonen i dumpdataene som 
          oppretter </filename>calc<filename>-katalogen.
          Det vil se ut omtrent som dette:</filename></para>

        <screen>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</screen>

        <warning>
          <!-- @ENGLISH {{{
          <para>If you do plan on manually editing the dump file to
            remove a top-level directory, make sure that your editor is
            not set to automatically convert end-lines to the native
            format (e.g. \r\n to \n) as the content will then not agree
            with the metadata and this will render the dump file
            useless.</para>
          @ENGLISH }}} -->
          <para>Hvis du planlegger &#229; redigere dumpfilen manuelt for &#229; 
            fjerne en toppkatalog, v&#230;r sikker p&#229; at tekstbehandleren din 
            ikke er satt til &#229; automatisk konvertere linjeslutt til det 
            lokale formatet (det vil si \r\n til \n).
            Dette vil f&#248;re til at innholdet ikke vil samsvare med 
            metadataene og dumpfilen vil dermed bli ubrukelig.</para>
        </warning>

        <!-- @ENGLISH {{{
        <para>All that remains now is to create your three new
          repositories, and load each dump file into the right
          repository:</para>
        @ENGLISH }}} -->
        <para>Alt som gjenst&#229;r n&#229; er &#229; opprette dine tre nye depot og 
          laste hver dumpfil inn i det riktige depotet:</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&hellip;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&hellip;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&hellip;
$
</screen>
        @ENGLISH }}} -->
        <screen>
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&#8230;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&#8230;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&#8230;
$
</screen>

        <!-- @ENGLISH {{{
        <para>Both of <command>svndumpfilter</command>'s subcommands
          accept options for deciding how to deal with
          <quote>empty</quote> revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <command>svndumpfilter</command> provides
          the following command-line options:</para>
        @ENGLISH }}} -->
        <para>Begge delkommandoene til <command>svndumpfilter</command> 
          godtar valg for &#229; bestemme hva de skal gj&#248;re med 
          <quote>tomme</quote> revisjoner.
          Hvis en gitt revisjon bare inneholdt forandringer i stier som 
          ble filtrert bort kan denne revisjonen som n&#229; er tom bli 
          betraktet som uinteressant eller til og med u&#248;nsket.
          S&#229; for &#229; gi brukeren kontroll over hva som skal gj&#248;res med 
          disse revisjonene, har <command>svndumpfilter</command> disse 
          kommandolinjevalgene:</para>

        <variablelist>
          <varlistentry>
            <term><option>--drop-empty-revs</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>Do not generate empty revisions at all&mdash;just
                omit them.</para>
              @ENGLISH }}} -->
              <para>Ikke lag tomme revisjoner i det hele tatt &#8212; utelat 
                dem.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--renumber-revs</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>If empty revisions are dropped (using the
                <option>-&#64738;-drop-empty-revs</option> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</para>
              @ENGLISH }}} -->
              <para>Hvis tomme revisjoner er droppet (ved bruk av valget 
                <option>--drop-empty-revs</option>), forandres 
                revisjonsnumrene p&#229; de gjenv&#230;rende revisjonene s&#229; det 
                ikke blir mellomrom i den numeriske sekvensen.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><option>--preserve-revprops</option></term>
            <listitem>
              <!-- @ENGLISH {{{
              <para>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <command>svndumpfilter</command>.</para>
              @ENGLISH }}} -->
              <para>Hvis tomme revisjoner ikke droppes, ta vare p&#229; 
                revisjonsegenskaper (loggmelding, forfatter, dato, 
                egendefinerte egenskaper og s&#229; videre) for disse tomme 
                revisjonene.
                Eller vil tomme revisjoner bare inneholde det originale 
                tidspunktet og en generert loggmelding som indikerer at 
                denne revisjonen ble t&#248;mt av 
                <command>svndumpfilter</command>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        
        <!-- @ENGLISH {{{
        <para>While <command>svndumpfilter</command> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dump file are specified with or without leading slashes.
          You'll want to look at the <literal>Node-path</literal> and
          <literal>Copyfrom-path</literal> headers.</para>
        @ENGLISH }}} -->
        <para>Selv om <command>svndumpfilter</command> kan v&#230;re veldig 
          nyttig og sparer masse tid, er det dessverre et par ting &#229; 
          passe p&#229;.
          For det f&#248;rste er dette verkt&#248;yet overf&#248;lsom for <!-- &#164; Finn 
          et mer brukervennlig ord for &#171;semantikk&#187; -->sti-semantikk.
          Legg merke til om stiene i dumpfilen er spesifisert med eller 
          uten skr&#229;streker i starten.
          Dette vil du se i <literal>Node-path</literal> og 
          <literal>Copyfrom-path</literal> i headerne.</para>

        <!-- @ENGLISH {{{
        <screen>
&hellip;
Node-path: spreadsheet/Makefile
&hellip;
</screen>
        @ENGLISH }}} -->
        <screen>
&#8230;
Node-path: spreadsheet/Makefile
&#8230;
</screen>

        <!-- @ENGLISH {{{
        <para>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <command>svndumpfilter include</command> and
          <command>svndumpfilter exclude</command> (and if they don't,
          you shouldn't).  Further, if your dump file has an inconsistent
          usage of leading slashes for some reason,
          <footnote>
            <para>While <command>svnadmin dump</command> has a
              consistent leading slash policy&mdash;to not include
              them&mdash;other programs which generate dump data might
              not be so consistent.</para>
          </footnote>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</para>
        @ENGLISH }}} -->
        <para>Hvis stiene har innledende skr&#229;streker, skal du ogs&#229; ha 
          innledende skr&#229;streker i stiene som du leverer til 
          <command>svndumpfilter include</command> og 
          <command>svndumpfilter exclude</command> (og hvis de ikke har 
          det, skal du ikke gj&#248;re det).
          Videre, hvis dumpfilen din har inkonsekvent bruk av innledende 
          skr&#229;streker av en eller annen grunn,<footnote>
          <para>Selv om <command>svnadmin dump</command> har en 
            konsekvent regel om innledende skr&#229;streker &#8212; &#229; ikke 
            inkludere dme &#8212; kan det v&#230;re at andre programmer som 
            genererer dumpdata ikke er like 
            konsekvente.</para></footnote>
          b&#248;r du normalisere disse stiene s&#229; de alle enten har eller 
          mangler innledende skr&#229;streker.</para>

        <!-- @ENGLISH {{{
        <para>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <command>svndumpfilter</command> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <command>svndumpfilter</command> needs to still show the
          addition of the new path&mdash;including the contents of any
          files created by the copy&mdash;and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</para>
        @ENGLISH }}} -->
        <para>I tillegg kan kopierte stier gi deg litt tr&#248;bbel.
          Subversion st&#248;tter kopioperasjoner i depotet, der en ny sti 
          blir opprettet ved &#229; kopiere en allerede eksisterende sti.
          Det er mulig at p&#229; et eller annet punkt i livsl&#248;pet til 
          depotet blir en fil eller katalog kopiert fra en plass som 
          <command>svndumpfilter</command> utelater, til en plass som 
          den inkluderer.
          For &#229; gj&#248;re dumpdataene <!-- &#164; self-sufficient -->selvforsynt, 
          m&#229; <command>svndumpfilter</command> vise tilleggingen av den 
          nye stien &#8212; inkludert innholdet av alle filer opprettet av 
          kopieringen &#8212; og ikke vise denne tilleggingen som en kopiering 
          fra en kilde som ikke eksisterer i den filtrerte 
          dumpdatastr&#248;mmen.
          Men fordi dumpformatet i Subversion bare viser hva som ble 
          forandret i hver revisjon, kan det v&#230;re at innholdet i kilden 
          for kopien ikke er <!-- &#164; readily --> tilgjengelig.
          Hvis du har mistanke om at du har denslags kopier i depotet 
          ditt, vil du kanskje tenke gjennom valget ditt av 
          inkluderte/utelatte stier p&#229; nytt.</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.4">
        <title>svnshell.py</title>

        <!-- @ENGLISH {{{
        <para>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <command>svnshell.py</command> Python script (located in
          <filename>tools/examples/</filename> in the source tree)
          uses Subversion's language bindings (so you must have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</para>
        @ENGLISH }}} -->
        <para>Kildekodetreet til Subversion kommer ogs&#229; med et 
          skall-lignende grensesnitt til depotet.
          Python-skriptet <command>svnshell.py</command> (lokalisert i 
          <filename>tools/examples/</filename> i kildekodetreet) bruker 
          Subversions <!-- &#164; Det h&#818;&#248;&#818;r&#818;e&#818;s&#818; riktig ut, men er det det? 
          -->spr&#229;kbindinger (s&#229; du m&#229; ha disse skikkelig kompilert og 
          installert for at dette skriptet skal virke) for &#229; koble seg 
          til depot- og filsystembibliotekene.</para>

        <!-- @ENGLISH {{{
        <para>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          <quote>positioned</quote> in the root directory of the
          <literal>HEAD</literal> revision of the repository, and
          presented with a command prompt.  You can use the
          <literal>help</literal> command at any time to display a
          list of available commands and what they do.</para>
        @ENGLISH }}} -->
        <para>N&#229;r det er startet, oppf&#248;rer programmet som likt et skall 
          og lar deg bla gjennom de forskjellige katalogene i depotet 
          ditt.
          I starten er du <quote>plassert</quote> i rotkatalogen for 
          <literal>HEAD</literal>-revisjonen i depotet, og du f&#229;r en 
          kommandolinje.
          Du kan bruke <literal>help</literal>-kommandoen til enhver tid 
          for &#229; vise en liste over tilgjengelige kommandoer og hva de 
          gj&#248;r.</para>

        <!-- @ENGLISH {{{
        <screen>
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>
        @ENGLISH }}} -->
        <!-- &#164; Den der b&#248;r virkelig fornorskes, men det tar vi seinere. 
        Eller kan vi det? Det er jo ikke noe i18n-opplegg p&#229; svnshell.py 
        for &#248;yeblikket. Hm. --><screen>
$ svnshell.py /sti/til/depot
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</screen>

        <!-- @ENGLISH {{{
        <para>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&mdash;using the <literal>cd</literal> command.
          At all times, the command prompt will show you what revision
          (prefixed by <literal>rev:</literal>) or transaction
          (prefixed by <literal>txn:</literal>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <literal>setrev</literal> and
          <literal>settxn</literal> commands, respectively.  As in a
          Unix shell, you can use the <literal>ls</literal> command to
          display the contents of the current directory, and you can
          use the <literal>cat</literal> command to display the
          contents of a file.</para>
        @ENGLISH }}} -->
        <para>Navigering i katalogstrukturen til depotet ditt gj&#248;res p&#229; 
          samme m&#229;ten som du gj&#248;r i et vanlig Unix- eller Windowsskall &#8212; 
          ved &#229; bruke kommandoen <literal>cd</literal>.
          Kommandolinjeprompten vil til enhver tid vise deg hvilken 
          revisjon (inneholder forstavelsen <literal>rev:</literal>) 
          eller transaksjon (inneholder forstavelsen 
          <literal>txn:</literal>) du unders&#248;ker for &#248;yeblikket, og 
          stiplasseringen i denne revisjonen eller transaksjonen.
          Du kan forandre din n&#229;v&#230;rende revisjon eller transaksjon med 
          henholdsvis <literal>setrev</literal>- og 
          <literal>settxn</literal>-kommandoen.
          Som i et Unixskall kan du bruke kommandoen 
          <literal>ls</literal> for &#229; vise innholdet av den n&#229;v&#230;rende 
          katalogen, og du kan bruke <literal>cat</literal>-kommandoen 
          for &#229; vise innholdet av en fil.</para>

        <example id="svn-ch-8-sect-3.1.3-ex-1">
          <!-- @ENGLISH {{{
          <title>Using svnshell to Navigate the Repository</title>
          @ENGLISH }}} -->
          <title>Bruk av svnshell for &#229; navigere i depotet</title>

          <screen>
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</screen>
        </example>

        <!-- @ENGLISH {{{
        <para>As you can see in the previous example, multiple
          commands may be specified at a single command prompt,
          separated by a semicolon.  Also, the shell understands the
          notions of relative and absolute paths, and will properly
          handle the <literal>.</literal> and
          <literal>..</literal> special path components.</para>
        @ENGLISH }}} -->
        <para>Som du ser i det forrige eksempelet kan flere kommandoer 
          bli spesifisert p&#229; en enkelt kommandolinje, separert med et 
          semikolon.
          I tillegg forst&#229;r skallet <!-- &#164; notions of --> relative og 
          absolutte stier og vil behandle stikomponentene 
          <literal>.</literal> og <literal>..</literal> p&#229; en skikkelig 
          m&#229;te.</para>

        <!-- @ENGLISH {{{
        <para>The <literal>youngest</literal> command displays the
          youngest revision.  This is useful for determining the range
          of valid revisions you can use as arguments to the
          <literal>setrev</literal> command&mdash;you are allowed to
          browse all the revisions (recalling that they are named with
          integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <command>lstxns</command> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <command>svnadmin lstxns</command> returns, and the same
          list that is valid for use with <command>svnlook</command>'s
          <option>-&#64738;-transaction</option> option.</para>
        @ENGLISH }}} -->
        <para><literal>youngest</literal>-kommandoen viser den yngste 
          revisjonen.
          Dette er nyttig for &#229; ansl&#229; omr&#229;det av gyldige revisjoner du 
          kan bruke som argumenter til 
          <literal>setrev</literal>-kommandoen &#8212; du har lov til &#229; bla 
          gjennom alle revisjonene (husk at de benevnes med heltall) 
          mellom 0 til og med den yngste.
          &#197; ansl&#229; de gyldige transaksjonene som du kan bla gjennom er 
          ikke like <!-- &#164; &#171;Nydelig&#187; blir fors&#229;vidt ikke helt korrekt. 
          Sjekkes ut n&#229;r jeg kommer p&#229; en maskin med skikkelig python. 
          -->enkelt.
          Bruk <command>lstxns</command>-kommandoen for &#229; liste 
          transaksjonene som du kan bla gjennom.
          Listen med transaksjoner som du kan bla gjennom er den samme 
          som <command>svnadmin lstxns</command> returnerer, og den 
          samme listen som er gyldig for bruk sammen med 
          <command>svnlook</command>-valget 
          <option>--transaction</option>.</para>

        <!-- @ENGLISH {{{
        <para>Once you've finished using the shell, you can exit
          cleanly by using the <command>exit</command> command.
          Alternatively, you can supply an end-of-file
          character&mdash;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</para>
        @ENGLISH }}} -->
        <para>N&#229;r du er ferdig med &#229; bruke skallet, kan du trygt 
          avslutte ved &#229; bruke <command>exit</command>-kommandoen.
          Alternativt kan du skrive et filslutt-tegn &#8212; Ctrl-d (<!-- &#164; 
          &#171;though&#187; &#8594; &#171;selv om&#187;. svnshell.py sjekker for EOF i linje 46. 
          Betyr det at CTRL-d brukes uansett, eller varierer det med 
          CTRL-z ? -->selv om noen Win32-distribusjoner av Python bruker 
          Windows-varianten Ctrl-z istedenfor).</para>

      </sect3>

      <sect3 id="svn-ch-5-sect-3.1.5">
        <!-- @ENGLISH {{{
        <title>Berkeley DB Utilities</title>
        @ENGLISH }}} -->
        <title>Berkeley DB-verkt&#248;y</title>

        <!-- @ENGLISH {{{
        <para>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools (you can see the documentation for these tools at
          SleepyCat's website, <systemitem
          class="url">http://www.sleepycat.com/</systemitem>).</para>
        @ENGLISH }}} -->
        <para>Hvis du bruker et Berkeley DB-depot, vil alle strukturer 
          og data v&#230;re i et sett med databasetabeller i katalogen 
          <filename>db</filename> i depotet ditt.
          Denne underkatalogen er en vanlig Berkeley DB milj&#248;katalog, og 
          kan derfor bli brukt i forbindelse med alle Berkeley 
          databaseverkt&#248;y (du kan se dokumentasjonen for disse 
          verkt&#248;yene p&#229; SleepyCats hjemmeside, <systemitem 
          class="url">http://www.sleepycat.com/</systemitem>).</para>

        <!-- @ENGLISH {{{
        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> command, and <command>svnadmin
          recover</command> reflects the common use-cases of the
          <command>db_recover</command> utility.</para>
        @ENGLISH }}} -->
        <para>For daglig Subversionbruk er disse verkt&#248;yene un&#248;dvendige.
          Mesteparten av funksjonaliteten som vanligvis er n&#248;dvendig for 
          Subversiondepot er blitt duplisert i 
          <command>svnadmin</command>-verkt&#248;yet.
          For eksempel, <command>svnadmin list-unused-dblogs</command> 
          og <command>svnadmin list-dblogs</command> utf&#248;rer en <!-- &#164; 
          subset -->del av hva Berkeley-kommandoen 
          <command>db_archive</command> gj&#248;r, og <command>svnadmin 
          recover</command> gjenspeiler de vanlige <!-- &#164; use-cases 
          -->bruksm&#229;ter for 
          <command>db_recover</command>-programmet.</para>
            
        <!-- @ENGLISH {{{
        <para>There are still a few Berkeley DB utilities that you
          might find useful.  The <command>db_dump</command> and
          <command>db_load</command> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>
        @ENGLISH }}} -->
        <para>Det er fortsatt noen f&#229; Berkeley DB-programmer som du kan 
          finne nyttige.
          Programmene <command>db_dump</command> og 
          <command>db_load</command> skriver og leser <!-- &#164; Blir det 
          rar setning hvis h. st&#229;r her? -->henholdsvis et tilpasset 
          filformat som beskriver n&#248;kler og verdier i en Berkeley 
          DB-database.
          Siden Berkeley DB-databaser ikke er portable p&#229; kryss av 
          maskinarkitekturer, er dette formatet en nyttig m&#229;te &#229; 
          overf&#248;re disse databasene fra maskin til maskin, uavhengig av 
          arkitektur eller operativsystem.
          I tillegg kan programmet <command>db_stat</command> gi deg 
          nyttig informasjon om statusen til Berkeley DB-milj&#248;et, 
          inkludert detaljert statistikk om undersystemer som tar seg av 
          l&#229;sing og lagring.</para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.2">
      <title>Repository Cleanup</title>
            
      <para>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <command>svnadmin</command> utility provides some helpful
        functionality to assist you in performing such tasks as</para>

      <itemizedlist>
        <listitem>
          <para>modifying commit log messages,</para>
        </listitem>
        <listitem>
          <para>removing dead transactions,</para>
        </listitem>
        <listitem>
          <para>recovering <quote>wedged</quote> repositories, and</para>
        </listitem>
        <listitem>
          <para>migrating repository contents to a different
            repository.</para>
        </listitem>
      </itemizedlist>

      <para>Perhaps the most commonly used of
        <command>svnadmin</command>'s subcommands is
        <literal>setlog</literal>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</para>

      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks; see <xref
        linkend="svn-ch-5-sect-2.1"/>) to accept changes to this log
        message after the commit is finished, then the user can
        <quote>fix</quote> her log message remotely using the
        <command>svn</command> program's <literal>propset</literal>
        command (see <xref linkend="svn-ch-9"/>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&mdash;except by an administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>
          
      <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      
      <para>The <command>svnadmin setlog</command> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&mdash;the
        <literal>pre-</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>

      <para>Another common use of <command>svnadmin</command> is to
        query the repository for outstanding&mdash;possibly
        dead&mdash;Subversion transactions.  In the event that a commit
        should fail, the transaction is usually cleaned up.  That is,
        the transaction itself is removed from the repository, and any
        data associated with (and only with) that transaction is
        removed as well.  Occasionally, though, a failure occurs in
        such a way that the cleanup of the transaction never happens.
        This could happen for several reasons: perhaps the client
        operation was inelegantly terminated by the user, or a network
        failure might have occurred in the middle of an operation, etc.
        Regardless of the reason, these dead transactions serve only
        to clutter the repository and consume resources.</para>

      <para>You can use <command>svnadmin</command>'s
        <literal>lstxns</literal> command to list the names of the
        currently outstanding transactions.</para>

      <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>

      <para>Each item in the resultant output can then be used with
        <command>svnlook</command> (and its
        <option>--transaction</option> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&mdash;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <command>svnadmin rmtxns</command>, which will perform the
        cleanup of the transaction.  In fact, the
        <literal>rmtxns</literal> subcommand can take its input
        directly from the output of <literal>lstxns</literal>!</para>

      <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>

      <para>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</para>

      <example id="svn-ch-5-sect-3.2-ex-1">
        <title>txn-info.sh (Reporting Outstanding Transactions)</title>

        <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info "${REPOS}" --transaction "${TXN}"
done
</programlisting>
      </example>

      <para>You can run the previous script using
        <command>/path/to/txn-info.sh /path/to/repos</command>.  The
        output is basically a concatenation of several chunks of
        <command>svnlook info</command> output (see <xref
        linkend="svn-ch-5-sect-3.1.1"/>), and will look something
        like:</para>

      <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>

      <para>Usually, if you see a dead transaction that has no log
        message attached to it, this is the result of a failed update
        (or update-like) operation.  These operations use Subversion
        transactions under the hood to mimic working copy state.
        Since they are never intended to be committed, Subversion
        doesn't require a log message for those transactions.
        Transactions that do have log messages attached are almost
        certainly failed commits of some sort.  Also, a transaction's
        datestamp can provide interesting information&mdash;for
        example, how likely is it that an operation begun nine months
        ago is still active?</para>

      <para>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&mdash;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&mdash;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.3">
      <title>Managing Disk Space</title>

        <para>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  If using a
          Berkeley DB repository, the primary storage mechanism is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.  This section is
          specific to Berkeley DB;  FSFS repositories have no extra
          data that be cleaned up or reclaimed.</para>

        <para>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the log files to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another&mdash;while the database files reflect
          at any given time some state, the log files contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files without any external procedures.  Any
          repositories created using an <command>svnadmin</command>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line which contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn-ch-5-sect-2.2"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&mdash;you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          log files:</para>

      <screen>
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</screen>

        <para>To keep the size of the repository as small as possible,
          Subversion uses <firstterm>deltification</firstterm> (or,
          <quote>deltified storage</quote>) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&mdash;rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, <quote>I look just like this other
          piece of data over here, except for the following couple of
          changes.</quote> Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable&mdash;namely,
          the contents of versioned files&mdash;is stored at a much
          smaller size than the original <quote>fulltext</quote>
          representation of that data.</para>

        <note>
          <para>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</para>
        </note>

    </sect2>
        
    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.4">
      <title>Repository Recovery</title>

      <para>As mentioned in <xref linkend="svn-ch-5-sect-1.3.1"/>, a
        Berkeley DB repository can sometimes be left in frozen state
        if not closed properly.  When this happens, an administrator
        needs to rewind the database back into a consistent
        state.</para>

      <para>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.</para>

      <para>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets <quote>wedged</quote>.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&mdash;which isn't going to happen).</para>

      <para>First, if this happens to your repository, don't panic.
        The Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <footnote>
          <para>E.g.: hard drive + huge electromagnet = disaster.</para>
        </footnote>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</para>

      <para>Secondly, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged</quote>.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
              
          <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the Subversion server.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <email>users@subversion.tigris.org</email>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.5">
      <title>Migrating a Repository</title>
    
      <para>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <command>svnadmin</command> subcommands:
        <literal>dump</literal> and <literal>load</literal>.</para>

      <para>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  Other
        reasons for dumping and loading might be to migrate a Berkeley
        DB repository to a new OS or CPU architecture, or to switch
        between Berkeley DB and FSFS back-ends.  The recommended
        course of action is relatively simple:</para>
  
      <orderedlist>
        <listitem>
          <para>Using your <emphasis>current</emphasis> version of
            <command>svnadmin</command>, dump your repositories to
            dump files.</para>
        </listitem>
        <listitem>
          <para>Upgrade to the new version of Subversion.</para>
        </listitem>
        <listitem>
          <para>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <emphasis>new</emphasis> <command>svnadmin</command>.</para>
        </listitem>
        <listitem>
          <para>Again using your <emphasis>new</emphasis>
            <command>svnadmin</command>, load your dump files into
            their respective, just-created repositories.</para>
        </listitem>
        <listitem>
          <para>Be sure to copy any customizations from your old
            repositories to the new ones, including
            <filename>DB_CONFIG</filename> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</para>
        </listitem>
        <listitem>
          <para>If the migration process made your repository
            accessible at a different URL (e.g. moved to a different
            computer, or is being accessed via a different schema),
            then you'll probably want to tell your users to run
            <command>svn switch --relocate</command> on their existing
            working copies.  See <xref
            linkend="svn-ch-9-sect-1.2-re-switch"/>.</para>
        </listitem>
      </orderedlist>

      <para><command>svnadmin dump</command> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</para>

      <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
* Dumped revision 25.
* Dumped revision 26.
</screen>

      <para>At the end of the process, you will have a single file
        (<filename>dumpfile</filename> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <command>svnadmin
        dump</command> is reading revision trees from the repository
        just like any other <quote>reader</quote> process would
        (<command>svn checkout</command>, for example.)  So it's safe
        to run this command at any time.</para>

      <para>The other subcommand in the pair, <command>svnadmin
        load</command>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&hellip;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>

      <para>Note that because <command>svnadmin</command> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <command>svnadmin</command> on each side of the pipe):</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>By default, the dump file will be quite large&mdash;much
        larger than the repository itself.  That's because every
        version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and nice
        if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file for
        longer-term storage, you'll likely want to save disk space by
        using the <option>--deltas</option> switch.  With this option,
        successive revisions of files will be output as compressed,
        binary differences&mdash;just as file revisions are stored in
        a repository.  This option is slower, but results in a
        dump file much closer in size to the original
        repository.</para>

      <para>We mentioned previously that <command>svnadmin
        dump</command> outputs a range of revisions.  Use the
        <option>--revision</option> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</para>

      <screen>
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</screen>

      <para>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <command>svnadmin dump</command>
        command.</para>

      <para>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <command>svnadmin dump</command> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</para>

      <para>However, you can change this default behavior.  If you add
        the <option>--incremental</option> option when you dump your
        repository, <command>svnadmin</command> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&mdash;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</para>

      <screen>
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</screen>

      <para>These dump files could be loaded into a new repository with
        the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <literal>post-commit</literal> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <command>svnadmin</command>'s
        <literal>dump</literal> and <literal>load</literal> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</para>

      <para>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <option>--parent-dir</option> option of <command>svnadmin
        load</command>, you can specify a new virtual root directory
        for the load process.  That means if you have dump files for
        three repositories, say <filename>calc-dumpfile</filename>,
        <filename>cal-dumpfile</filename>, and
        <filename>ss-dumpfile</filename>, you can first create a new
        repository to hold them all:</para>

      <screen>
$ svnadmin create /path/to/projects
$
</screen>

      <para>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</para>

      <screen>
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</screen>

      <para>Lastly, load the individual dump files into their
        respective locations in the new repository:</para>

      <screen>
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&hellip;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&hellip;
$
</screen>

      <para>We'll mention one final way to use the Subversion
        repository dump format&mdash;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <footnote>
          <para>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</para>
        </footnote>
        it should be relatively easy to describe generic sets of
        changes&mdash;each of which should be treated as a new
        revision&mdash;using this file format.  In fact, the
        <command>cvs2svn.py</command> utility (see <xref
        linkend="svn-ap-a-sect-11"/>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        moved in a Subversion repository.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-3.6">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&mdash;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&mdash;how to make backup copies of your repository
        data.</para>

      <para>There are generally two types of backup methods available
        for Subversion repository administrators&mdash;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <command>svnadmin dump --incremental</command> to
        perform an incremental backup (see <xref
        linkend="svn-ch-5-sect-3.5"/>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</para>

      <para>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        either Berkeley database or FSFS environment).  Now, unless
        you temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</para>

      <para>In the case of Berkeley DB, Sleepycat documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And a similar ordering exists
        for FSFS data.  Better still, you don't have to implement
        these algorithms yourself, because the Subversion development
        team has already done so.  The
        <command>hot-backup.py</command> script is found in the
        <filename>tools/backup/</filename> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <command>hot-backup.py</command>&mdash;which is
        really just a more intelligent wrapper around the
        <command>svnadmin hotcopy</command> command&mdash;will perform
        the necessary steps for backing up your live
        repository&mdash;without requiring that you bar public
        repository access at all&mdash;and then will clean out the
        dead Berkeley log files from your live repository.</para>

      <para>Even if you also have an incremental backup, you might
        want to run this program on a regular basis.  For example, you
        might consider adding <command>hot-backup.py</command> to a
        program scheduler (such as <command>cron</command> on Unix
        systems).  Or, if you prefer fine-grained backup solutions,
        you could have your post-commit hook script call
        <command>hot-backup.py</command> (see <xref
        linkend="svn-ch-5-sect-2.1" />), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <filename>hooks/post-commit</filename> script in your live
        repository directory:</para>

      <programlisting>
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</programlisting>

      <para>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</para>

      <para>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        complete repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&mdash;and
        restoration from&mdash;incremental backups takes longer, as
        each commit is effectively replayed into either the dump file
        or the repository.</para>

      <para>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <footnote>
          <para><command>svnadmin setlog</command> can be called in a
            way that bypasses the hook interface altogether.</para>
        </footnote>  
        And since you can change revision properties without respect
        to chronological order&mdash;you can change any revision's
        properties at any time&mdash;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data&mdash;protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <footnote>
          <para>You know&mdash;the collective term for all of her
            <quote>fickle fingers</quote>.</para>
        </footnote>
        it should certainly help you recover from those trying 
        times.</para>

    </sect2>
  </sect1>


  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-6">
    <title>Adding Projects</title>

    <para>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <command>svn</command>
      client program's <literal>import</literal> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.1">
      <title>Choosing a Repository Layout</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By <quote>laying out</quote>
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</para>

      <para>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</para>

      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook scripts, one thing to routinely backup, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, and without losing any historical versioning
        information.</para>

      <para>The downside of using a single repository is that
        different projects may have different commit mailing lists or
        different authentication and authorization requirements.
        Also, remember that Subversion uses repository-global revision
        numbers.  Some folks don't like the fact that even though no
        changes have been made to their project lately, the youngest
        revision number for the repository keeps climbing because
        other projects are actively adding new revisions.</para>

      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>

      <para>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies in the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn-ch-4"/>), the Subversion
        community recommends that you choose a repository location for
        each <firstterm>project root</firstterm>&mdash;the
        <quote>top-most</quote> directory which contains data related
        to that project&mdash;and then create three subdirectories
        beneath that root: <filename>trunk</filename>, meaning the
        directory under which the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        <filename>tags</filename>, which is a directory of branches
        that are created, and perhaps destroyed, but never
        changed.</para>

      <para>For example, your repository might look like:</para>

      <screen>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &hellip;
</screen>

      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</para>

      <screen>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &hellip;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &hellip;
</screen>

      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&mdash;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-6.2">
      <title>Creating the Layout, and Importing Initial Data</title>
          
      <para>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <command>svn mkdir</command> command (see <xref
        linkend="svn-ch-9"/>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <command>svn
        import</command> command (see <xref
        linkend="svn-ch-3-sect-7.3"/>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</para>
            
      <screen>
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
&hellip;
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
&hellip;
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</screen>

      <para>You can verify the results of the import by running the
        <command>svn list</command> command:</para>

      <screen>
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
&hellip;
$
</screen>

      <para>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <command>svn import</command>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <command>svn add</command> and <command>svn
        commit</command> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <command>svn</command> client program, see <xref
        linkend="svn-ch-3"/>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 7:  SUMMARY                                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-7">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
vim: set ft=svnbook :
-->
