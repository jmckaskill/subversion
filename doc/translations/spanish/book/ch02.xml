<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<!-- Modeline para usuarios del editor vim
vim: set expandtab tabstop=2 shiftwidth=2 textwidth=78:
-->
<chapter id="svn-ch-2">
  <title>Conceptos Básicos</title>

  <simplesect>
    <para>Este capítulo es una introducción corta y casual a Subversion.
      Si es nuevo en el tema de control de versiones, este capítulo es
      definitivamente para usted. Empezamos con una discusión de conceptos
      generales en el control de versiones, avanzamos a las ideas específicas
      detras de Subversion, y mostramos algunos ejemplos simples de Subversion
      en acción.</para>
    
    <para>Aún cuando los ejemplos en este capítulo muestran a gente
      compartiendo colecciones de código fuente de programas, tenga en mente
      que Subversion puede manejar cualquier tipo de colección de
      archivos&mdash;no esta limitado a asistir a programadores de
      computadores.</para>
  </simplesect>
  
  
  <sect1 id="svn-ch-2-sect-1" > 
    <title>El Repositorio</title>  
    
    <para>Subversion es un sistema centralizado para compartir información.
      En su núcleo esta un repositorio, el cual es un almacén central de datos.
      El repositorio guarda información en forma de un 
      <firstterm>árbol de archivos</firstterm>&mdash;una jerarquía típica
      de archivos y directorios. Cualquier número de <firstterm>clientes</firstterm>
      se conectan al repositorio para luego leer o escribir a estos archivos.
      Al escribir los datos, un cliente pone a disposición de otros la información;
      Al leer datos, el cliente recibe información de otros.  
      La figura <xref linkend="svn-ch-2-dia-1"/> ilustra esto.</para>

    <figure id="svn-ch-2-dia-1">
      <title>Un sistema cliente/servidor típico</title>
      <graphic fileref="images/ch02dia1.png"/>
    </figure>
    
    <para>Entonces, por qué es esto interesante?. Hasta ahora, esto
      suena como la definición de un típico servidor de archivos.
      En efecto, el repositorio <emphasis>es</emphasis> una clase de
      servidor de archivos, pero no es del tipo usual. Lo que hace 
      especial al repositorio de Subversion es que <emphasis>recuerda
      cada cambio</emphasis> jamás escrito en el: cada cambio a cada
      archivo, e inclusive cambios al árbol de directorios mismo, tales
      como la adición, borrado y reubicación de archivos y directorios.</para>

    <para>Cuando un cliente lee datos del repositorio, normalmente ve
      sólo la ultima versión del árbol de archivos. Pero el cliente
      también tiene la habilidad de ver estados <emphasis>previos</emphasis>
      del sistema de archivos. Por ejemplo, un cliente puede hacer
      consultas históricas como, <quote>¿Qué contenía este directorio 
      el miércoles pasado?</quote> Este es el tipo de pregunta esencial
      en cualquier <firstterm>sistema de control de versiones</firstterm>:
      sistemas que estan diseñados para registrar y seguir cambios en
      datos a través del tiempo.
    </para>

  </sect1>

  <sect1 id="svn-ch-2-sect-2">
    <title>Modelos de Versionamiento</title>

    <para>La misión principal de un sistema de control de versiones
      es permitir la edición colaborativa de datos y el compartir los mismos.
      Sin embargo, diversos sistemas utilizan estrategias distintas para
      lograr esto.</para>
    
    <sect2 id="svn-ch-2-sect-2.1">
      <title>El Problema de Compartir Archivos</title>
      
      <para>Todos los sistemas de control de versiones tienen que resolver
        un problema fundamental: ¿Cómo permitira el sistema a los usuarios
        el compartir información, pero prevendrá el que accidentalmente se 
        pisen mutuamente los callos? Es muy sencillo para los usuarios el
        accidentalmente sobreescribir los cambios de los demás en el
        repositorio.</para>

      <para>Considere el escenario mostrado en <xref linkend="svn-ch-2-dia-2"/>.
        Supóngase que tenemos dos colaboradores, Harry y Sally. Cada uno de
        ellos decide editar el mismo archivo del repositorio al mismo tiempo.
        Si Harry guarda sus cambios al repositorio primero, es posible
        entonces que (unos momentos mas tarde) Sally accidentalmente
        los sobreescriba con su propia nueva versión del archivo. Si bien es
        cierto que la versión de Harry no esta perdida para siempre (porque el
        sistema recuerda cada cambio), cualquier cambio que Harry haya hecho
        <emphasis>no</emphasis> estará presente en la nueva versión de Sally
        del archivo porque ella nunca los cambios de Harry en primer lugar. El
        trabajo de Harry si está efectivamente perdido&mdash;o al menos
        ausente de la última versión del archivo&mdash;y probablemente por
        accidente. Esta es definitivamente una situación que queremos evitar!</para>

      <figure id="svn-ch-2-dia-2">
        <title>El problema a evitar</title>
        <graphic fileref="images/ch02dia2.png"/>
      </figure>

      </sect2>
    
    <sect2 id="svn-ch-2-sect-2.2">
      <title>La solución Bloqueo-Modificación-Desbloqueo</title>
      
      <para>Muchos sistemas de control de versiones utilizan un modelo de
        <firstterm>bloqueo-modificación-desbloqueo</firstterm> para atacar
        este problema. En un sistema como este, el repositorio permite que
        solo una persona cambie un archivo a la vez. Harry debe
        primero <quote>bloquear</quote> el archivo para luego empezar a
        hacerle cambios. Bloquear un archivo se parece mucho pedir prestado un
        libro de la biblioteca; si Harry ha bloqueado el archivo, entonces
        Sally no puede hacerle cambios. So ella intenta bloquear el archivo,
        el repositorio rechazara la petición. Todo lo que puede hacer es leer
        el archivo y esperar que Harry termine sus cambios y deshaga su
        bloqueo. Luego que Harry desbloquea el archivo, su turno termina y
        ahora Sally puede aprovechar su turno bloqueando y editando. La figura
        <xref linkend="svn-ch-2-dia-3"/> demuestra esta simple solución.</para>
      
      <figure id="svn-ch-2-dia-3">
        <title>La solucion bloqueo-modificación-desbloqueo</title>
        <graphic fileref="images/ch02dia3.png"/>
      </figure>
      
      <para>El problema con el modelo bloqueo-modificación-desbloqueo es que
        es un tanto restrictivo y a menudo se convierte en un obstáculo para
        los usuarios:</para>

      <itemizedlist>
        <listitem><para>
            <emphasis>Bloquear puede causar problemas administrativos.</emphasis>


            En ocasiones Harry bloqueara un archivo y lo olvidará. Mientras
            tanto, como Sally esta aun esperando para editar el archivo, sus
            manos estan atadas. Y luego Harry se va de vacaciones. Ahora Sally
            debe conseguir que un administrador deshaga el bloqueo de Harry.
            La situación termina causando muchas demoras innecesarias y
            perdida de tiempo.
            </para></listitem>
        
        <listitem><para>
            <emphasis>Bloquear puede causar serialización innecesaria.</emphasis>

            Qué sucede si Harry esta editando el inicio de un archivo de texto
            y Sally simplemente quiere editar el final del mismo archivo?
            Estos cambios no traslapan en absoluto. Ellos podrían editar el
            archivo simultaneamente y no resultaría en gran daño, asumiendo
            que los cambios fueran correctamente mezclados. No hay necesidad
            de que tomen turnos en esta situación.
            </para></listitem>
    
        <listitem><para>
            <emphasis>Bloquear puede causar una falsa sensación de seguridad.</emphasis>

            Digamos que Harry bloquea y edita el archivo A, mientras que
            Sally simultaneamente bloquea y edita el archivo B. Pero suponga
            que A y B dependen uno del otro y que los cambios hechos a cada
            uno son semánticamente incompatibles. Súbitamente A y B ya no
            funcionan juntos. El sistema de bloqueo fue impotente para
            prevenir el problema&mdash;sin embargo de algun modo ha provisto
            una falsa sensación de seguridad. Es facil para Harry y Sally
            imaginar que al bloquear archivos, cada uno esta empezando una
            tarea segura y aislada, lo cual los inhibe de discutir sus cambios
            incompatibles desde temprano.
            </para></listitem>
      </itemizedlist>

      </sect2>

    <sect2 id="svn-ch-2-sect-2.3">
      <title>La solución Copiar-Modificar-Mezclar</title>
      
      <para>Subversion, CVS y otros sistemas de control de versiones
        utilizan un modelo tipo
        <firstterm>copiar-modificar-mezclar</firstterm> como una alternativa
        al bloqueo. En este modelo, el cliente de cada usuario contacta al
        repositorio del proyecto y crea una <firstterm>copia de
          trabajo</firstterm> personal&mdash;una reflexión local de los
        archivos y directorios del repositorio. Los usuarios trabajan entonces
        en paralelo, modificando sus copias privadas. Finalmente, las copias
        privadas son mezcladas juntas en una nueva versión final. El sistema
        de control de versiones a menudo ayuda con la mezcla, pero al final un
        ser humano es responsable de hacer que suceda correctamente.
      </para>
      
      <para>He aquí un ejemplo. Digamos que Harry y Sally crean sendas copias
        de trabajo del mismo proyecto, copiadas del repositorio. Ellos
        trabajan concurrentemente y hacen cambios un mismo archivo A en sus
        copias. Sally guarda sus cambios al repositorio primero. Cuando Harry
        intenta guardar sus cambios mas tarde, el repositorio le informa que
        su archivo A esta <firstterm>desactualizado</firstterm>. En otras
        palabras, que el archivo A en el repositorio ha cambiado de algún modo
        desde que lo copio por última vez. Luego Harry le dice a su cliente
        que <firstterm>mezcle</firstterm> cualquier cambio nuevo del
        repositorio con su copia de trabajo del archivo A. Es probable que los
        cambios de Sally no traslapan con los suyos; así que una vez que tenga
        ambos juegos de cambios integrados, Harry guarda su copia de trabajo
        en el repositorio. Las figuras <xref
        linkend="svn-ch-2-dia-4"/> y <xref linkend="svn-ch-2-dia-5"/>
        muestran este proceso.</para>

      <figure id="svn-ch-2-dia-4">
        <title>La solución copiar-modificar-mezclar</title>
        <graphic fileref="images/ch02dia4.png"/>
      </figure>
      
      <figure id="svn-ch-2-dia-5">
        <title>La solución copiar-modificar-mezclar (continuación)</title>
        <graphic fileref="images/ch02dia5.png"/>
      </figure>

      <para>¿Pero que tal si los cambios de Sally <emphasis>sí</emphasis>
        traslapan con los de Harry? ¿Entonces qué? Esta situación se conoce
        como <firstterm>conflicto</firstterm> y usualmente no es un gran
        problema. Cuando Harry le pide a su cliente que mezcle los últimos
        cambios del repositorio en su copia de trabajo, su copia del archivo A
        es marcada de algún modo indicando que está en estado de conflicto: él
        podrá ver ambos sets de cambios conflictivos y manualmente escoger
        entre ellos. Nótese que el programa no puede autmáticamente resolver
        conflictos; sólo los humanos son capaces de entender y realizar las
        decisiones inteligentes necesarias. Una vez que Harry ha resuelto
        manualmente los cambios traslapados&mdash;posiblemente luego de
        discutirlo con Sally&mdash;él podra guardar con seguridad el archivo
        mezclado en el repositorio.</para>

      <para>La solución copiar-modificar-mezclar puede sonar un tanto caótica,
        pero en la práctica funciona extremadamente bien. Los usuarios pueden
        trabajar en paralelo, nunca esperandose el uno al otro. Cuando
        trabajan en los mismos archivos, sucede que la mayoría de sus cambios
        concurrentes no se traslapan en absoluto; los conflictos son poco
        frecuentes. El tiempo que toma resolver los conflictos es mucho menor
        al tiempo perdido por un sistema de bloqueos.</para>

      <para>Al final, todo se centra en un factor crítico: la comunicación
        entre los usuarios. Cuando los usuarios se comunican pobremente, los
        conflictos tanto sintácticos como semánticos aumentan. Ningún sistema
        puede forzar a los usuarios a comunicarse perfectamente, y ningún
        sistema puede detectar conflictos semánticos. Por consiguiente no
        tiene sentido el dejarse adormecer por la falsa promesa de que un
        sistema de bloqueos va de alguna manera a prevenir los conflictos; en
        la práctica, el bloqueo parece inhibir la productividad mas que
        nada.</para>
      
    </sect2>
    
  </sect1>
  
  <!-- Cómo svn implementa esta filosofía -->
  <sect1 id="svn-ch-2-sect-3">
    <title>Subversion en Acción</title>
    
    <para>Es tiempo de movernos de lo abstracto a lo concreto. En esta sección
      mostraremos ejemplos reales de Subversion siendo utilizado.</para>

    <sect2 id="svn-ch-2-sect-3.1">
      <title>Copias de Trabajo</title>
      
      <para>Ya ha leído acerca de copias de trabajo; ahora demostraremos como
        el cliente de Subversion las crea y utiliza.</para>
      
      <para>Una copia de trabajo de Subversion es un árbol de directorios
        ordinario en su sistema de archivos local, conteniendo una colección
        de archivos. Usted puede editar estos archivos del modo que prefiera y
        si se trata de archivos de código fuente, usted puede compilar su
        programa con ellos de la manera usual. Su copia de trabajo es su área
        de trabajo privada: Subversion nunca incorporará los cambios de otra
        gente, o pondrá a disposición de otros sus cambios hasta que usted le
        indique explícitamente que lo haga.</para>

      <para>Luego de que haya hecho algunos cambios a los archivos en su copia
        de trabajo y verificado que trabajan correctamente, Subversion provee
        comandos para <quote>publicar</quote> sus cambios para las demás
        personas trabajando con usted en su proyecto (guardándolos en el
        repositorio). Si las demás personas publican sus propios cambios,
        Subversion provee comandos para mezclar estos cambios en su directorio
        de trabajo (leyéndolos del repositorio).</para>

      <para>Una copia de trabajo también contiene algunos archivos extra,
        creados y mantenidos por Subversion para ayudarle a ejecutar estos
        comandos. En particular, cada directorio de su copia de trabajo
        contiene un subdirectorio llamado <filename>.svn</filename>, también
        conocido como el <firstterm>directorio administrativo</firstterm> de
        la copia de trabajo. Los archivos en cada directorio administrativo le
        ayudan a Subversion a reconocer qué archivos contienen cambios no
        publicados y qué archivos estan desactualizados con respecto al
        trabajo de otros.</para>
      
      <para>Un repositorio típico de Subversion a menudo contiene los archivos
        (o el código fuente) de varios proyectos; usualmente cada proyecto es
        un subdirectorio en el árbol del sistema de archivos del repositorio.
        En este arreglo, la copia de trabajo de un usuario usualmente
        corresponderá a un sub-árbol particular del repositorio.</para>
      
      <para>Por ejemplo, supónga que usted tiene un repositorio que contiene
        dos proyectos de software, <literal>paint</literal> y
        <literal>calc</literal>. Cada proyecto vive en su propio subdirectorio
        en la raíz, tal como se muestra en <xref
        linkend="svn-ch-2-dia-6"/>.</para>

      <figure id="svn-ch-2-dia-6">
        <title>El sistema de archivos del repositorio</title>
        <graphic fileref="images/ch02dia6.png"/>
      </figure>
      
      <!--TODO: buscar un mejor termino en castellano para explicar 'check
      out'-->
      <para>Para conseguir una copia de trabajo, usted debe primero ejecutar
        un <firstterm>check out</firstterm> de algún sub-árbol del
        repositorio. (El término en inglés puede sonar como que tiene algo que
        ver con bloquear o reservar recursos, pero esto no sucede; simplemente
        le crea una copia privada del proyecto). Por ejemplo, si usted hace un
        check out de <filename>/calc</filename>, obtendrá una copia de
        trabajo como esta:</para>

<screen>
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>


      <para>La lista de letras A indica que Subversion esta agregando un
        número de ítems a su copia de trabajo. Usted ahora tiene una copia
        personal del directorio <filename>/calc</filename> del repositorio,
        con una entrada adicional&mdash;<filename>.svn</filename>&mdash;la
        cual contiene la información extra que Subversion necesita, como se
        mencionó anteriormente.</para>

      <sidebar id="svn-ch-2-sidebar-1">
        <title>URLs del Repositorio</title>

        <para>A los repositorios de Subversion se puede acceder a través de
          diferentes métodos&mdash;en el disco local, o través de varios
          protocolos de red. Sin embargo, una ubicación de repositorio siempre
          es un URL. La tabla 2-1 describe como los diversos esquemas de URL
          se conectan con los distintos métodos de acceso.</para>

        <table id="svn-ch-2-table-1">
          <title>URLs de Acceso al Repositorio</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Esquema</entry>
                <entry>Método de Acceso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><literal>file:///</literal></entry>
                <entry>acceso directo al repositorio (en disco local)</entry>
              </row>
              <row>
                <entry><literal>http://</literal></entry>
                <entry>acceso via el protocolo WebDAV a un servidor
                  Apache que entiende de Subversion</entry>
              </row>
              <row>
                <entry><literal>https://</literal></entry>
                <entry>igual que <literal>http://</literal>, pero con
                  encriptación SSL.</entry>
              </row>
              <row>
                <entry><literal>svn://</literal></entry>
                <entry>acceso via un protocolo personalizado a un servidor
                  <literal>svnserve</literal>.</entry>
              </row>
              <row>
                <entry><literal>svn+ssh://</literal></entry>
                <entry>igual que <literal>svn://</literal>, pero a través de 
                  un túnel de SSH.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
 
        <para>En general, los URLs de Subversion utilizan la sintaxis
          estándar, permitiendo la especificación de nombres de servidores 
          y números de puerto como parte del URL. Recuerde que el método
          de acceso <literal>file:</literal> es válido sólo para ubicaciones
          en el mismo servidor donde corre el cliente&mdash;de hecho, se
          requiere por convención que la porción del URL con el nombre del 
          servidor este ausente o sea <literal>localhost</literal>:</para>

        <screen>
$ svn checkout file:///ruta/a/repositorio
&hellip;
$ svn checkout file://localhost/ruta/a/repositorio
&hellip;
</screen>

        <para>Además, los usuarios del esquema <literal>file:</literal> en
          plataformas Windows necesitarán usar una sintaxis
          <quote>estándar</quote> extraoficial para acceder  a repositorios
          que están en la misma máquina, pero en una unidad de disco distinta
          de la que el cliente este utilizando en el momento. Cualquiera de
          las dos siguientes sintaxis para rutas de URL funcionarán siendo
          <literal>X</literal> la unidad donde reside el repositorio:</para>

        <screen>
C:\> svn checkout file:///X:/ruta/a/repositorio
&hellip;
C:\> svn checkout "file:///X|/ruta/a/repositorio"
&hellip;
</screen>
 
        <para>En la segunda sintaxis, es necesario encerrar el URL en comillas
          para que la barra vertical no sea interpretada como un pipe.</para>

        <para>Nótese que un URL usa diagonales ordinarias aún cuando la forma
          de ruta nativa (no para URLs), en Windows utiliza diagonales
          invertidas.</para>

      </sidebar>

      <!--TODO: revisar para agregar notas del traductor para 'commit' y
      'check in' -->
      <para>Suponga que hace cambios a <filename>button.c</filename>. Puesto
        que el directorio <filename>.svn</filename> recuerda la fecha de
        modificación y contenido original del archivo, Subversion puede darse
        cuenta que ha cambiado el mismo. Sin embargo, Subversion no hace
        públicos sus cambios hasta que se lo mande explícitamente. El acto de
        publicar sus cambios es comúnmente conocido como 
        <firstterm>consignar</firstterm> (o <firstterm>registrar</firstterm>)
        los cambios al repositorio.</para>

      <para>Para publicar sus cambios a otros, usted puede utilizar el comando
        <command>commit</command> de Subversion:</para>
      <para>To publish your changes to others, you can use
        Subversion's <command>commit</command> command:</para>

<screen>
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>Ahora sus cambios a <filename>button.c</filename> han sido
        consignados al repositorio; si otro usuario baja una copia de trabajo
        de <filename>/calc</filename>, él verá sus cambios en la última
        versión del archivo.</para>

      <para>Suppose you have a collaborator, Sally, who checked out a
        working copy of <filename>/calc</filename> at the same time
        you did.  When you commit your change to
        <filename>button.c</filename>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</para>

      <para>To bring her project up to date, Sally can ask
        Subversion to <firstterm>update</firstterm> her working copy,
        by using the Subversion <command>update</command> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</para>

<screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U button.c
</screen>

      <para>The output from the <command>svn update</command> command
        indicates that Subversion updated the contents of
        <filename>button.c</filename>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <filename>.svn</filename> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</para>
      
    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.2">
      <title>Revisions</title>

      <para>An <command>svn commit</command> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</para>

      <para>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</para>
      
      <para><xref linkend="svn-ch-2-dia-7"/> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a <quote>snapshot</quote> of the way the
        repository looked after each commit. </para>
      
      <figure id="svn-ch-2-dia-7">
        <title>The repository</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>
         
        <para>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <emphasis>entire
          trees</emphasis>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When a
          Subversion user talks about <quote>revision 5 of
          <filename>foo.c</filename></quote>, they really mean
          <quote><filename>foo.c</filename> as it appears in revision 5.</quote>
          Notice that in general, revisions N and M of a file do
          <emphasis>not</emphasis> necessarily differ!  Because CVS
          uses per-file revisions numbers, CVS users might want to see
          <xref linkend="svn-ap-a"/> for more details.</para>
      </sidebar>

      <para>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <filename>button.c</filename>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</para>

<screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para>Suppose that, at this point, Sally commits a change to
        <filename>integer.c</filename>, creating revision 6.  If you
        use <command>svn update</command> to bring your working copy
        up to date, then it will look like this:</para>

<screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>Sally's changes to <filename>integer.c</filename> will
        appear in your working copy, and your change will still be
        present in <filename>button.c</filename>.  In this example,
        the text of <filename>Makefile</filename> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <filename>Makefile</filename> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</para>

    </sect2>
    
    
    <sect2 id="svn-ch-2-sect-3.3">
      <title>How Working Copies Track the Repository</title>
      
      <para>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <filename>.svn/</filename> administrative area:</para>
      
      
      <itemizedlist>
        <listitem><para>what revision your working file is based on
            (this is called the file's <firstterm>working
             revision</firstterm>), and</para></listitem>
        
        <listitem><para>a timestamp recording when the local copy was
            last updated by the repository.</para></listitem>
      </itemizedlist>

      <para>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</para>

      <variablelist>
        <varlistentry>
          <term>Unchanged, and current</term> 

          <listitem><para>The file is unchanged in the working
          directory, and no changes to that file have been committed
          to the repository since its working revision.  A
          <command>svn commit</command> of the file will do nothing,
          and an <command>svn update</command> of the file will do
          nothing. </para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and current</term>

          <listitem><para>The file has been changed in the working
          directory, and no changes to that file have been committed
          to the repository since its base revision.  There are local
          changes that have not been committed to the repository, thus
          an <command>svn commit</command> of the file will succeed in
          publishing your changes, and an <command>svn update</command>
          of the file will do nothing.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Unchanged, and out-of-date</term> 

          <listitem><para>The file has not been changed in the working
          directory, but it has been changed in the repository.  The
          file should eventually be updated, to make it current with
          the public revision.  An <command>svn commit</command> of the
          file will do nothing, and an <command>svn update</command> of
          the file will fold the latest changes into your working
          copy.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term>Locally changed, and out-of-date</term>

          <listitem><para>The file has been changed both in the
          working directory, and in the repository.  An <command>svn
          commit</command> of the file will fail with an
          <quote>out-of-date</quote> error.  The file should be
          updated first; an <command>svn update</command> command will
          attempt to merge the public changes with the local changes.
          If Subversion can't complete the merge in a plausible way
          automatically, it leaves it to the user to resolve the
          conflict.</para></listitem>
        </varlistentry>
      </variablelist>
      
      
      <para>This may sound like a lot to keep track of, but the
        <command>svn status</command> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <xref linkend="svn-ch-3-sect-4.3.1" />.</para>
     
    </sect2>
    
    <sect2 id="svn-ch-2-sect-3.4">
      <title>The Limitations of Mixed Revisions</title>

      <para>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing mixed revision
        numbers.</para>

      <para>At first, it may not be entirely clear why this sort of
        flexibility is considered a feature, and not a liability.
        After completing a commit to the repository, the freshly
        committed files and directories are at a more recent working
        revision than the rest of the working copy.  It looks like a
        bit of a mess.  As demonstrated earlier, the working copy can
        always be brought to a single working revision by running
        <command>svn update</command>.  Why would someone
        <emphasis>deliberately</emphasis> want a mixture of working
        revisions?</para>

      <para>Assuming your project is sufficiently complex, you'll
        discover that it's sometimes nice to forcibly
        <quote>backdate</quote> portions of your working copy to an
        earlier revision; you'll learn how to do that in Chapter 3.
        Perhaps you'd like to test an earlier version of a sub-module,
        contained in a subdirectory, or perhaps you'd like to examine
        a number of previous versions of a file in the context of the
        latest tree.</para>
        
      <para>However you make use of mixed-revisions in your working
        copy, there are limitations to this flexibility.</para>

      <para>First, you cannot commit the deletion of a file or
        directory which isn't fully up-to-date.  If a newer version of
        the item exists in the repository, your attempt to delete will
        be rejected, to prevent you from accidentally
        destroying changes you've not yet seen.</para>

      <para>Second, you cannot commit a metadata change to a directory
        unless it's fully up-to-date.  You'll learn about attaching
        <quote>properties</quote> to items in Chapter 6.  A
        directory's working revision defines a specific set of entries
        and properties, and thus committing a property change to an
        out-of-date directory may destroy properties you've not yet
        seen.</para>

    </sect2>

  </sect1>

  <sect1 id="svn-ch-2-sect-4">
    <title>Summary</title>
    
    <para>We've covered a number of fundamental Subversion concepts in
    this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We've seen some simple examples of how two collaborators
        can use Subversion to publish and receive changes from one
        another, using the 'copy-modify-merge' model.</para>
      </listitem>

      <listitem>
        <para>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>
    
    <para>At this point, you should have a good idea of how Subversion
    works in the most general sense.  Armed with this knowledge, you
    should now be ready to jump into the next chapter, which is a
    detailed tour of Subversion's commands and features. </para>
      
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
