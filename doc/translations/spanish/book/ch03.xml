<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<chapter id="svn-ch-3">
  <title>Recorrido guiado</title>

  <simplesect>

    <para>Ahora entraremos en los detalles de usar Subversion. Para el
      momento en que usted alcance el final de este capítulo, podrá
      realizar casi todas las tareas Subversion que usted necesita usar
      en un día normal de trabajo.<!--TODO:almost all the tasks you
      need to use Subversion in a normal day's work--> Comenzará con
      una descarga inicial<!--TODO:checkout--> de su codigo, y caminará
      <!--TODO:and walk through making changes--> haciendo cambios y
      examinando esos cambios. Usted también verá como introducir
      <!--TODO:how to bring changes-->cambios hechos por otros en
      su copia de trabajo, examinarlos, y trabajar con cualquier
      <!--TODO: and work through any conflicts--> conflicto que
      pudiera surgir.</para>

    <para>Observe que este capítulo no pretende ser <!--TODO:is not
      meant to be--> una lista exhaustiva de los comandos de Subversion
      &mdash;al contrario, es una introducción conversacional<!--TODO:
      conversational introduction--> a las tareas más comunes de
      Subversion que se encontrará. Este capítulo asume que usted ha
      leido y entendido <xref linkend="svn-ch-2"/> y está familiarizado
      con el modelo general de Subversion. Para una referencia completa
      de todos los comandos, vea <xref linkend="svn-ch-9"/>.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECCIÓN 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-1">
    <title>¡Ayuda!</title><!--TODO:help! .... al venir con la exclamación
                          no creo que se refiera a la opcion help-->


    <para>Antes de leer<!--TODO:Before reading on-->, aqui está el
      comando más importante que usted necesitará siempre usando
      Subversion: <command>svn help</command>. El cliente de linea
      de comandos Subversion está auto-documentado<!--TODO:
      self-documenting-->&mdash; en cualquier momento, un rapido
      <command>svn help &lt;subcomando&gt;</command> describirá
      la sintaxis, los interruptores <!--TODO:switches-->y el
      comportamiento del <command>subcomando</command>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECCIÓN 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-2">
    <title>Import</title><!--TODO:aqui no creo que haya que traducirlo-->

    <para>Use <command>svn import</command> para importar un nuevo
      proyecto dentro de un repositorio Subversion. Mientras que esto
      es lo más probable que usted haga cuando instala su servidor
      Subversion, no es algo que sucede muy a menudo. Para una
      descripción detallada de import, vea <xref
      linkend="svn-ch-3-sect-7.3"/> más adelante en este capítulo.
    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECCIÓN 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-3">
    <title>Revisiones: números, palabras clave, y fechas, ¡Oh mi!</title>
       <!--Revisions: Numbers, Keywords, and Dates, Oh My!-->

    <para>Antes de continuar <!--TODO:Before we go on-->, debería saber
      un poco acerca de como identificar una revisión particular en su
      repositorio. Como ha aprendido en <xref linkend="svn-ch-2-sect-3.2"/>,
      una revisión es una <quote>instantánea</quote> de su repositorio
      en un momento particular en el tiempo. A medida que continue
      depositando y creciendo su repositorio, usted necesita un mecanismo
      para identificar estas instantáneas.</para>

    <para>Especifique estas resvisiones usando <option>--revision</option>
      (<option>-r</option>) junto con la revsión que quiera <!--TODO:
      switch plus the revision you want-->
      (<command>svn --revision REV</command>) o puede especificar un rango
      separando dos revisiones con dos puntos
      (<command>svn --revision REV1:REV2</command>). Y Subversion le deja
      referirse a estas revisiones por número, palabra clave, o fecha.
    </para>
    
    <sect2 id="svn-ch-3-sect-3.1">
      <title>Números de revision</title>
      <!--TODO:Revision Numbers-->
      
      <para>Cuando usted crea un nuevo repositorio de Subversion, este
        comienza su vida como revision cero y cada commit sucesivo
        <!--TODO: successive commit...no creo que sea buena idea poner
        deposición sucesiva :D--> incrementa el número de revision en
        uno. Después de completar su commit <!--TODO: como ponemos
        commit?-->, el cliente de Subversion le informa del nuevo
        número de revisión:</para>
      
      <screen>
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</screen>

      <para>Si en cualquier punto del futuro usted desea referirse a
        esta revisión (veremos cómo y por qué podríamos querer hacer
        esto más adelante en este capítulo<!--TODO:we might want
        to do that later-->), puede referirse a esta como
        <quote>3</quote>.</para>

    </sect2>
    
    <sect2 id="svn-ch-3-sect-3.2">
      <title>Palabras clave de la revsión</title>
             <!--TODO:Revision Keywords-->
      <para>El cliente de Subversion entiende un número de <firstterm>
        palabras clave de la revisión</firstterm>.<!--TODO:The Subversion
        client understands a number of revision keywords--> Estas palabras
        clave pueden ser usadas en vez del número entero como argumento a
        la opción <option>--revision</option>, y son resueltos como
        números especificos de revisión por Subversion:</para>
        <!--TODO:These keywords can be used instead of integer arguments
        to the <option>- -revision</option> switch, and are resolved into
        specific revision numbers by Subversion-->

      <note>
        <para>Cada directorio en su copia de trabajo contiene un
          subdirectorio administrativo llamado <filename>.svn</filename>.
          Para todos los ficheros en un directorio, Subversion  mantiene
          una copia de cada fichero en el area administrativa.<!--TODO:
          quizá haya que cambiar lo de administrativo, por "area de
          aministrador" o algo así--> Esta copia es una copia inmodificada
          (ninguna extensión de palabra clave, ninguna traducción del
          fin-de-linea, nada de nada) del fichero tal como existió en la
          última revisión (llamada la revisión <quote>BASE</quote>) que
          usted actualizó a su copia de trabajo. Nos referimos a este
          fichero como <firstterm>copia prístina</firstterm> o <!--TODO:
          pristine copy... ¿?--> versión <firstterm>basada en texto
          </firstterm><!--TODO:text-base--> de su fichero, y este es
          siempre una copia byte-a-byte exacta del fichero tal como
          existe en el repositorio.</para> 
        </note>
      
      <variablelist>
        
        <varlistentry>
          <term>HEAD</term>
          <listitem>
            <para>La última revisión del repositorio.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>BASE</term>
          <listitem>
            <para>La revisión <quote>prístina</quote> de un elemento
              en la copia de trabajo.</para><!--TODO:of an item-->
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>COMMITTED</term>
          <listitem>
            <para>La última revisión en la que un elemento cambió antes
              (o en) <literal>BASE</literal>.</para> <!--TODO:an item
              changed before (or at) BASE-->
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>PREV</term>
          <listitem>
            <para>La revisión justo <emphasis>anterior</emphasis> de la
              última revision en la cual un elemento cambió.
              (Técnicamente, <literal>COMMITTED</literal> - 1.)</para>
          </listitem>
        </varlistentry>
        
      </variablelist>

      <note>
        <para><literal>PREV</literal>, <literal>BASE</literal>, y
          <literal>COMMITTED</literal> pueden ser usadas para referirse
          a paths locales, pero no a URLs.</para><!--TODO:como se traduce
          "path"? camino? referencia?-->
      </note>
      
      <para>Aquí hay algunos ejemplos de palabras clave de revisión en
        acción. No se preocupe si los comandos no tienen sentido todavía;
        estaremos explicando estos comandos a medida que avanzamos por el
        capítulo:</para><!--TODO:as we go through the chapter...creo que
        mi traducción es acertada-->
      
      <screen>
$ svn diff --revision PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log --revision HEAD
# shows log message for the latest repository commit

$ svn diff --revision HEAD
# compares your working file (with local mods) to the latest version
# in the repository.

$ svn diff --revision BASE:HEAD foo.c
# compares your <quote>pristine</quote> foo.c (no local mods) with the 
# latest version in the repository

$ svn log --revision BASE:HEAD
# shows all commit logs since you last updated

$ svn update --revision PREV foo.c
# rewinds the last change on foo.c.
# (foo.c's working revision is decreased.)
</screen>
      
      <para>Estas palabras clave le permiten realizar muchas
        operaciones comunes (y útiles) sin tener que mirar números
        <!--TODO: to look up specific--> especificos de revisión
        o recordar la revisión exacta de su copia de trabajo.</para>
      
    </sect2>
    
    <sect2 id="svn-ch-3-sect-3.3">
      <title>Fechas de revisión</title>
      
      <para>Dondequiera que usted especifique un número de revisión o
        palabra clave de revisión, usted también puede especificar una
        fecha especificando la fecha dentro de llaves <quote>{}</quote>.
        <!--TODO:curly braces--> ¡Puede incluso tener acceso a un rango
        de cambios en el repositorio usando fechas y revisiones juntas!
      </para>

      <para>Aquí hay ejemplos de los formatos de fecha que admite
        Subversion. Recuerde usar comillas alrededor de cualquier fecha
        que contenga espacios.</para><!--TODO:to use quotes around any
        date-->

      <screen>
$ svn checkout --revision {2002-02-17}
$ svn checkout --revision {15:30}
$ svn checkout --revision {15:30:00.200000}
$ svn checkout --revision {"2002-02-17 15:30"}
$ svn checkout --revision {"2002-02-17 15:30 +0230"}
$ svn checkout --revision {2002-02-17T15:30}
$ svn checkout --revision {2002-02-17T15:30Z}
$ svn checkout --revision {2002-02-17T15:30-04:00}
$ svn checkout --revision {20020217T1530}
$ svn checkout --revision {20020217T1530Z}
$ svn checkout --revision {20020217T1530-0500}
&hellip;
</screen>
      
      <para>Cuando especifique una fecha como revisión, Subversion
        encuentra la revisión más reciente en el repositorio con
        esta fecha:<!--TODO: as of that date:--></para>
        
      <screen>
$ svn log --revision {2002-11-28}
------------------------------------------------------------------------
r12 | ira | 2002-11-27 12:31:51 -0600 (Wed, 27 Nov 2002) | 6 lines
&hellip;
</screen>
        
      <sidebar>
        <title>¿Está Subversion un día anticipado?</title>
           <!--TODO:Is Subversion a Day Early?-->
        
        <para>Si usted especifica una fecha simple como revsión sin
          especificar una hora del día (por ejemplo
          <literal>2002-11-27</literal>), puede pensar que Subversion
          le dará la última revisión que tuvo lugar el 27 de Noviembre.
          En cambio, usted recibirá una revisión del 26 de Noviembre,
          o incluso anterior. Recuerde que Subversion encontrará la
          <emphasis>revisión más reciente del repositorio </emphasis>
          <!--TODO:as of the date you give--> con la fecha que usted da.
          Si da una marca de tiempo sin hora <!--TODO:timestamp...según
          ORCA-->, como <literal>2002-11-27</literal>, Subversion
          asume la hora como 00:00:00<!--TODO: assumes a time of-->,
          así que buscando la revisión más reciente no devolverá nada
          del día 27.</para>

        <para>Si quiere incluir el día 27 <!--TODO:the 27th...lo he
          traducido como "día 27", ya que no sé si hay alguna mejor-->
          en su busqueda, puede especificar el día 27 con la hora
          (<literal>{"2002-11-27 23:59"}</literal>), o justo el día
          siguiente (<literal>{2002-11-28}</literal>).</para>
          <!--TODO:you can either specify... puede especificar ambas...?
          puede blablabla ambas? No sé traducir de forma adecuada ese
          either :p-->
        
      </sidebar>
      
      <para>También puede especificar un rango de fechas. Subversion
        encontrará todas las revisiones entre ambas fechas, inclusive:
        <!--TODO:traducir inclusive?--></para>
      
      <screen>
$ svn log --revision {2002-11-20}:{2002-11-29}
&hellip;
</screen>
        
      <para>Como apuntamos<!--TODO:As we pointed out-->, también puede
        mezclar fechas y revisiones:</para>
      
      <screen>
$ svn log --revision {2002-11-20}:4040
</screen>

      <para>Los usuarios deberían estar enterados de un subtlety que
        puede convertirse en un obstáculo al tratar con fechas en
        Subversion.<!--TODO: que es "subtlety"? ni idea--> Desde que
        la marca de tiempo <!--TODO: "timestamp" otra vez--> de una
        revisión es guardada como una propiedad de la revisión&mdash;
        <!--TODO:traducir "property" como característica mejor?-->
        una propiedad sin versionar<!--TODO:unversioned-->, modificable
        &mdash; la marca de tiempo<!--TODO:timestamp--> de la revisión puede
        cambiarse para representar una falsificación completa de la
        verdadera cronología, o incluso borrarla totalmenta. Esto
        causará estragos <!--TODO:This will wreak havoc--> en la
        conversión interna fecha-a-revisión que Subversion realiza.
        </para>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECCIÓN 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-4">
    <title>Descarga inicial</title>

    <para>La mayoría del tiempo, comenzará usando un repositorio de
      Subversion haciendo un <firstterm>checkout</firstterm> de su
      proyecto<!--TODO:añadir NT para poner que checkout es descarga?-->
      . Descargando un repositorio crea una copia de este en en su
      maquina local. Esta copia contiene el <literal>HEAD</literal>
      (última revisión) del repositorio de Subversion que usted
      especifica en la línea de comandos:</para>
      

    <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
&hellip;
Checked out revision 2499.
</screen>
    
    <sidebar>
      <title>Esquema del repositorio</title>
         <!--TODO: Repository Layout-->

      <para>Si se está preguntando qué es todo lo de alrededor de
        <literal>trunk</literal> en la URL anterior<!--TODO:If you're
        wondering what <literal>trunk</literal> is all about in the
        above URL-->, es parte de la manera que le recomendamos
        presentar su repositorio Subversion, acerca del cual
        hablaremos mucho más en <xref linkend="svn-ch-4"/>.</para>
        <!--TODO:it's part of the way we recommend you lay out your
        Subversion repository which we'll talk a lot more about in-->

    </sidebar>

    <para>Aunque el ejemplo anterior descarga el directorio trunk
      <!--TODO:traducir trunk?no creo-->, usted puede descargar
      facilmente cualquier subdirectorio más profundo <!--TODO:deep-->
      de un repositorio especificando el subdirectorio en la URL de
      descarga:</para>


    <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools
A  tools/readme-dblite.html
A  tools/fo-stylesheet.xsl
A  tools/svnbook.el
A  tools/dtd
A  tools/dtd/dblite.dtd
&hellip;
Checked out revision 2499.
</screen>
    
    <para>Desde que Subversion usa un modelo
      <quote>copie-modifique-fusione</quote> en vez de
      <quote>atar-modificar-desatar</quote><!--TODO:lock,unlock...
      traducir mejor como cerrar, liberar? o bloquear, desbloquear?-->
      (vea <xref linkend="svn-ch-2"/>), usted ya puede comenzar a
      realizar cambios a los ficheros y directorios en su copia de
      trabajo local. Su copia local es justo como cualquier otra
      colección de ficheros y directorios en su sistema. Usted puede
      editarlos y cambiarlos, moverlos <!--TODO:move them around-->,
      usted puede incluso borrar la copia local entera y olvidarse
      de él.</para>

      <note>
        <para>Mientras que su copia de trabajo local es <quote>justo
          como cualquier otra colección de ficheros y directorios en
          su sistema</quote>, usted necesita hacer saber a Subversion
          si va a cambiar cualquier cosa dentro de su copia local. Si
          desea copiar o mover un elemento en una copia local, debe
          usar <command>svn copy</command> o <command>svn move</command>
          en vez de los comandos copiar y mover proporcionados por su
          sistema operativo. Hablaremos más acerca de ellos más adelante
          en este capítulo.</para>
      </note>

    <para>A menos que esté preparado para enviar al repositorio un nuevo
      fichero o directorio, o cambios a unos existentes, no hay necesidad
      de citar más sobre el servidor de Subversion que usted haya hecho.
      <!--TODO:there's no need to further notify the Subversion server
      that you've done anything...complicado de traducir :p--></para>

    <sidebar>
      <title>¿Qué pasa con el directorio <filename>.svn</filename>?</title>
      <!--TODO:What's with the <filename>.svn</filename> directory?-->

      <para>Cada directorio en una copia de trabajo local contiene un
        área administrativa, un subdirectorio llamado
        <filename>.svn</filename>. Generalmente, el comando de listado
        de directorios no mostrará este subdirectorio, pero este es
        sin embargo un directorio importante. Sea lo que fuere lo que haga
        <!--TODO:whatever you do--> ¡no borre o cambie nada en el área
        administrativa!  Subversion depende de esta para administar su
        copia de trabajo local.</para>

    </sidebar>

    <para>Mientras que <!--TODO: can certainly check out-->usted puede
      descargar una copia de trabajo local con la URL del repositorio
      como único argumento, también puede especificar un directorio
      después de su URL del repositorio. Esto pone su copia de trabajo
      local dentro del nuevo directorio que usted nombra. Por ejemplo:
    </para>
    
    <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
&hellip;
Checked out revision 2499.
</screen>
    
    <para>Esto pondrá su copia de trabajo local en un directorio
      llamado <literal>subv</literal> en vez de en un directorio
      llamado <literal>trunk</literal> como hemos hecho previamente.
    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECCIÓN 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-5">
    <title>Ciclo básico de trabajo</title><!--TODO:Basic Work Cycle-->

    <para>Subversion tiene numerosas características, opciones, campanas
      y silbidos<!--TODO:bells and whistles-->, pero en una base cotidiana
      <!--TODO: day-to-day basis... quizá mejor poner "uso cotidiano"?-->
      las probabilidades son que use solamente algunas de ellas. En esta
      sección veremos <!--TODO:we'll run--> las cosas más comunes que
      puede encontrarse haciendo con Subversion en el transcurso de un día
      de trabajo.</para>
    
    <para>El típico ciclo de trabajo se parece a esto:</para>
             <!--TODO:The typical work cycle looks like this-->
    <itemizedlist>
      <listitem>
        <para>Actualizar su copia de trabajo local</para>
        <itemizedlist>
          <listitem>
            <para><command>svn update</command></para>
          </listitem>
        </itemizedlist>
        
      </listitem>
      
      <listitem>
        <para>Hacer cambios</para>
        <itemizedlist>
          <listitem>
            <para><command>svn add</command></para>
          </listitem>
          <listitem>
            <para><command>svn delete</command></para>
          </listitem>
          <listitem>
            <para><command>svn copy</command></para>
          </listitem>
          <listitem>
            <para><command>svn move</command></para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Examinar sus cambios</para>
        <itemizedlist>
          <listitem>
            <para><command>svn status</command></para>
          </listitem>
          <listitem>
            <para><command>svn diff</command></para>
          </listitem>
          <listitem>
            <para><command>svn revert</command></para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Fusionarlos con los cambios de otros</para>
             <!--TODO:Merge others' change-->
        <itemizedlist>
          <listitem>
            <para><command>svn merge</command></para>
          </listitem>
          <listitem>
            <para><command>svn resolved</command></para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Enviar sus cambios al repositorios</para>
        <itemizedlist>
          <listitem>
            <para><command>svn commit</command></para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <sect2 id="svn-ch-3-sect-4.1">
      <title>Actualizar su copia de trabajo local</title>

      <para>Cuando se trabaja en un proyecto con un equipo, usted querrá
        actualizar su copia de trabajo local para recibir cualquier cambio
        hecho desde su última actualización por otros desarrolladores en
        el proyecto. Use <command>svn update</command> para aportar a su
        copia de trabajo local<!--TODO:to bring your working copy into
        sync--> sincronización  con la última revisión en el repositorio.
      </para>
      
      <screen>
$ svn update
U  foo.c
U  bar.c
Updated to revision 2.
</screen>
      
      <para>En este caso, alguien <!--TODO:someone else checked in
        modifications to both--> modificó <filename>foo.c</filename> y
        <filename>bar.c</filename> desde la última vez que usted actualizó,
        y Subversion ha actualizado su copia de trabajo local para incluir
        estos cambios.</para>
      
      <para>Vamos a examinar la salida de <command>svn update</command>
        un poco más. Cuando el servidor envía cambios a su copia de trabajo
        local, una letra codigo <!--TODO:a letter code--> se visualiza al
        lado del objeto para hacerle saber qué acciones realizó Subversion
        para traer su copia de trabajo local a la actualización:<!--TODO:
        to bring...up-to-date--></para>

      <variablelist>

        <varlistentry>
          <term><computeroutput>U      foo</computeroutput></term>
          <listitem>
            <para>El fichero <filename>foo</filename> fue
              <computeroutput>U</computeroutput>pdated<!--TODO:quizá poner
              NT diciendo que Updated es actualizado?--> (recibidos
              cambios del servidor).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>A      foo</computeroutput></term>
          <listitem>
            <para>El fichero o directorio <filename>foo</filename> fue
              <computeroutput>A</computeroutput>dded <!--TODO:lo mismo de
              antes, solo que aqui quedaria bien poner "Añadido"-->
              a su copia de trabajo local.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>D      foo</computeroutput></term>
          <listitem><!--TODO-->
            <para>El fichero o directorio <filename>foo</filename> fue
              <computeroutput>D</computeroutput>eleted <!--TODO:otra vez-->
              de su copia de trabajo local.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><computeroutput>R      foo</computeroutput></term>
          <listitem><!--TODO-->
            <para>El fichero o directorio <filename>foo</filename> fue
              <computeroutput>R</computeroutput>eplaced <!--TODO:otra mas-->
              en su copia de trabajo local; esto es, <filename>foo</filename>
              fue borrado, y un nuevo objeto con el mismo nombre fue añadido.
              Mientras pueden tener el mismo nombre, el repositorio los
              considera objetos distintos con historiales distintos.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>G      foo</computeroutput></term>
          <listitem><!--TODO-->
            <para>El fichero <filename>foo</filename> recibió nuevos
              cambios del repositorio, pero su copia local del
              fichero tenía sus modificaciones. O los cambios no se
              intersectaron <!--TODO:intersect-->, o los cambios eran
              exactamente iguales que sus modificaciones locales, asi que
              Subversion ha mer<computeroutput>G</computeroutput>ed
              <!--TODO: cambiar lo de merged--> satisfactoriamente los
              cambios del repositorio al fichero sin ningún problema.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>C      foo</computeroutput></term>
          <listitem><!--TODO-->
            <para>El fichero <filename>foo</filename> recibió cambios
              <computeroutput>C</computeroutput>onflicting del servidor.
              Los cambios del servidor directamente <!--overlap-->
              se superpusieron sobre sus propios cambios en el fichero.
              Aunque no hay necesidad de aterrarse. Esta superposición
              necesita ser resuelta por un humano (usted); tratamos esta
              situación más tarde en este capítulo.</para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="svn-ch-3-sect-4.2">
      <title>Hacer cambios en su copia de trabajo local</title>
      
      <para>Ahora puede conseguir trabajar y hacer cambios en su copia
        de trabajo local. Generalmente es más conveniente decidir un
        cambio particular (o un conjunto de cambios) a hacer, por ejemplo
        escribir una nueva característica, corregir un fallo, etc. Los
        comandos de Subversion que puede usar aqui <!--TODO:use here...
        poner mejor "en esta situación?"--> son <command>svn add</command>,
        <command>svn delete</command>, <command>svn copy</command>,
        y <command>svn move</command>. Sin embargo, si usted está
        simplemente corrigiendo los archivos que están ya en Subversion,
        puede no necesitar utilizar ninguno de estos comandos hasta que
        envie los cambios. Cambios que puede hacer a su copia de trabajo
        local:</para>
      
      <variablelist>
        
        <varlistentry>
          <term>Cambios en los ficheros</term>
            <!--TODO:File changes-->
          <listitem>
            <para>Esta es la clase más simple de cambio. No necesita
              decirle a Subversion que se propone a cambiar un fichero;
              simplemente <!--TODO:just--> haga los cambios. Subversion
              será capaz de detectar automaticamente qué archivos han
              sido cambiados.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Cambios en el árbol</term><!--TODO:tree changes-->
          <listitem>
            <para>Puede preguntar a Subversion que <quote>marque</quote>
              ficheros y directorios para <!--TODO:scheduled removal-->
              el borrado planificado, la adición, la copia, o moverlos.
              <!--TODO:moving-->Mientras estos cambios pueden ocurrir
              inmediatamente en su copia de trabajo local, ninguna
              adición o borrado sucederá en el respositorio hasta que
              envie los cambios.</para>
          </listitem>
        </varlistentry>

      </variablelist>
      
      <para>Para hacer cambios en los ficheros, use su editor de textos,
        procesador de textos, programa de graficos <!--TODO: graphics
        program-->, o cualquier herramienta que usaría normalmente.
        Subversion maneja ficheros binarios tan fácilmente como maneja
        archivos de texto&mdash;y tan eficientemente también.</para>
      
      <para>Aqui hay una descripción de los cuatro subcomandos de
        Subversion que usted usará más a menudo para hacer cambios del
        árbol (cubriremos <command>svn import</command> y
        <command>svn mkdir</command> después.</para>
        <!--TODO:habría que poner alguna explicación sobre el árbol?
        que se trata del árbol de repositorio?-->
      
      <variablelist>
        
        <varlistentry>
          <term><command>svn add foo</command></term>
          <listitem>
            <para>Programa añadir <filename>foo</filename> al repositorio.
              <!--TODO:schedule foo to be added-->Cuando haga su proximo
              envio, <filename>foo</filename> se convertirá en hijo de
              su directorio padre. Fijese que si <filename>foo</filename>
              es un directorio, todo por debajo de <filename>foo</filename>
              será programado para la adición <!--TODO:will be scheduled
              for addition-->. Si solo quiere añadir el propio
              <filename>foo</filename><!--TODO:schedule foo itself-->,
              pase la opción <option>--non-recursive</option>
              (<option>-N</option>) <!--TODO:pass -N switch-->.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn delete foo</command></term>
          <listitem>
            <para>Programa <!--TODO:schedule--> borrar
              <filename>foo</filename> del repositorio. Si
              <filename>foo</filename> es un fichero, se borrará
              inmediatamente de su copia de trabajo local. Si
              <filename>foo</filename> es un directorio, este no es
              borrado, pero Subversion lo programa para borrarlo. <!--TODO:
              schedules it for deletion--> Cuando envie sus cambios,
              <filename>foo</filename> será borrado de su copia de trabajo
              y del repositorio.<footnote><para>Por supuesto, nada es
              borrado totalmente del repositorio&mdash;solo del<!--TODO:
              just from the--><literal>HEAD</literal> del repositorio.
              Puede conseguir cualquier cosa que borró descargando (o
              actualizando su copia de trabajo) a una revisión anterior a
              la que lo borró.</para> </footnote></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn copy foo bar</command></term>
          <listitem>
            <para>Crea un nuevo objeto <filename>bar</filename> como
              duplicado de <filename>foo</filename>.
              <filename>bar</filename> es automáticamente programado
              para la adición<!--TODO:is automatically scheduled for
              addition-->. Cuando <filename>bar</filename> es añadido al
              repositorio en el siguiente envio de cambios, su historia
              de copia es registrada (como que originalmente  viene de
              <filename>foo</filename><!--TODO:as having originally come
              from-->).<command>svn copy</command> no crea directorios
              intermedios.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn move foo bar</command></term>
          <listitem>
            <para>Este comando funciona exactamente igual que
              <command>svn copy foo bar; svn delete foo</command>.
              Esto es, se programa <!--TODO:scheduled-->
              <filename>bar</filename> para la adición como una copia de
              <filename>foo</filename>, y se programa
              <filename>foo</filename> para la eliminación<!--TODO:
              for removal-->. <command>svn move</command> no crea
              directorios intermedios.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <sidebar>
        <title>Cambiando el repositorio sin una copia de trabajo</title>

        <!-- ### pll - Fri 07 Feb 2003 12:55:07                            -->
        <!-- I find this sidebar rather confusing here, since you really   -->
        <!-- haven't gone through explaining the svn command line syntax   -->
        <!-- anywhere.  Maybe a short section explaining that subversion   -->
        <!-- can be used both in networked and non-networked environments, -->
        <!-- and which types of commands need URLs, etc.  This should      -->
        <!-- probably be in chapter 2 (around the "Subversion in action"   -->
        <!-- though, so that this sidebar makes more sense.                -->
        
        <para>Anteriormente en este capítulo, dijimos que tiene que enviar
          cualquier cambio que usted haga en orden para que <!--TODO:in
          order for the repository to reflect these changes-->el
          repositorio refleje estos cambios. Esto no es enteramente cierto
          <!--TODO: entirely true... podria quedar mejor "no es del todo
          cierto-->&mdash;<emphasis>hay</emphasis> algunos usos-casos que
          inmediatamente envian los cambios del árbol al repositorio. Esto
          sucede solamente cuando un subcomando está operando directamente
          sobre una URL, al contrario que sobre una ruta de la copia-local
          <!--TODO:on a URL, rather than on a working-copy path-->.
          En particular, usos especificos de <command>svn mkdir</command>,
          <command>svn copy</command>, <command>svn move</command>, y
          <command>svn delete</command> pueden trabajar con URLs.</para>


        <para>Las operaciones de URL se comportan de esta manera porque
          los comandos que manipulan <!--TODO:operate-->en una copia de
          trabajo pueden usar la copia de trabajo como una clase de
          <quote>area de estancamiento</quote><!--TODO:staging area to set
          up your changes before-->para preparar sus cambios antes de
          enviarlos al repositorio. Los comandos que operan sobre URLs
          no tienen este lujo, asi cuando usted opera directamente sobre
          una URL, cualquiera de las acciones anteriores representa un
          envio inmediato.</para>

      </sidebar>

    </sect2>

    <sect2 id="svn-ch-3-sect-4.3">
      <title>Examine sus cambios</title>
      
      <para>Una vez que haya terminado de hacer cambios, necesita enviarlos
        al repositorio, pero antes de hacerlo, generalmente es buena
        idea hechar un vistazo a lo que ha cambiado exactamente. Examinando
        sus cambios antes de que los envie, puede hacer un mensaje de
        informe de cambios más exacto. También puede descubrir que ha
        cambiado inadvertidamente un fichero, y esto le dá la posibilidad
        de invertir<!--TODO:revert...¿retroceder?--> esos cambios antes
        de enviarlos. Además, esta es una buena oportunidad para revisar
        y escudriñar cambios antes de publicarlos. Usted puede ver
        exactamente qué cambios ha hecho usando <command>svn
        status</command>, <command>svn diff</command>, y
        <command>svn revert</command>. Generalmente usará los primeros
        dos comandos para descubrir qué ficheros han cambiado en su copia
        de trabajo local, y después quizá el tercero para invertir
        algunos (o todos) de esos cambios.</para>
      
      <!-- pll - Fri 07 Feb 2003 12:55:07                                   -->
      <!-- I find this following paragraph a little unclear.  Mostly for    -->
      <!-- the same reasons as I found the sidebar above unclear.  There    -->
      <!-- hasn't been much discussion of the Subversion architecture, and  -->
      <!-- therefore, nothing has been clearly stated wrt the fact that the -->
      <!-- repository may not be local.                                     -->
      
      <para>Subversion ha sido optimizado para ayudarle con esta tarea,
        y es capaz de hacer muchas cosas sin comunicarse con el
        repositorio. En particular, su copia de trabajo local contiene una
        copia <quote>pristina</quote><!--TODO:secret cached pristine
        copy of each version controlled file within the .svn area-->
        secreta almacenada de cada fichero de versión controlado dentro
        del área <filename>.svn</filename>. Debido a esto, Subversion
        puede rapidamente mostrarle cómo sus ficheros de trabajo han cambiado,
        o incluso permitirle deshacer sus cambios sin contactar con el
        repositorio.</para>
      
      <sect3 id="svn-ch-3-sect-4.3.1">
        <title><command>svn status</command></title>
        
        <para>Probablemente usará el comando <command>svn status</command>
          más que cualquier otro comando de Subversion.</para>
        
        <sidebar>
          <title>Usuarios de CVS: ¡Lleve a cabo esa actualización!</title>
            <!--TODO:CVS Users: Hold That Update!... según google
            "¡Lleve a cabo Esa Actualización!"-->
          <para>Probablemente esté acostumbrado a usar<!--TODO:You're
            probably used to using--> <command>cvs update</command> para
            ver qué cambios le ha hecho a su copia de trabajo local.
            <command>svn status</command> le dará toda la información
            que necesita sobre qué ha cambiado en su copia de trabajo
            local&mdash;sin acceder al repositorio o incorporando
            <!--TODO:potentially incorporating new changes-->nuevos cambios
            potenciales publicados por otros usuarios.</para>
        
          <para>En Subversion, <command>update</command> hace justo
            eso&mdash;actualiza su copia de trabajo local con cualquier
            cambio enviado al repositorio desde la última vez que usted
            <!--TODO:last time you've updated-->ha actualizado su copia
            de trabajo. Tendrá que romper el hábito de usar el comando
            <command>update</command> para ver qué modificaciones locales
            ha hecho.</para>

        </sidebar>
        
        <para>Si ejecuta <command>svn status</command> en lo alto<!--TODO:
          at the top...poner que se refiere al directorio más alto?-->
          de su copia de trabajo sin argumentos, detectará todos
          los cambios de fichero y árbol que usted ha hecho. Este
          ejemplo está diseñado para mostrar todos los códigos de
          estado<!--TODO:status--> diferentes que <command>svn
          status</command> puede devolver. (Observe que el texto que
          sigue a <literal>#</literal> en el siguiente ejemplo no es
          <!--TODO:printed...imprimido?-->impreso realmente por
          <command>svn status</command>.)</para>

      
        <screen>
$ svn status
  L    abc.c               # svn has a lock in its .svn directory for abc.c
M      bar.c               # the content in bar.c has local modifications
 M     baz.c               # baz.c has property but no content modifications
X      3rd_party           # this dir is part of an externals definition
?      foo.o               # svn doesn't manage foo.o
!      some_dir            # svn manages this, but it's either missing or incomplete
~      qux                 # versioned as dir, but is file, or vice versa
I      .screenrc           # this file is ignored
A  +   moved_dir           # added with history of where it came from
M  +   moved_dir/README    # added with history and has local modifications
D      stuff/fish.c        # this file is scheduled for deletion
A      stuff/loot/bloo.h   # this file is scheduled for addition
C      stuff/loot/lump.c   # this file has conflicts from an update
    S  stuff/squawk        # this file or dir has been switched to a branch
&hellip;
</screen>
      
        <para>En este formato de salida <command>svn status</command>
          impresa <!--TODO:prints...o "imprime"?--> cinco columnas de
          caracteres, seguidos por varios caracteres de espacio en
          blanco<!--TODO:whitespace-->, seguido por un nombre de
          fichero o directorio. La primera columna dice el estado
          de un fichero o directorio y/o su contenido. Los códigos
          impresos aqui son:</para>


        <variablelist>

          <varlistentry>
            <term><computeroutput>A      file_or_dir</computeroutput></term>
            <listitem>
              <para>El fichero o directorio
                <filename>file_or_dir</filename> ha sido programado para
                la adición<!--TODO:for addition--> en el repositorio.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>C     file</computeroutput></term>
            <listitem>
              <para>El fichero <filename>file</filename> está en un estado
                de conflicto. Esto es, los cambios recibidos del servidor
                durante una actualización se solapan con cambios locales
                que usted tiene en su copia de trabajo. Debe resolver
                este conflicto antes de enviar sus cambios al repositorio.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>D      file_or_dir</computeroutput></term>
            <listitem>
              <para>El fichero o directorio
                <filename>file_or_dir</filename> ha sido programado para
                la supresión <!--TODO:for deletion...estaría mejor "para
                ser suprimido"?-->del repositorio.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>M      file</computeroutput></term>
            <listitem>
              <para>El contenido del fichero <filename>file</filename> ha
                sido modificado.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>X      dir</computeroutput></term>
            <listitem>
              <para>El directorio <filename>dir</filename> está sin
                versionar<!--TODO:unversioned-->, pero está relacionado
                con una definición externa<!--TODO:is related to a
                Subversion externals definition--> de Subversion. Para
                descubrir más acerca de definiciones externas, vea
                <xref linkend="svn-ch-7-sect-3"/>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>?      file_or_dir</computeroutput></term>
            <listitem>
              <para>El fichero o directorio
                <filename>file_or_dir</filename> no está bajo control de
                versiones. Puede silenciar la marca de pregunta<!--TODO:
                the question marks...mejor "la marca de interrogante"?-->
                pasando la opción<!--TODO:switch--> <option>--quiet</option>
                (<option>-q</option>) a <command>svn status</command>, o
                o poniendo<!--TODO:or by setting--> la característica
                <literal>svn:ignore</literal> en el directorio padre.
                Para más información sobre ficheros ignorados, vea
                <xref linkend="svn-ch-7-sect-2.3.3" />.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>!      file_or_dir</computeroutput></term>
            <listitem>
              <para>El fichero o directorio
                <filename>file_or_dir</filename> está bajo el control de
                versiones pero falta o está de alguna manera incompleto.
                El objecto puede faltar si se ha borrado usando un comando
                ajeno<!--TODO:non-Subversion command--> a Subversion. En
                el caso de un directorio, puede estar incompleto si ha
                interrumpido una descarga o una actualización.
                Un rápido <command>svn update</command> repondrá <!--TODO:
                refetch-->el fichero o el directorio desde el repositorio,
                o <command>svn revert file</command> restaurará un
                archivo que falta.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>~     file_or_dir</computeroutput></term>
            <listitem>
              <para>El fichero o directorio
                <filename>file_or_dir</filename> está en el repositorio
                como un tipo<!--TODO: as one kind of object--> de objeto,
                pero actualmente está en su copia de trabajo como otro
                tipo. Por ejemplo, Subversion pudo tener un fichero en
                el repositorio, pero usted borró el fichero y creó un
                directorio en su lugar, sin usar los comandos
                <command>svn delete</command> o <command>svn add</command>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>I      file_or_dir</computeroutput></term>
            <listitem>
              <para>Subversion está <quote>ignorando</quote> el fichero o
                directorio <filename>file_or_dir</filename>, probablemente
                porque usted se lo dijo. Para más información sobre
                ficheros ignorados, vea <xref
                linkend="svn-ch-7-sect-2.3.3"/>. Observe que este simbolo
                solo aparece si le pasa la opción
                <option>--no-ignore</option> a <command>svn status</command>.
              </para>
            </listitem>
          </varlistentry>

        </variablelist>

        <para>La segunda columna dice el estado de las propiedades de un
          fichero o un directorio (vea <xref
          linkend="svn-ch-7-sect-2"></xref> para más información sobre
          propiedades). Si aparece una <computeroutput>M</computeroutput>
          en la segunda columna, entonces las propiedades han sido
          modificadas, si no un espacio en blanco <!--TODO:whitespace-->
          será impreso.</para>
        
        <para>La tercera columna solo mostrará un espacio en blanco
          o una <computeroutput>L</computeroutput>
          la cual significa que Subversion ha bloqueado <!--TODO:locked-->
          el objeto en el area de trabajo <filename>.svn</filename>. Usted
          verá una <computeroutput>L</computeroutput> si ejecuta
          <command>svn status</command> en un directorio donde un
          <command>svn commit</command> esté en progreso&mdash;quizás
          cuando esté editando el informe de cambios. Si Subversion
          no se está ejecutando, entonces probablemente Subversion
          fue interrumpido y el bloqueo necesita ser eliminado
          <!--TODO:the lock needs to be cleaned up--> ejecutando
          <command>svn cleanup</command> (más sobre eso más adelante
          en este capítulo).</para>
        
        <para>La cuarta columna solo mostrará un espacio blanco o un
          <computeroutput>+</computeroutput> el cual significa
          que el fichero o directorio está programado <!--TODO:
          is scheduled-->para ser añadido o modificado con historial
          adicional adjunto<!--TODO:with additional attached history-->.
          Esto ocurre típicamente cuando usted <command>svn move</command>
          o <command>svn copy</command> un fichero o directorio. Si usted
          ve <computeroutput>A&nbsp;&nbsp;+</computeroutput>, esto
          significa que el objeto está programado para la
          adición-con-historial<!--TODO:for addition-with-history-->.
          Este puede ser un fichero, o la raiz de un directorio copiado.
          <computeroutput>+</computeroutput> significa que el objeto
          es parte de un subárbol programado para la
          adición-con-historial, p.e.<!--TODO:i.e.-->algún padre fue
          copiado,and it's just coming along for the ride<!--TODO:
          i.e. some parent got copied, and it's just coming along for
          the ride....demasiado dificil :-(-->.
          <computeroutput>M&nbsp;&nbsp;+</computeroutput> significa que
          el objeto es parte de un subárbol programado para la
          adición-con-historial, <emphasis>y</emphasis> este tiene
          modificaciones locales. Cuando envie los cambios,
          primero el padre será añadido-con-historial (copiado),
          lo que significa que este fichero existirá automaticamente
          en la copia. Entonces las modificaciones locales serán
          enviadas al repositorio.</para>

        <para>La quinta columna solo mostrará un espacio en blanco o
          una <computeroutput>S</computeroutput>. Esto significa que
          el fichero o directorio ha sido movido<!--TODO:switched-->
          de la ruta<!--TODO:path--> del resto de la copia de trabajo
          (usando <command>svn switch</command>) a una rama.</para>

        <para>Si usted pasa una ruta específica a <command>svn
          status</command>, este le dará información acerca de ese
          objeto solamente:</para>
        
        <screen>
$ svn status stuff/fish.c
D      stuff/fish.c
</screen>
        
        <para><command>svn status</command> también tiene una opción
          <option>--verbose</option> (<option>-v</option>), el cuál
          le mostrará el estado de <emphasis>todos</emphasis> los
          objetos en su copia de trabajo, incluso si este no ha
          sido cambiado:</para>
           
        <screen>
$ svn status --verbose
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</screen>
           
        <para>Esta es la <quote>forma larga</quote> de salida de
          <command>svn status</command>. La primera columna permanece
          igual<!--TODO:remains the same-->, pero la segunda columna
          muestra la revisión de trabajo del fichero. La tercera
          y cuarta columna muestra la revisión en la cuál el objeto
          cambió por última vez, y quién lo cambió.</para>

        <para>Ningúna de las invocaciones anteriores a
          <command>svn status</command> contactaban con el repositorio,
          trabajan solo localmente comparando los metadatos en el
          <!--TODO:metadata in the .svn...quedaría mejor "del directorio?-->
          directorio <filename>.svn</filename> con la copia de trabajo
          local. Finalmente está la opción<!--TODO:switch-->
          <option>--show-updates</option> (<option>-u</option>), la cual
          contacta con el repositorio y añade informacion acerca de las
          cosas que están fuera-de-fecha:<!--TODO:out-of-date...
          desactualizadas? anticuadas?--></para>
      
        <screen>
$ svn status --show-updates --verbose
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</screen>
           
        <para>Observe los dos asteriscos: si usted ejecutara
          <command>svn update</command> en este punto, usted podría
          recivir cambios para <filename>README</filename> y
          <filename>trout.c</filename>. Esto le dice cierta información
          muy útilmdash;necesitará actualizar y coger los cambios del
          servidor para <filename>README</filename> antes de enviar sus
          cambios, o el repositorio rechazará su envio por estar
          fuera-de-fecha.<!--TODO:out-of-date--> (Más de este tema más 
          adelante.)</para>

      </sect3>

      <sect3 id="svn-ch-3-sect-4.3.2">
        <title><command>svn diff</command></title>
        
        <para>Otra manera de examinar sus cambios es con el comando
          <command>svn diff</command>. Puede descubrir
          <emphasis>exactamente</emphasis> cómo ha modificado cosas
          ejecutando <command>svn diff</command> sin argumentos<!--TODO:with
          no arguments-->, el cual imprime los cambios de los ficheros en
          formato unificado del<!--TODO:in unified diff format -->
          diff:<footnote><para>Subversion usa su motor
          <!--TODO:engine--> interno de diff, el cual produce un formato 
          unificado del diff, por defecto. Si quiere la salida del diff en 
          un formato diferente, especifique un programa diff externo usando
          <option>--diff-cmd</option> y pasando cualquier parámetro que
          quiera usando la opción <option>--extensions</option>. Por
          ejemplo, para ver diferencias locales en el fichero
          <filename>foo.c</filename> en contexto con el formato de
          salida mientras ignora cambios en espacios en blanco
          <!--TODO:in context output format while ignoring whitespace
          changes--> puede ejecutar
          <command>svn diff --diff-cmd /usr/bin/diff
          --extensions '-bc' foo.c</command>.</para>
          </footnote></para>


        <screen>
$ svn diff
Index: bar.c
===================================================================
--- bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@ 
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.
</screen>
        
        <para>El comando <command>svn diff</command> produce esta
          salida comparando sus ficheros de copia de trabajo contra
          la copia <quote>pristina</quote> almacenada en el área
          <filename>.svn</filename>. Los ficheros programados para
          la adición se visualizan como texto-añadido<!--TODO:are
          displayed as all added-text-->, y los ficheros
          programados para la eliminación  son visualizados como
          texto eliminado<!--TODO:as all deleted text-->.</para>

        <para>La salida es visualizada en <firstterm>formato unificado
          del diff</firstterm>. Esto es, las lineas quitadas son
          empezadas<!--TODO:prefaced--> con un <literal>-</literal> y
          las lineas añadidas son empezadas con un <literal>+</literal>.
          <command>svn diff</command> también imprime el nombre del
          fichero e información util para el programa <!--TODO:
          offset information useful--><command>patch</command>,
          asi que puede generar <quote>parches</quote><!--TODO:patches-->
          redireccionando la salida del diff a un fichero:</para>


        <screen>
$ svn diff &gt; patchfile
</screen>

        <para>Usted puede, por ejemplo, mandar por email<!--TODO:traducir
          email?--> el fichero de parche<!--TODO:patchfile--> a otro
          desarrollador para la <!--TODO:for review or testing-->
          revisión o testeo antes de enviarlo.</para>

      </sect3>

      <sect3 id="svn-ch-3-sect-4.3.3">
        <title><command>svn revert</command></title>

        <para>Ahora suponga que usted ve la salida del diff anterior, y
          <!--TODO:realize--> se dá cuenta que sus cambios a
          <filename>README</filename> son un error; quizás accidentalmente
          tecleó ese texto en el fichero equivocado en su editor</para>
      
        <para>Esta es una oportunidad perfecta para usar <command>svn
          revert</command>.</para>
           
        <screen>
$ svn revert README
Reverted 'README'
</screen>
        
        <para>Subversion <!--TODO:reverts-->invierte el fichero a un
          estado pre-modificado reescribiendolo con la copia
          <quote>pristina</quote> almacenada en el area
          <filename>.svn</filename>. Pero también observer que
          <command>svn revert</command> puede deshacer
          <emphasis>cualquier</emphasis> operación programada&mdash;por
          ejemplo, usted puede decidir que no quiere añadir un nuevo
          fichero después de todo:</para>

        <screen>
$ svn status foo
?      foo

$ svn add foo
A         foo

$ svn revert foo
Reverted 'foo'

$ svn status foo
?      foo
</screen>

        <note>
          <para><command>svn revert</command>
          <replaceable>ITEM</replaceable> tiene exactamente el mismo
          efecto que suprimiendo <replaceable>ITEM</replaceable> de
          su copia de trabajo local y despues ejecutando
          <command>svn update -r BASE</command>
          <replaceable>ITEM</replaceable>. Sin embargo, si está
          revirtiendo<!--TODO:reverting... o mejor "invirtiendo"?-->
          un fichero, <command>svn revert</command> tiene una diferencia
          muy considerable&mdash;no tiene que comunicarse con el
          repositorio para reponer<!--restore--> su fichero.</para>
        </note>

        <para>O quizás usted quito equivocadamente un fichero del control
          de versión:</para>

        <screen>
$ svn status README 
       README

$ svn delete README 
D         README

$ svn revert README
Reverted 'README'

$ svn status README
       README
</screen>

      </sect3>

      <sidebar>
          <title>¡Mira mamá! ¡Sin red!</title>
          <!--TODO:Look Ma! No Network!... supongo que lo habré traducido
          bien, pero por si acaso-->

        <para>Estos tres comandos<!--TODO:all three of these commands-->
          (<command>svn status</command>, <command>svn diff</command>, y
          <command>svn revert</command>) pueden ser usados sin ningún
          acceso de red. Esto lo hace sencillo para administrar sus
          cambios-en-progreso cuando usted está en alguna parte sin
          una conexión de red, tal como viajando en un avión, montando en
          un tren<!--TODO:riding a commuter train--> o hackeando en
          la playa.</para>

        <para>Subversion hace esto manteniendo almacenes privados de
          versiones prístinas de cada fichero versionado dentro del
          área administrativa <filename>.svn</filename>. Esto permite
          a Subversion reportar&mdash;y revertir&mdash;modificaciones
          locales a ésos ficheros <emphasis>sin acceso de
          red</emphasis>. Este almacén (llamado el
          <quote>texto-base</quote>) también permite a Subversion
          mandar las modificaciones locales del usuario durante un
          envio al servidor como un <firstterm>delta</firstterm>
          comprimido (o <quote>diferéncia</quote>) contra la
          versión prístina. Tener este almacén es un benefício
          tremendo&mdash;incluso si usted tiene una conexión de red
          rápida, es mucho más rapido mandar solamente los cambios
          del fichero al servidor antes que el fichero entero. A
          primera vista, esto puede no parecer tán importante, pero
          imagine la repercusión si usted intenta enviar un cambio de
          una línea a un fichero de 400MB ¡ y tiene que enviar el fichero
          entero al servidor!<!--TODO:la frase acaba "whole file to
          the server!"... está bien donde he puesto la "¡"?--></para>
    </sidebar>

    </sect2>

    <sect2 id="svn-ch-3-sect-4.4">
      <title>Resolver conflictos (fusionando los cambios de otros)</title>
           
      <para>Ya hemos visto cómo <command>svn status -u</command> puede
        predecir conflictos. Suponga que ejecuta <command>svn
          update</command> y ocurren algunas cosas interesantes</para>
      
      <screen>
$ svn update
U  INSTALL
G  README
C  bar.c
Updated to revision 46.
</screen>
           
      <para>Los códigos <computeroutput>U</computeroutput> y
        <computeroutput>G</computeroutput> no son causa para la
        <!--TODO:are no cause for concern-->inquietud; esos ficheros
        absorbieron limpiamente los cambios del repositorio. Los
        ficheros marcados con una <computeroutput>U</computeroutput>
        no contienen cambios locales pero fueron
        act<computeroutput>U</computeroutput>alizados<!--TODO:en ingles
        ponía Updated--> con cambios del repositorio. La
        <computeroutput>G</computeroutput> representa
        mer<computeroutput>G</computeroutput>ed<!--TODO:se pone "enviado"
        entre parentesis?-->, lo que significa que el fichero tenía
        para comenzar cambios locales, pero los cambios que venían del
        repositorio no se solaparon de ninguna manera.</para>

      <para>Pero la <computeroutput>C</computeroutput> representa
        conflicto. Esto significa que los cambios del servidor se solapan
        con los suyos propios, y ahora tiene que elegir manualmente
        entre ellos.</para>
           
      <para>Siempre que ocurra un conflicto, ocurren tres cosas para
        ayudarle a notar<!--TODO:to assist you in noticing--> y
        resolver ese conflicto:</para>
           
      <itemizedlist>

        <listitem>
          <para>Subversion imprime una <computeroutput>C</computeroutput>
            durante la actualización, y recuerda que el fichero está en
            un estado de conflicto.</para>
        </listitem>

        <listitem>
          <para>Subversion coloca <firstterm>marcas de
            conflicto</firstterm>&mdash;secuencias especiales de texto
            que delimitan los <quote>lados</quote> del conflicto&mdash;en
            el fichero para demostrar visualmente las áreas solapadas.
          </para>
        </listitem>

        <listitem>
          <para>Para cada fichero en conflicto, Subversion coloca tres
            ficheros extra en su copia de trabajo local:</para>

          <variablelist>
            
            <varlistentry>
              <term><filename>filename.mine</filename></term>
              <listitem>
                <para>Este es su fichero como existió en su copia de
                  trabajo antes de que usted actualizara su copia de
                  trabajo&mdash;esto es, sin marcas de conflicto.
                  Este fichero tiene su últimos cambios y nada más.</para>
              </listitem>
            </varlistentry>
            
            <varlistentry>
              <term><filename>filename.rOLDREV</filename></term>
              <listitem>
                <para>Este es el fichero que era la revisión
                  <literal>BASE</literal> antes de que usted actalizara
                  su copia de trabajo. Esto es, el fichero que usted
                  descargó antes de que hiciera su última edición.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><filename>filename.rNEWREV</filename></term>
              <listitem>
                <para>Este es el fichero que su cliente de Subversion
                  recibió del servidor justo cuando usted actualizó su
                  copia de trabajo. Este fichero corresponde con la
                  revisión <literal>HEAD</literal> del repositorio.</para>
              </listitem>
            </varlistentry>

          </variablelist>
          
          <para>Aquí <literal>OLDREV</literal> es el número de revisión
            del fichero en su directorio <filename>.svn</filename> y
            <literal>NEWREV</literal> es el número de revisión del
            <literal>HEAD</literal> del repositorio.</para>
        </listitem>
        
      </itemizedlist>
      
      <para>Por ejemplo, Sally hace cambios al fichero
        <filename>sandwich.txt</filename> en el repositorio. Harry acaba
        de cambiar el fichero en su copia de trabajo y lo ha enviado. Sally
        actualiza su copia de trabajo antes de enviarlo y recibe<!--TODO:
        gets...recibir parece que es un premio, quizá haya algo mejo--> un
        conflicto:</para>
      
      <screen>
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</screen>
      <!-- ###TODO What happens if the revnum is gt 99999?-->
      
      <para>En este punto, Subversion <emphasis>no</emphasis> le
        permitirá enviar el fichero <filename>sandwich.txt</filename>
        hasta que los tres ficheros temporales sean borrados.</para>

      <screen>
$ svn commit --message "Add a few more things"
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</screen>

      <para>Si obtiene un conflicto, necesita hacer una de tres
        cosas:</para>

        <itemizedlist>

          <listitem>
            <para>Fusionar el texto en conflicto <quote>a mano</quote>
              (examinando y editando las marcas de conflicto dentro
              del fichero).
            </para>
          </listitem>

          <listitem>
            <para>Copiar uno de los ficheros temporales sobre su fichero
              de trabajo<!--TODO:copy...on top of your working copy-->.
            </para>
          </listitem>

          <listitem>
            <para>Ejecutar <command>svn revert &lt;filename&gt;</command>
              para eliminar<!--TODO:throw away--> todos sus cambios
              locales.</para>
          </listitem>

        </itemizedlist>

      <para>Una vez que usted haya resuelto el conflico, necesita dejar que
        Subversion lo sepa<!--TODO:you need to let Subversion know-->
        ejecutando <command>svn resolved</command>. Esto borrará los
        tres ficheros temporales y Subversion no considerará por más<!--TODO:
        no longer considers--> tiempo que el fichero está en estado de
        conflicto.<footnote><para>Siempre puede borrar los ficheros
        temporales usted mismo, pero ¿realmente querría hacer eso cuando
        Subversion puede hacerlo para usted?<!--TODO:can do it for you?...
        quizá quede mejor poner "hacerlo por usted"?--> No lo creemos.
        </para></footnote>
      </para>

      <screen>
$ svn resolved sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</screen>

      <sect3 id="svn-ch-3-sect-4.4.1">
        <title>Fusionando conflictos a mano</title>

        <para>Fusionar conflictos a mano puede ser absolutamente
          intimidatorio la primera vez que lo haga<!--TODO:you attempt
          it-->, pero con un poco de practica, puede llegar a ser tan
          fácil como caerse de una bici<!--TODO:it can become as easy as
          falling off a bike.....ein???-->.</para>

        <para>Aquí tiene un ejemplo. Debido a una falta de comunicación,
          usted y Sally, su colaboradora, editan el fichero
          <filename>sandwich.txt</filename> en el mismo momento. Sally
          envía sus cambios, y cuando usted va a actualizar su copia
          de trabajo, obtiene un conflicto y vamos a tener que editar
          <filename>sandwich.txt</filename> para resolver los conflictos.
          Primero, hechemos una hojeada al fichero:</para>

        <screen>
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</screen>

        <para>Las líneas de signos menor-que, y signos mayor-que son
          marcas de conflictos, y no son parte de los datos en conflicto
          actuales. Generalmente usted querrá asegurarse que estén
          borrados del fichero antes de su proximo envío. El texto entre
          las dos primeras marcas están compuestas por los cambios que
          usted hizo en el área conflictiva:</para>

        <screen>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</screen>

        <para>El texto entre el segundo y tercer set de marcas de conflicto
          es el texto del envio de Sally:</para>

        <screen>
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</screen>

        <para>Generalmente usted no deseará borrar las marcas de conflicto
          y los cambios de Sally&mdash;ella se sorprenderá terriblemente
          cuando llegue el sandwich y no sea lo que ella quería. Aquí es
          donde usted coge el telefono o anda a través de la oficina y le
          explica a Sally que no puede tomar sauerkraut de un deli
          Italiano.<!--TODO:that you can't get sauerkraut from an Italian
          deli...vaya metafora--><footnote><para>Y si les pregunta por
          esto, pueden echarle de la ciudad en un carril<!--TODO: they may
          very well ride you out of town on a rail...ein?
          -->.</para></footnote>Una vez usted esté de acuerdo con los
          cambios deberá comprobarlos, editar su fichero y borrar las
          marcas de conflicto</para>

        <screen>
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</screen>

        <para>Ahora ejecute <command>svn resolved</command>, y está listo
          para enviar sus cambios:</para>

        <screen>
$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</screen>

        <para>Recuerde, si algúna vez está confuso mientras edita el
          fichero conflictivo, siempre puede consultar los tres ficheros
          que Subversion crea para usted en su copia de
          trabajo&mdash;incluyendo su fichero como estaba antes de que
          usted actualizara. Incluso puede usar una herramienta interactiva
          de fusión de una third-party<!--TODO:cómo traducir third-party?-->
          para examinar esos tres fichero.</para>

      </sect3>

      <sect3 id="svn-ch-3-sect-4.4.2">
        <title>Copiando un fichero en su fichero de trabajo</title>

        <para>Si obtiene un conflicto y decide que quiere rechazar sus
          cambios, simplemente usted puede copiar uno de los ficheros
          temporales creados por Subversion sobre el fichero en su copia
          de trabajo:</para>

        <screen>
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ cp sandwich.txt.r2 sandwich.txt
$ svn resolved sandwich.txt
</screen>

      </sect3>

      <sect3 id="svn-ch-3-sect-4.4.3">
        <title>Punting: Usando <command>svn revert</command></title>
          <!--TODO:Punting... rechazando? excluyendo?-->

        <para>Si obtiene un conflicto, y sobre la examinación decide
          que quiere rechazar sus cambios y empezar su edición de nuevo,
          simplemente invierta sus cambios:</para>

        <screen>
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
</screen>

        <para>Observe que cuando usted invierte un fichero conflictivo,
          no tiene que ejecutar <command>svn resolved</command>.</para>

      </sect3>

      <para>Ahora usted está listo para enviar sus cambios. Observe que
        <command>svn resolved</command>, al contrario de la mayoría de
        los otros comandos<!--TODO: unlike most of the other
        commands we've dealt with in this chapter--> que nos hemos ocupado
        en este capitulo, requiere un argumento. En cualquier caso, debe
        tener cuidado y solo ejecutar <command>svn resolved</command>
        cuando esté seguro que ha arreglado el conflicto en su
        fichero&mdash;una vez los ficheros temporales son borrados,
        Subversion le dejará enviar el fichero incluso si todavía tiene
        marcas de conflicto.</para>
      
    </sect2>
    
    <sect2 id="svn-ch-3-sect-4.5">
      <title>Enviar sus cambios</title>
      
      <para>¡Finalmente! Su edición está terminada, ha fusionado todos
        los cambios del servidor, y está listo para enviar sus cambios
        al repositorio.</para>
      
      <para>El comando <command>svn commit</command> envía todos sus
           cambios al repositorio. Cuando usted envía un cambio, necesita
           proveer un <firstterm>mensaje de registro</firstterm>,
           describiendo su cambio. Su mensaje de registro será adjuntado
           a la nueva revisión que ha creado. Si su mensjae de registro
           es breve, puede querer proveerlo en la línea de comando usando
           la opción <option>--message</option> (o
           <option>-m</option>):</para>

      <screen>
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</screen>
           
      <para>Sin embargo, si ha estado componiendo su mensaje de registro
        mientras trabaja, puede querer decirle a Subversion que coja el
        mensaje de un fichero pasando el nombre de fichero con la
        opción <option>--file</option> :</para>

      <screen>
$ svn commit --file logmsg 
Sending        sandwich
Transmitting file data .
Committed revision 4.
</screen>

      <para>Si usted falla en especificar cualquiera de las opciones
        <option>--message</option> o <option>--file</option>,
        entonces Subversion lanzará automaticamente su editor favorito
        (según lo definido en la variable de entorno
        <literal>$EDITOR</literal>) para redactar un mensaje de
        registro.</para>
        
        
      <tip>
        <para>Si está en su editor escribiendo un mensaje de registro y
          decide que quiere cancelar su envio, usted puede quitar su
          editor sin guardar los cambios. Si ya ha guardado su mensaje
          de registro, simplemente borre el texto y salve otra vez.</para>

        <screen>
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
a)bort, c)ontinue, e)dit
a
$
</screen>
      </tip>

      <para>El repositorio no sabe ni cuida<!--TODO:doesn't know or care-->
        si sus cambios tienen algún sentido en su totalidad; solo comprueba
        para asegurarse que nadie haya cambiado cualquiera de los mismos
        ficheros que usted mientras usted no miraba. Si alguien
        <emphasis>ha</emphasis> hecho esto, el envio entero fallará con
        un mensaje informandole que uno o más de sus ficheros está
        fuera-de-fecha:</para>

<screen>
$ svn commit --message "Add another rule"
Sending        rules.txt
svn: Commit failed (details follow):
svn: Out of date: 'rules.txt' in transaction 'g'
</screen>

      <para>En este punto, necesita ejecutar <command>svn
        update</command>, ocupandose<!--TODO:deal with any merges or
        conflicts--> con cualquier fusión o conflicto que resulte
        y procure enviarlo otra vez.</para>

           
      <para>Eso cubre el ciclo basico de trabajo para usar Subversion.
        Hay muchas otras características en Subversion que usted puede
        usar para administrar su repositorio y copia de trabajo, pero
        puede pasar facilmente<!--TODO: but you can get by
        quite easily using--> usando solo los comandos que hemos visto
        <!--TODO:discussed so far--> hasta ahora en este capítulo.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-6">
    <title>Examinando el historial</title>
    <!--TODO:Examining History..."la historia" o "el historial"?-->
    <para>Como hemos mencionado anteriormente, el repositorio es como
      una máquina del tiempo. Este mantiene un expediente de cada cambio
      enviado, y le permite explorar este historial examinando versiones
      anteriores de ficheros y directorios así como los metadatos que
      los acompañan. Con un único comando de Subversion, puede descargar
      el repositorio (o restaurar una copia de trabajo existente)
      exactamente como era en cualquier fecha o número de revisión en el
      pasado. Sin embargo, a veces solo desea <emphasis>mirar</emphasis>
      <!--TODO:peer into--> al pasado en vez de <emphasis>ir</emphasis>
      al pasado<!--TODO:going into-->.</para>
           
    <para>Hay varios comandos que pueden proporcionarle datos históricos
      del repositorio:</para>

      <variablelist>

        <varlistentry>
          <term><command>svn log </command></term>
          <listitem>
            <para>Le muestra amplia información: mensajes de registro
              unidos a las revisions, y que ruta de fichero cambió en
              cada revisión.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn diff </command></term>
          <listitem>
            <para>Le muestra los detalles específicos de cómo cambió un
              fichero en un cierto plazo<!--TODO:over time-->.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn cat </command></term>
          <listitem>
            <para>Este se utiliza para recuperar cualquier fichero tal
              como existió en un un número de revisión particular y
              lo muestra en su pantalla.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn list </command></term>
          <listitem>
            <para>Muestra los ficheros en un directorio para cualquier
              revisión dada.</para>
          </listitem>
        </varlistentry>

      </variablelist>


    <sect2 id="svn-ch-3-sect-5.1">
      <title><command>svn log</command></title>

      <para>Para descubrir información sobre la historia de un fichero o
        directorio, use el comando <command>svn log</command>.
        <command>svn log</command> le proporcionará un registro de quién
        hizo cambios a un fichero o directorio, en qué revisión cambió,
        la hora y fecha de esa revisión, y, si fue proporcionado, el
        mensaje de registro que acompañaba al envío.</para>
           
      <screen>
$ svn log
------------------------------------------------------------------------
r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line

Initial import
------------------------------------------------------------------------
</screen>
           
      <para>Observe que los mensajes de registro son impresos en
        <emphasis>orden cronológico inverso</emphasis> por defecto.
        Si desea ver un rango diferente de revisiones en un orden
        particular, o solo una única revisión, pase la opción
        <option>--revision</option> (<option>-r</option>):</para>
           
      <screen>
$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order

$ svn log -r 19:5            # shows logs 5 through 19 in reverse order

$ svn log -r 8               # shows log for revision 8
</screen>
        
      <para>También puede examinar el historial de registro de un único
      fichero o directorio. Por ejemplo:</para>
           
      <screen>
$ svn log foo.c
&hellip;
$ svn log http://foo.com/svn/trunk/code/foo.c
&hellip;
</screen>
           
      <para>Ésto mostrará los mensajes de registro
        <emphasis>solo</emphasis> para esas revisiones en las cuales
        el fichero de trabajo (o URL) cambió.</para>
           
      <para>Si deséa aún más información sobre un fichero o directorio,
        <command>svn log</command> también toma una opción
        <option>--verbose</option> (<option>-v</option>). Porque
        Subversion le permite mover y copiar ficheros y directorios,
        es importante poder seguir cambios de la ruta del fichero en el
        sistema de ficheros, así en modo detallado<!--TODO:verbose-->,
        <command>svn log</command> incluirá una lista de rutas de
        fichero cambiadas en una revisión en su salida:<!--TODO:
        will include a list of changed paths in a
        revision in its output--></para>

      <screen>
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
M /trunk/code/foo.c
M /trunk/code/bar.h
A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</screen>

      <sidebar>
        <title>¿Por qué <command>svn log</command> me da una respuesta
          vacía?</title>
        
        <para>Después de trabajar con Subversion un poco, la mayoría de
          los usuarios tendrán algo como esto:</para>

        <screen>
$ svn log -r 2
------------------------------------------------------------------------
$
</screen>

        <para>A primer vistazo, esto parece como un error. Pero recuerde
          que mientras las revisiones son repository-wide<!--TODO:cómo
          traducir "repository-wide"?-->, <command>svn log</command>
          funciona sobre una ruta en el repositorio. Si no provee
          ninguna ruta de fichero, Subversion usa el directorio de
          trabajo actual como destino por defecto. En consecuencia, si
          usted está trabajando<!--TODO:operating--> en un subdirectorio
          de su copia de trabajo y procurando registrar una revisión
          en la cual ni ese directorio ni cualquiera de sus hijos fue
          cambiado, Subversion le dará un registro vacio. Si desea ver
          qué cambió en esa revisión, intente indicando
          <command>svn log</command> directamente en lo más alto del
          URL de su repositorio, como en <command>svn log -r 2
          http://svn.collab.net/repos/svn</command>.</para>

      </sidebar>
           
    </sect2>

    <sect2 id="svn-ch-3-sect-5.2">
      <title>svn diff</title>

      <para>Ya hemos visto <command>svn diff</command>
        antes&mdash;éste muestra las diferencias de fichero en un
        formato unificado del diff; fue utilizado para mostrar las
        modificaciones locales hechas a nuestra copia de trabajo
        antes de enviarlas al repositorio.</para>
      
      <para>De hecho, resulta que hay <emphasis>three</emphasis> usos
        distintos para <command>svn diff</command>:</para>

      <itemizedlist>

        <listitem>
          <para>Examinar cambios locales</para>
        </listitem>

        <listitem>
          <para>Comparar su copia de trabajo con la del repositorio</para>
        </listitem>

        <listitem>
          <para>Comparar repositorio con repositorio</para>
        </listitem>

      </itemizedlist>
      
      <sect3 id="svn-ch-3-sect-5.2.1">
        <title>Examinando cambios locales</title>

        <para>Como hemos visto, invocando<!--TODO:invoking... mejor
          poner otra cosa?--> <command>svn diff</command> sin
          argumentos comparará sus ficheros de trabajo con las
          copias <quote>pristinas</quote> almacenadas en el área
          <filename>.svn</filename>:</para>
        
        <screen>
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
        
      </sect3>

      <sect3 id="svn-ch-3-sect-5.2.2">
        <title>Comparando copia de trabajo con repositorio</title>

        <para>Si se pasa un único <option>--revision</option>
          (<option>-r</option>) número, entonces su copia de trabajo
          es comparada con la revisión especificada del
          repositorio.</para>
          
        <screen>
$ svn diff --revision 3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
          
      </sect3>

      <sect3 id="svn-ch-3-sect-5.2.3">
        <title>Comparando repositorio con repositorio</title>
        
        <para>Si dos números de revisión, separados por una coma, son
          pasados via <option>--revision</option>
          (<option>-r</option>), entonces las dos revisiones son
          comparadas directamente.</para>
          
        <screen>
$ svn diff --revision 2:3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth closed 
$
</screen>
          
        <para>No solo puede usar <command>svn diff</command> para
           comparar ficheros en su copia de trabajo con el repositorio,
           sino que si suministra una URL como argumento<!--TODO:supply
           a URL argument-->, usted puede examinar las diferencias entre
           elementos en el repositorio incluso sin tener<!--TODO:without
           even having--> una copia de trabajo. Esto es especialmente
           útil si desea inspeccionar cambios en un fichero cuando
           no tiene una copia de trabajo en su máquina local:</para>
           
        <screen>
$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt
&hellip;
$
</screen>

      </sect3>

    </sect2>

    <sect2 id="svn-ch-3-sect-5.3">
       <title><command>svn cat</command></title>

      <para>Si desea examinar una versión anterior de un fichero y
        no necesariamente las diferencias entre dos ficheros, puede
        usar <command>svn cat</command>:</para>

      <screen>
$ svn cat --revision 2 rules.txt 
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth closed
$
</screen>

      <para>También puede redireccionar la salida directamente a un
        fichero:</para>

      <screen>
$ svn cat --revision 2 rules.txt &gt; rules.txt.v2
$
</screen>

      <para>Probablemente se esté preguntando por qué <!--TODO:why we
        don't just use--> no usamos <command>svn update --revision</command>
        para actualizar el fichero a la revisión más antígua. Hay algunas
        razones por las que <!--TODO:we might prefer--> preferimos usar
        <command>svn cat</command>.</para>

      <para>Primero, usted puede querer ver las diferencias entre dos
        revisiones de un fichero usando un programa diff externo (quizás
        uno grafico, o quizás su fichero está en <!--TODO:is in such
        a format--> un formato que la salida de un diff unificado es
        absurdo). En este caso, necesitará coger una copia de la revisión
        antigua, redireccionarla a un fichero, y pasar este y el fichero
        de su copia de trabajo a su programa diff externo.</para>

      <para>A veces es más facil mirar una versión más antigua de un fichero
        en su totalidad en comparación con las diferencias entre esta y
        otra revisión.</para>

      </sect2>

    <sect2 id="svn-ch-3-sect-5.4">
      <title><command>svn list</command></title>
      
      <para>El comando <command>svn list</command> le muestra qué ficheros
        están en un directorio de un repositorio sin realmente descargar
        los ficheros a su máquina local:</para>
      
      <screen>
$ svn list http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
</screen>

      <para>Si desea un listado más detallado, pase la opción
        <option>--verbose</option> (<option>-v</option>) para obtener
        una salida como esta.</para>

      <screen>
$ svn list --verbose http://svn.collab.net/repos/svn
   2755 harry          1331 Jul 28 02:07 README
   2773 sally               Jul 29 15:07 branches/
   2769 sally               Jul 29 12:07 clients/
   2698 harry               Jul 24 18:07 tags/
   2785 sally               Jul 29 19:07 trunk/
</screen>

      <para>Las columnas le dicen la revisión en la cual el fichero o
        directorio fue modificado por última vez, el usuario qué lo
        modificó, el tamaño si este es un fichero, la fecha de la
        última modificación, y el nombre del objeto.</para>
 
    </sect2>

    <sect2 id="svn-ch-3-sect-5.5">
      <title>Una palabra final en el historial</title>
            <!--TODO: A Final Word on History-->

      <para>Además de todos los comandos anteriores, usted puede usar
        <command>svn update</command> y <command>svn checkout</command>
        con la opción <option>--revision</option> para tomar una
        copia de trabajo entera <quote>aterior en el tiempo</quote>
        <!--TODO:back in time--><footnote><para>¿Ve? Le dijimos que
        Subversion era una máquina del tiempo.</para></footnote>:</para>

      <screen>
$ svn checkout --revision 1729 # Checks out a new working copy at r1729
&hellip;
$ svn update --revision 1729 # Updates an existing working copy to r1729
&hellip;
</screen>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 7 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-7">
    <title>Otros comandos útiles</title>

      <para>Mientras que no son usados con tanta frecuencia como los comandos
        discutidos<!--TODO:previously discused--> previamente en este
        capítulo, usted necesitará de vez en cuando estos comandos.</para>

    <sect2 id="svn-ch-3-sect-7.1">
      <title><command>svn cleanup</command></title>

      <para>Cuando Subversion modifica su copia de trabajo (o cualquier
        información en el interior de <filename>.svn</filename>),
        intenta hacerlo tan seguro como sea posible. Antes de cambiar
        cualquier cosa, escribe sus intenciones en un fichero de
        registro, ejecuta los comandos en el fichero de registro,
        entonces borra el fichero de registro (esto es similar en
        diseño a un sistema de ficheros transaccional). Si una operación
        de Subversion es interrumpida (si el proceso es matado, o si
        la máquina se cuelga<!--TODO:crashes-->, por ejemplo), los
        ficheros de registro permanecen en disco. Ejecutando de nuevo
        los ficheros de registro, Subversion puede completar la
        operación anteriormente empezada, y su copia de trabajo puede
        <!--TODO:and your working copy can get itself back into a
        consistent state--> volver a estar en un estado consistente.</para>

      <para>Y esto es exactamente lo que hace <command>svn
        cleanup</command>: busca en su copia de trabajo y ejecuta
        cualquier registro de sobra<!--TODO:and runs any leftover logs-->,
        eliminando bloqueos en el proceso. Si Subversion alguna vez le
        dice que alguna parte de su copia de trabajo está
        <quote>bloqueada</quote>, entonces éste es el comando que
        debería ejecutar. También, <command>svn status</command>
        mostrará una <literal>L</literal> al lado de los objetos
        bloqueados:</para>

      <screen>
$ svn status
  L    somedir
M      somedir/foo.c 

$ svn cleanup
$ svn status
M      somedir/foo.c
</screen>

    </sect2>


    <sect2 id="svn-ch-3-sect-7.3">
      <title><command>svn import</command></title>

      <para>The <command>svn import</command> command is a quick way
        to copy an unversioned tree of files into a repository,
        creating intermediate directories as necessary.</para>

      <screen>
$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/some/project
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
</screen>

      <para>El ejemplo anterior copia el contenido del directorio
        <filename>mytree</filename> debajo del directorio
        <filename>some/project</filename> en el repositorio:</para>

      <screen>
$ svn ls file:///usr/local/svn/newrepos/some/project
bar.c
foo.c
subdir/
</screen>

      <para>Note that after the import is finished, the original tree
        is <emphasis>not</emphasis> converted into a working copy.  To
        start working, you still need to <command>svn
        checkout</command> a fresh working copy of the tree.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 8 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-3-sect-8">
    <title>Summary</title>
        
      <para>Now we've covered most of the Subversion client
          commands.  Notable exceptions are those dealing with
          branching and merging (see <xref linkend="svn-ch-4"/>) and
          properties (see <xref linkend="svn-ch-7-sect-2"/>).
          However, you may want to take a moment to skim through <xref
          linkend="svn-ch-9"/> to get an idea of all the many
          different commands that Subversion has&mdash;and how you can
          use them to make your work easier.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
