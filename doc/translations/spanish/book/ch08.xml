<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<chapter id="svn-ch-8">
  <title>Información para desarrolladores</title>
  
  <simplesect id="svn-ch-8-sect-0">
    <para>Subversion es un proyecto de software open-source
      desarrollado bajo una licencia de software estilo Apache. El
      proyecto está respaldado económicamente por CollabNet, Inc.,
      una compañía de desarrollo de software con sede en California.
      La comunidad que se ha formado alrededor del desarrollo
      de Subversion siempre da la bienvenida a nuevos miembros
      que pueden conar su tiempo y atención al proyecto. A los
      voluntarios se les anima a ayudar de cualquier modo, ya sea
      encontrando y diagnosticando fallos, refinando el código fuente
      existente, o implementando por nuevas características.</para>
    
    <para>Este capítulo es para aquellos que desean asistir en
      la evolución continua de Subversion ensuciándose las manos
      con el código fuente.  Cubriremos algunos detalles íntimos
      del software, ese tipo de conocimiento técnico específico
      necesario por aquellos que desarrollan Subversion&mdash;o
      herramientas completamente nuevas basadas en las librerías
      de Subversion.  Si no prevee participar con el software a
      tal nivel, siéntase libre de ignorar este capítulo con la
      certeza de que su experiencia como usuario de Subversion no
      se verá afectada.</para>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  LAYERED LIBRARY DESIGN                          *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-1">
    <title>Diseño de librería por capas</title>

    <para>Subversion tiene un diseño modular, implementado como un
      grupo de librerías en C. Cada librería tiene un
      propósito e interfaz bien definidos, y la mayoría
      de los módulos se puede decir que existen en una
      de tres posibles capas&mdash;capa de repositorio,
      capa de acceso al repositorio (RA<footnote><para>N.T.:
      <quote>repository access</quote>.</para></footnote>), o capa
      de cliente. Examinaremos en breve estas capas, pero antes, vea
      un corto inventario de las librerías de Subversion en <xref
      linkend="svn-ch-8-table-1"/>.  En aras de la consistencia,
      nos referiremos a estas librerías por sus nombres de librería
      Unix sin extensión (por ejemplo: libsvn_fs, libsvn_wc,
      mod_dav_svn).</para>

    <table id="svn-ch-8-table-1">
      <title>Un corto inventario de las librerías de Subversion</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Librería</entry>
            <entry>Descripción</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>libsvn_client</entry> 
            <entry>Interfaz principal para programas cliente</entry>
          </row>
          <row>
            <entry>libsvn_delta</entry>
            <entry>Rutinas de diferenciado de árboles y texto</entry>
          </row>
          <row>
            <entry>libsvn_fs</entry>
            <entry>Librería del sistema de ficheros de
              Subversion</entry>
          </row>
          <row>
            <entry>libsvn_ra</entry>
            <entry>Utilidades comunes de acceso al repositorio y
              módulo cargador</entry>
          </row>
          <row>
            <entry>libsvn_ra_dav</entry>
            <entry>Módulo de acceso WebDav al repositorio</entry>
          </row>
          <row>
            <entry>libsvn_ra_local</entry>
            <entry>Módulo de acceso local al repositorio</entry>
          </row>
          <row>
            <entry>libsvn_ra_svn</entry>
            <entry>Módulo de acceso al repositorio mediante protocolo
              personalizable</entry>
          </row>
          <row>
            <entry>libsvn_repos</entry>
            <entry>Interfaz del repositorio</entry>
          </row>
          <row>
            <entry>libsvn_subr</entry>
            <entry>Miscelánea de subrutinas útiles</entry>
          </row>
          <row>
            <entry>libsvn_wc</entry>
            <entry>Librería para la gestión de la copia local de
              trabajo</entry>
          </row>
          <row>
            <entry>mod_authz_svn</entry>
            <entry>Módulo de autorización de Apache para acceso a
              repositorios Subversion vía WebDAV</entry>
          </row>
          <row>
            <entry>mod_dav_svn</entry>
            <entry>Módulo Apache para relacionar operaciones WebDAV
              con operaciones Subversion</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>El hecho de que la palabra <quote>miscelánea</quote>
      sólo aparezca una vez en <xref linkend="svn-ch-8-table-1"/>
      es una buena señal. El equipo de desarrollo de Subversion está
      seriamente dedicado a que las funcionalidades vivan en la
      capa y librería correctas.  Quizás la mayor de las ventajas
      del diseño modular es su falta de complejidad desde el punto
      de vista de un desarrollador. Como desarrollador, usted puede
      formular rápidamente este <quote>gran mapa</quote> <!-- TODO
      buscar traducción adecuada de big picture --> que le permite
      marcar la localización de ciertas partes de la funcionalidad
      con relativa facilidad.</para>

    <para>Otro gran beneficio de la modularidad es la posibilidad
      de reemplazar un módulo concreto con una nueva librería
      que implementa la misma API sin afectar al resto del código
      fuente. En cierto sentido, esto ya ocurre dentro de Subversion.
      Las librerías libsvn_ra_dav, libsvn_ra_local, y libsvn_ra_svn
      implementan la misma interfaz. Y las tres se comunican con la
      capa de repositorio;libsvn_ra_dav y libsvn_ra_svn lo hacen
      a través de la red, mientras que libsvn_ra_local accede
      directamente.</para>

    <para>El propio cliente es una muestra de la modularidad del
      diseño de Subversion.  A pesar de que Subversion por ahora
      sólo viene con un programa cliente de línea de comando, ya
      hay en desarrollo unos cuantos programas por parte de terceros
      que actúan como interfaces gráficas de Subversion. De nuevo,
      estos GUIs usan las mismas APIs que el cliente de línea
      de comando que viene de serie. La librería de Subversion
      libsvn_client es como una tienda de paso con la mayor parte
      de la funcionalidad necesaria para diseñar un cliente de
      Subversion (vea <xref linkend="svn-ch-8-sect-1.3"/>).</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.1">
      <title>Capa de repositorio</title>

      <para>Cuando nos referimos a la capa de respositorio de
        Subversion, en general estamos hablando de dos
        librerías&mdash;la librería de repositorio, y la librería
        del sistema de ficheros. Estas librerías proporcionan
        los mecanismos de almacenamiento e informe <!--TODO
        reporting? --> para las varias revisiones de sus datos
        bajo control de versiones. Esta capa está conectada a la
        capa cliente vía capa de acceso al repositorio, y son,
        desde el punto de vista del usuario de Subversion, las
        cosas <quote>al otro lado de la línea.</quote></para>

      <para>Al sistema de ficheros de Subversion se accede vía la
        API de libsvn_fs, y no se trata de un sistema de
        ficheros que uno instalaría en un sistema operativo
        (como ext2 de Linux o NTFS), sino un sistema de ficheros
        virtual. En lugar de almacenar <quote>ficheros</quote>
        y <quote>directorios</quote> como ficheros y directorios
        reales (vamos, el tipo que puede explorar usando su
        programa favorito de shell), usa un sistema de base de
        datos para sus mecanismos back-end <!-- TODO back-end? -->
        de almacenamiento.  Actualmente el sistema de base de datos
        que usa es la base de datos de Berkeley.
        <footnote>
          <para>La elección de la base de datos de Berkeley trajo
            varias características de forma automática que
            Subversion necesitaba, como integridad de datos,
            escrituras atómicas, recuperabilidad, y copias de
            seguridad en caliente.</para>
        </footnote>
        No obstante, en la comunidad de desarrolladores ha habido
        un considerable interés para que futuras versiones de
        Subversion tengan la capacidad para usar otros sistemas
        back-ends de base de datos, quizás a través de mecanismos
        como la Open Database Connectivity (ODBC).</para>

      <para>La API de sistema de ficheros exportada por libsvn_fs
        contiene el tipo de funcionalidad que esperaría de
        cualquier otro API de sistema de ficheros: puede crear
        y borrar ficheros y directorios, copiarlos y moverlos,
        modificar el contenido de ficheros, y un largo etcétera.
        También tiene características que no son tan comunes, como
        la habilidad de añadir, modificar o eliminar meta datos
        (<quote>propiedades</quote>) sobre cualquier fichero o
        directorio.  Además, el sistema de ficheros de Subversion
        es versionado, lo que significa que a medida que realiza
        cambios a su árbol de directorios, Subversion recuerda el
        aspecto que tenía el árbol antes de esos cambios. Y antes
        que los cambios anteriores. Y que los anteriores a los
        anteriores. Y así todo el camino de vuelta por el tiempo
        de versionado hasta el momento inicial en el cual comenzó
        a añadir cosas al sistema de ficheros.</para>

      <para>Todas las modificaciones que haga a su árbol se
        realizarán en el contexto de una transacción de
        Subversion. Lo siguiente es una rutina general simplificada
        para modificar su sistema de ficheros:</para>

      <orderedlist>
        <listitem>
          <para>Comience una transacción de Subversion.</para>
        </listitem>
        <listitem>
          <para>Realice sus cambios (adiciones, borrados,
            modificación de propiedades, etc.).</para>
        </listitem>
        <listitem>
          <para>Finalice su transacción.</para>
        </listitem>
      </orderedlist>

      <para>Una vez ha finalizado su transacción, las modificaciones
        a su sistema de ficheros se almacenan permanentemente como
        artefactos históricos <!-- TODO historical artifacts? -->.
        Cada uno de estos ciclos genera una nueva revisión de su
        árbol, y cada revisión es accesible para siempre como
        una instantánea inmutable de <quote>cómo estaban las
        cosas.</quote></para>

      <sidebar>
        <title>La distracción de la transacción</title>

        <para>La noción de una transacción de Subversion puede
          ser confundida fácilmente con el soporte de transacción
          proporcionado por la base de datos subyacente,
          especialmente dada su proximidad al código de base de
          datos en libsvn_fs. Ambos tipos de transacción existen
          para proporcionar atomicidad y aislamiento.  En otras
          palabras, las transacciones le permiten realizar
          un conjunto de acciones de una forma <quote>todo
          o nada</quote>&mdash;o bien todas las acciones del
          conjunto son completadas con éxito, o todas son tratadas
          como si <emphasis>ninguna</emphasis> de ellas hubiese
          ocurrido&mdash;y de un modo que no intefieran con otros
          procesos que actúan sobre los datos.</para>

        <para>Las transacciones de base de datos generalmente
          engloban pequeñas operaciones relacionadas con
          la modificación específica de datos (como cambiar el
          contenido de una fila en una tabla). Las transacciones de
          Subversion son mayores en ámbito, englobando operaciones de
          alto nivel como realizar modificaciones a un conjunto de
          ficheros y directorios que pretenden ser almacenados como
          la siguiente revisión del árbol del sistema de ficheros. Si
          eso no es suficientemente confuso, considere lo siguiente:
          ¡Subversion usa una transacción de base de datos durante
          la creación de una transacción de Subversion (por lo que
          si la creación de una transacción de Subversion falla,
          la base de datos tendrá el mismo aspecto que antes, como
          si nunca hubiésemos intentado crear nada)!</para>

        <para>Afortunadamente para los usuarios de la API del
          sistema de ficheros, el soporte de transacción
          proporcionado por el propio sistema de base de datos está
          oculto casi por completo (tal y como debería esperarse de
          un esquema de librerías correctamente modularizadas). Sólo
          cuando comienza a ahondar en la implementación del sistema
          de ficheros este tipo de cosas se vuelven visibles (o
          interesantes).</para>

      </sidebar>

      <para>La mayoría de la funcionalidad proporcionada por la
        interfaz del sistema de ficheros se muestra como acciones
        que trabajan sobre una ruta del sistema de ficheros.
        Es decir, desde un punto de vista externo, el mecanismo
        principal para describir y acceder a las revisiones
        individuales de ficheros y directorios son las cadenas
        con rutas como <filename>/foo/bar</filename>, igual que si
        estuviese tratando con ficheros y directorios a través de
        su programa favorito de línea de comando.  Añada nuevos
        ficheros y directorios pasando sus futuras rutas a las
        funciones correctas de la API. Obtenga información sobre
        ellos usando el mismo mecanismo.</para>

      <para>No obstante, a diferencia de la mayoría de los
        sistemas de ficheros, una ruta sola no es información
        suficiente para identificar un fichero o directorio
        en Subversion. Piense que el árbol de directorios
        es un sistema bidimensional, donde los nodos hermanos
        representan una especie de movimiento izquierda-derecha, y
        descender en subdirectorios un movimiento hacia abajo. <xref
        linkend="svn-ch-8-dia-1"/> muestra una representación típica
        de un árbol justo de ese modo.</para>

      <figure id="svn-ch-8-dia-1">
        <title>Ficheros y directorios en dos dimensiones</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>Por supuesto, el sistema de ficheros de Subversion
        tiene una genial tercera dimensión que muchos sistemas de
        ficheros no tienen&mdash;¡El tiempo!
        <footnote>
          <para>Entendemos que esto pueda ser un jarro de agua fría
            a todos los fans de la ciencia ficción, quienes
            durante mucho tiempo han considerado el tiempo como
            la <emphasis>cuarta</emphasis> dimensión, y pedimos
            disculpas si provocamos algún trauma emocional con
            nuestra aserción de una teoría diferente.</para>
        </footnote>
        En la interfaz del sistema de ficheros, casi toda función
        que tiene un parámetro de <parameter>ruta</parameter>
        espera también un parámetro <parameter>raíz</parameter>.
        Este parámetro <structname>svn_fs_root_t</structname>
        describe una revisión o una transacción de Subversion (la
        cual es normalmente una futura revisión), y proporciona
        ese contexto tridimensional necesario para entender la
        diferencia entre <filename>/foo/bar</filename> de la revisión
        32, y la misma ruta tal y como existe en la revisión 98.
        <xref linkend="svn-ch-8-dia-2"/> muestra la historia de
        versiones como una dimensión añadida al universo del sistema
        de ficheros de Subversion.</para>

      <figure id="svn-ch-8-dia-2">
        <title>Versionando el tiempo&mdash;¡la tercera dimensión!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <!-- Perhaps dig into the DAG/tree layers a bit here, talking
           about the hard-link design and how that affords such
           pleasures as cheap copies.  If "bubble-up" isn't covered
           twelve other times in the book, maybe give it a go here. -->

      <para>Tal y como mencionamos anteriormente, la API de libsvn_fs
        tiene el aspecto de cualquier otro sistema de ficheros,
        excepto por el hecho de tener la maravillosa capacidad
        de versionado. Fue diseñada para ser usada por cualquier
        programa interesado en un sistema de ficheros versionado. A
        su vez, Subversion está interesado en esa funcionalidad. Pero
        mientras que la API del sistema de ficheros debería ser
        suficiente para tener soporte básico de versionado de
        ficheros y directorios, Subversion quiere más&mdash;y es
        ahí donde entra en juego libsvn_repos.</para>
        
      <para>La librería de repositorio de Subversion (libsvn_repos)
        es básicamente una librería envoltorio sobre la funcionalidad
        del sistema de ficheros. Esta librería es responsable de
        crear la estructura del repositorio, asegurarse de que
        el sistema de ficheros subyacente está inicializado,
        etc. Libsvn_repos también implementa un conjunto de
        ganchos&mdash;scripts que son ejecutados por el código
        de repositorio cuando se realizan ciertas tareas. Estos
        scripts son útiles para notificar, autorizar, o cualquier
        cosa deseada por el administrador del repositorio. Este tipo
        de funcionalidad, y otras utilidades proporcionadas por la
        librería de repositorio, no están estrictamente relacionadas
        con la implementación de un sistema de ficheros versionados,
        razón por la cual fue colocada en su propia librería.</para>
      
      <para>Los desarrolladores que deseen usar la API de
        libsvn_repos se encontrarán con que no es un envoltorio
        completo sobre la interfaz del sistema de ficheros.
        Es decir, sólo ciertos eventos de categoría en el ciclo
        general de la actividad del sistema de ficheros están
        envueltos por la interfaz de repositorio.  Elgunos de éstos
        incluyen la creación y enviado de transacciones Subversion,
        y la modificación de propiedades de revisiones. Estos eventos
        particulares están envueltos por la capa de repositorio
        porque tienen enganches asociados con ellos. En el futuro,
        puede que otros eventos sean envueltos por la API de
        repositorio. Mientras tanto, el resto de la interacción con
        el sistema de ficheros continuará ocurriendo directamente
        via la API de libsvn_fs.</para>

      <para>Por ejemplo, aquí tiene un segmento de código que
        ilustra el uso de ambas interfaces (repositorio y sistema
        de ficheros) para crear una nueva revisión del sistema de
        ficheros en la cual se añade un directorio. Tenga en cuenta
        que en este ejemplo (y todos los demás del libro), la macro
        <function>SVN_ERR</function> simplemente verifica de forma
        booleana el código de retorno de la función que envuelve,
        y retorna si hay algún error.</para>

      <example id="svn-ch-8-sect-1.1-ex-1">
        <title>Usando la capa de repositorio</title>

        <programlisting>
/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, 
                                 &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%" SVN_REVNUM_T_FMT "'.\n", new_directory, youngest_rev);
    }
  else if (err->apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area 
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n", 
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n", 
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
} 
</programlisting>
      </example>

      <para>En el segmento de código anterior, se hacen llamadas
        tanto a las interfaces de repositorio como de sistema de
        ficheros. Igualmente podríamos haber enviado la transacción
        usando <function>svn_fs_commit_txn</function>. Pero la API
        del sistema de ficheros no sabe nada sobre los mecanismos
        de enganche de la librería del repositorio. Si quiere que
        su repositorio de Subversion realice automáticamente un
        conjunto de tareas no relacionadas con Subversion cada vez
        que envía una transacción (como por ejemplo, enviar un email
        que describe los cambios realizados en esa transacción
        a su lista de correo de desarrolladores), necesita
        usar la versión envoltorio de la función libsvn_repos
        apropiada&mdash;<function>svn_repos_fs_commit_txn</function>.
        Esta función en realidad ejecutará primero el script de
        enganche <literal>pre-commit</literal> si existe, entonces
        enviará la transacción, y finalmente ejecutará el script
        de enganche <literal>post-commit</literal>.  Los ganchos
        proporcionan un mecanismo especial de información que no
        pertenece a la librería del núcleo del sistema de ficheros.
        (Para más información sobre los ganchos de repositorio de
        Subversion, lea <xref linkend="svn-ch-5-sect-2.1" />.)</para>
      
      <para>El requisito del mecanismo de enganches es una de las
        razones para abstraer la librería de repositorio del código
        del sistema de ficheros.  La API libsvn_repos proporciona
        algunas otras utilidades importantes para Subversion. Entre
        ellas está la capacidad para:</para>

      <orderedlist>
        <listitem>
          <para>crear, abrir, destruír y realizar los pasos de
            recuperación sobre un repositorio Subversion y el sistema
            de ficheros incluido en el mismo.</para>
        </listitem>
        <listitem>
          <para>describir las diferencias entre dos árboles de
            sistema de ficheros.</para>
        </listitem>
        <listitem>
          <para>obtener el informe de cambios asociado con todas
            (o algunas) las revisiones en las cuales un conjunto de
            ficheros fue modificado en el sistema de ficheros.</para>
        </listitem>
        <listitem>
          <para>generar un <quote>volcado</quote> legible por un
            humano del sistema de ficheros, una representación
            completa de las revisiones en el sistema de
            ficheros.</para>
        </listitem>
        <listitem>
          <para>procesar el formato de ese volcado, cargando
            revisiones volcadas en un repositorio Subversion
            diferente.</para>
        </listitem>
      </orderedlist>

      <para>A medida que Subversion continúa evolucionando, la
        librería de repositorio seguirá creciendo con la librería
        del sistema de ficheros para ofrecer una mayor funcionalidad
        y soporte configurable de opciones.</para>

    </sect2>

    <!-- ****************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.2">
      <title>Capa de acceso al repositorio</title>

      <para>Si la capa de repositorio de Subversion está <quote>al
        otro lado de la línea</quote>, la capa de acceso al
        repositorio está en la propia línea.  Destinada a serializar
        los datos entre las librerías cliente y el repositorio, esta
        capa incluye la librería cargadora del módulo libsvn_ra,
        los propios módulos RA (que por ahora son libsvn_ra_dav,
        libsvn_ra_local, y libsvn_ra_svn), y cualquier librería
        adicional necesaria por uno o varios de esos módulos RA,
        como por ejemplo el módulo mod_dav_svn de Apache que se
        comunica con libsvn_ra_dav o el servidor de libsvn_ra_svn,
        <command>svnserve</command>.</para>

      <para>Dado que Subversion usa URLs para identificar los
        recursos del repositorio, la porción de protocolo del
        esquema URL (normalmente <literal>file:</literal>,
        <literal>http:</literal>, <literal>https:</literal>, o
        <literal>svn:</literal>) es usada para determinar qué módulo
        RA se encargará de las comunicaciones.  Cada módulo registra
        una lista de los protocolos que sabe <quote>hablar</quote>
        por lo que el cargador de RA puede, en tiempo de ejecución,
        determinar qué modulo usar para cada tarea concreta. Puede
        determinar qué módulos RA están disponibles en el cliente
        de línea de comando de Subversion, y qué protocolos dice
        soportar, ejecutando <command>svn --version</command>:</para>
     
      <screen>
$ svn --version
svn, version 1.0.1 (r9023)
   compiled Mar 17 2004, 09:31:13

Copyright (C) 2000-2004 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
This product includes software developed by CollabNet (http://www.Collab.Net/).

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' schema
  - handles 'https' schema
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' schema
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' schema
</screen>
    
      <sect3 id="svn-ch-8-sect-1.2.1">
        <title>RA-DAV (Acceso al repositorio usando HTTP/DAV)</title>

        <para>La librería libsvn_ra_dav está diseñada para ser
          usada por clientes que están siendo ejecutado en diferentes
          máquinas que los servidores con los que se comunican,
          específicamente servidores a los que se ha alcanzado
          usando URLs que contienen las porciones de protocolo
          <literal>http:</literal> o <literal>https:</literal>. Para
          entender cómo funciona este módulo, deberíamos mencionar
          primero un grupo de componentes clave en esta configuración
          particular de capa de acceso al repositorio&mdash;el
          poderoso servidor HTTP Apache, y la librería cliente Neon
          HTTP/WebDAV.</para>
  
        <para>El servidor principal de red de Subversion es el
          servidor HTTP Apache.  Apache es un proceso servidor
          open-source extensible probado por mucho tiempo, preparado
          para uso serio. Puede soportar una elevada carga de red
          y se ejecuta en muchas plataformas. El servidor Apache
          soporta una variedad de protocolos de autenticación
          estandar, y puede expandirse por medio de módulos para
          soportar muchos más. También soporta optimizaciones de
          red como pipelining y caching.  <!--TODO revisar en
          la documentación traducida de Mozilla o Apache cómo
          traducen pipelining y caching--> Usando Apache como
          servidor, Subversion obtiene todas estas características
          gratuítamente. Y dado que la mayoría de los cortafuegos
          ya permiten que pase el tráfico HTTP, los administradores
          de sistemas normalmente no tienen que cambiar siquiera
          la configuración de su cortafuegos para permitir que
          Subversion funcione.</para>
  
        <para>Subversion usa HTTP y WebDAV (junto con DeltaV)
          para comunicarse con un servidor Apache. Puede leer
          más sobre esto en la sección WebDAV de este capítulo,
          pero en pocas palabras, WebDAV y DeltaV son extensiones
          al protocolo HTTP 1.1 estándar que permiten compartir y
          versionar ficheros a través de la web. Apache 2.0 viene
          con mod_dav, un módulo Apache que entiende las extensiones
          DAV de HTTP.  El propio Subversion proporciona mod_dav_sv,
          que es otro módulo de Apache que funciona junto con mod_dav
          (realmente, es su motor) para proporcionar implementaciones
          específicas de Subversion de WebDAV y DeltaV.</para>

        <para>Cuando se comunica con un repositorio por HTTP,
          la librería cargadora RA selecciona libsvn_ra_dav como el
          módulo correcto de acceso. El cliente de Subversion realiza
          llamadas sobre la interfaz genérica RA, y libsvn_ra_dav
          relaciona esas llamadas (que tienden a englobar acciones
          Subversion a gran escala) con un conjunto de peticiones
          HTTP/WebDAV. Usando la librería Neon, libsvn_ra_dav
          transmite esas peticiones al servidor Apache. Apache
          recibe estas peticiones (exáctamente igual que con las
          peticiones genéricas HTTP que su navegador pudiera hacer),
          se da cuenta de que estas peticiones están dirigidas
          a una URL que está configurada como una localización
          DAV (usando la directiva <sgmltag>Location</sgmltag>
          en <filename>httpd.conf</filename>), y pasa la petición
          a su propio módulo mod_dav. Configurado correctamente,
          mod_dav sabe que debe usar mod_dav_svn de Subversion para
          cualquier necesidad relacionada con el sistema de ficheros,
          a diferencia del módulo genérico mod_dav_fs que viene
          con Apache.  Así que finalmente el cliente se comunica
          con mod_dav_svn, que enlaza directamente con la capa de
          repositorio de Subversion.</para>
  
        <para>Pero eso es una descripción simplificada de los
          intercambios reales que ocurren. Por ejemplo, el
          repositorio Subversion podría estar protegido por
          las directivas de autorización de Apache. Esto podría
          significar que los intentos iniciales de comunicación
          con el repositorio podrían ser rechazados por Apache
          debido al código de autorización. En esta situación,
          libsvn_ra_dav recibe la notificación de Apache de que no
          se proporcionaron suficientes datos de identificación, y
          llama de vuelta a la capa cliente para obtener algunos
          datos actualizados de autenticación.  Si los datos se
          proporcionan correctamente, y el usuario tiene los
          permisos que Apache necesita, el siguiente intento
          automático de libsvn_ra_dav para realizar la operación
          original será aceptado, y todo irá bien.  Si no se puede
          proporcionar suficiente información de autenticación,
          la petición fallará, y el cliente informará del fallo
          al usuario.</para>
  
        <!-- A diagram here? -->
  
        <para>Gracias al uso de Neon y Apache, Subversion también
          obtiene funcionalidad gratuita en algunas otras áreas
          complejas. Por ejemplo, si Neon encuentra las librerías
          OpenSSL, permitirá al cliente de Subversion intentar
          usar comunicaciones cifradas con SSL con el servidor
          Apache (cuyo módulo mod_ssl puede <quote>hablar el
          lenguaje</quote>).  Además, tanto Neon como mod_deflate de
          Apache pueden entender el algoritmo <quote>deflate</quote>
          (el mismo usado por los programas PKZIP y gzip), por lo que
          las peticiones pueden ser enviadas en trozos comprimidos
          más pequeños a través del cable. Otras características
          complejas que Subversion espera soportar en el futuro
          incluyen la capacidad de manejar de forma automática las
          redirecciones indicadas por el servidor (por ejemplo,
          cuando un repositorio se mueve a otra nueva URL canónica)
          y obtener la ventaja del pipelining HTTP.</para>
  
        <!-- Talk about another difference between CVS and Subversion.
             CVS users had to specify which auth mechanism to use
             (with :ext: vs. :pserver:) and whether or not to use
             compressed communications (with the -z option).  In
             Subversion, Apache takes some of that responsibility.
             The server will tell the client whether it can understand
             compression, and ... hmm.  Is this really true? -->

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.2">
        <title>RA-SVN (Acceso al repositorio usando protocolo propio)</title>

        <para>Además del protocolo estándar HTTP/WebDAV, Subversion
          también proporciona una implementación RA que usa un
          protocolo propio.  El módulo libsvn_ra_svn implementa su
          propia conectividad por red, y se comunica con un servidor
          <!-- TODO stand-alone podría traducirse como independiente,
          pero pierde "gancho" --> autosuficiente&mdash;el
          programa <filename>svnserve</filename>&mdash;
          en la máquina que almacena el repositorio. Los
          clientes acceden al repositorio usando el esquema
          <literal>svn://</literal>.</para>

        <para>Esta implementación RA carece de la mayoría de las
          ventajas de Apache mencionadas en la sección anterior;
          no obstante, puede ser atractiva para algunos
          administradores de sistemas. Es dramáticamente más
          fácil de configurar y ejecutar; configurar un proceso
          <filename>svnserve</filename> es casi instantáneo.
          También es mucho más pequeño (en líneas de código) que
          Apache, haciéndolo más fácil de auditar, <!-- TODO ¿auditar
          o revisar? --> por razones de seguridad u otras. Además,
          algunos administradores de sistemas pueden tener ya
          instalada una infraestructura de seguridad SSH, que quieren
          que Subversion aproveche. Los clientes usando ra_svn pueden
          canalizar fácilmente el protocolo por SSH.</para>

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.3">
        <title>RA-Local (Acceso directo al repositorio)</title>

        <para>No todas las comunicaciones con un repositorio
          Subversion requieren un todopoderoso proceso servidor y
          una capa de red. Para los usuarios que simplemente desean
          acceder a los repositorios de sus discos duros locales,
          pueden hacerlo usando URLs <literal>file:</literal> y la
          funcionalidad proporcionada por libsvn_ra_local. Este
          módulo RA enlaza directamente con las librerías de
          repositorio y sistema de ficheros, por lo que no se
          requiere comunicación por red en absoluto.</para>

        <para>Subversion requiere que el nombre del servidor
          incluido como parte de la URL <literal>file:</literal>
          esté vacío o sea <literal>localhost</literal>, y
          que no exista especificación alguna de puerto. En
          otras palabras, las URLs deberían ser como
          <literal>file://localhost/ruta/al/repositorio</literal>
          o <literal>file:///ruta/al/repositorio</literal>.</para>

        <para>Además, tenga en cuenta que las URLS
          <literal>file:</literal> de Subversion no pueden ser
          usadas en un navegador normal al igual que con la
          URL <literal>file:</literal> típica.  Cuando intenta
          visualizar una URL <literal>file:</literal> en un
          navegador normal, lee y muestra el contenido del fichero
          que está en ese lugar examinando el sistema de ficheros
          directamente. No obstante, los recursos de Subversion
          existen en un sistema de ficheros virtual (vea <xref
          linkend="svn-ch-8-sect-1.1"/>), y su navegador no
          será capaz de entender cómo leer este sistema de
          ficheros.</para>

      </sect3>

      <sect3 id="svn-ch-8-sect-1.2.4">
        <title>Su librería RA aquí</title>

        <para>Para aquellos que deseen acceder al repositorio
          Subversion usando todavía otro protocolo, ¡para eso
          precisamente está modularizada la capa de acceso al
          repositorio! Los desarrolladores pueden simplemente
          escribir una nueva librería que implemente la interfaz
          RA en un lado y se comunique con el repositorio por
          el otro. Su nueva librería puede usar protocolos
          de red existentes, o puede inventarse uno propio.
          Puede usar llamadas de comunicación inter-proceso
          (IPC), o&mdash;tiremos la casa por la ventana, ¿de
          acuerdo&mdash;podría incluso implementar un protocolo
          basado en email. Subversion proporciona las APIs; usted
          proporciona la creatividad.</para>

      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-1.3">
      <title>Capa cliente</title>
      
      <para>En el lado del cliente, la copia local de trabajo de
        Subversion es donde ocurre toda la acción. El grueso de la
        funcionalidad implementada por las librerías en el lado
        del cliente existe con el único propósito de gestionar
        copias locales de trabajo&mdash;directorios llenos de
        ficheros y otros subdirectorios que sirven a modo de
        <quote>reflejo</quote> local y editable de una o más
        localizaciones de repositorio&mdash;y propagar cambios
        hacia y desde la capa de acceso al repositorio.</para>

      <para>La librería de Subversion de copias locales de trabajo,
        libsvn_wc, es directamente responsable de gestionar los
        datos en las copias locales.  Para realizar esta tarea,
        la librería almacena información administrativa sobre cada
        directorio dentro de un subdirectorio especial. Este
        subdirectorio, llamado <filename>.svn</filename>,
        está presente en cada directorio de la copia local y
        contiene varios ficheros y directorios que almacenan el
        estado y proporcionan un espacio de trabajo privado para
        acciones administrativas.  Para aquellos familiarizados
        con CVS, este subdirectorio <filename>.svn</filename> es
        similar en propósito a los directorios administrativos
        <filename>CVS</filename> encontrados en las copias de
        trabajo locales de CVS.  Para más información sobre el
        área administrativa <filename>.svn</filename>, vea <xref
        linkend="svn-ch-8-sect-3"/>en este capítulo.</para>

      <para>La libería cliente de Subversion, libsvn_client, tiene
        la más amplia responsabilidad; su trabajo es reunir la
        funcionalidad de la librería de copia local de trabajo y la
        de la capa de acceso al repositorio, y entonces proporcionar
        la API de mayor nivel para cualquier aplicación que desee
        realizar acciones generales de control de revisiones. Por
        ejemplo, la función <function>svn_client_checkout</function>
        recibe una URL como parámetro. La función pasa la URL a la
        capa RA y abre una sesión autenticada con un repositorio en
        particular. Entonces le pregunta al repositorio por un árbol
        concreto y envía este árbol a la librería de copia local de
        trabajo, la cual escribe entonces una copia local de trabajo
        completa en el disco (directorios <filename>.svn</filename>
        y demás incluidos).</para>

      <para>La librería cliente está diseñada para que pueda ser
        usada por cualquier aplicación. Aunque el código fuente de
        Subversion incluye un cliente estándar de línea de comando,
        debería ser muy sencillo escribir cualquier número de
        clientes gráficos sobre esta librería cliente. Nuevas
        interfaces gráficas (o realmente, cualquier cliente)
        para Subversion no tienen que ser envoltorios precarios
        sobre el cliente incluído de línea de comando&mdash;tienen
        acceso completo vía la API de libsvn_client a la misma
        funcionalidad, datos, y mecanismos de retrollamada usados
        por el cliente de línea de comando.</para>

      <sidebar>
        <title>Acceso directo&mdash;unas palabras sobre corrección</title>

        <para>¿Por qué debería su programa de interfaz gráfica
          acceder directamente a libsvn_client en lugar de
          actuar como envoltorio sobre el programa de línea de
          comando? Aparte de ser simplemente más eficiente, esto
          puede solucionar potenciales problemas de corrección. Un
          programa de línea de comando (como el que trae Subversion)
          que accede a la librería cliente necesita traducir con
          efectividad las respuestas y bits de datos solicitados
          desde tipos de datos de C a alguna forma de salida legible
          por un ser humano. Este tipo de traducción puede tener
          pérdidas. Es decir, un programa puede que no muestre
          toda la información cosechada a través de la API, o
          puede combinar bits de información para compactar la
          representación.</para>

        <para>Si envuelve a un programa de línea de comando de este
          tipo con otro programa, el segundo sólo tiene acceso a la
          información ya interpretada (que como hemos mencionado, es
          posiblemente incompleta), que <emphasis>de nuevo</emphasis>
          debe ser traducida a <emphasis>su</emphasis> formato
          de representación.  Con cada capa de envoltorio, la
          integridad de los datos originales es potencialmente
          corrompida más y más, igual que el resultado de hacer una
          copia de una copia (de una copia &hellip;) de su cinta de
          audio o vídeo favorita.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  USING THE APIS                                  *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-2">
    <title>Usando las APIs</title>

    <para>Desarrollar aplicaciones usando las APIs de las librerías
      de Subversion es bastante sencillo. Todos los ficheros
      de cabecera públicos se encuentran en el directorio
      <filename>subversion/include</filename> del código fuente.
      Estos ficheros de cabecera son copiados en su sistema cuando
      compila e instala Subversion a partir del código fuente. Estos
      ficheros de cabecera recogen por completo las funciones y
      tipos de datos accesibles por los usuarios de las librerías
      de Subversion.</para>

    <para>La primera cosa que puede observar es que los tipos de
      datos y funciones de Subversion están protegidos por un espacio
      de nombrado <!-- TODO incluir NT sobre namespace? -->. Todo
      símbolo público comienza con <literal>svn_</literal>,
      seguido por un breve código que representa la librería
      en la cual es definido (como <literal>wc</literal>,
      <literal>client</literal>, <literal>fs</literal>,
      etc.), seguido por un único carácter de subrayado
      (<literal>_</literal>) y por último el resto del nombre
      del símbolo. Las funciones semi públicas (usadas por varios
      ficheros de código fuente de una librería pero no fuera de
      ésta, y contenidas en los propios directorios de las librerías)
      difieren de este esquema de nombres en el uso del carácter
      de subrayado tras el código de librería, ya que usan doble
      carácter de subrayado (<literal>__</literal>). Las funciones
      que son privadas de un fichero particular no tienen prefijos
      especiales, y son declaradas como <literal>static</literal>.
      Por supuesto, el compilador no tiene interés alguno por estas
      convenciones de nombrado, pero ayudan a clarificar el ámbito
      de una función o tipo de datos.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.1">
      <title>La librería Apache Portable Runtime<!--TODO verificar si hay traducción --></title>

      <para>Junto con los tipos de datos de Subversion, verá muchas
        referencias a tipos de datos que comienzan con
        <literal>apr_</literal>&mdash;símbolos de la librería
        Apache Portable Runtime (APR).  APR es la librería de
        portabilidad de Apache, originada a partir del código fuente
        del servidor en un intento de separar el código dependiente
        del SO de las porciones de código independientes del SO. El
        resultado es una librería que proporciona una API genérica
        para realizar operaciones que difieren ligeramente &mdash;o
        terriblemente&mdash; de SO a SO. Aunque el servidor HTTP
        Apache fue obviamente el primer usuario de la librería
        APR, los desarrolladores de Subversion reconocieron
        inmediatamente el valor de usar también APR. Esto significa
        que prácticamente no hay porciones de código dependiente
        del SO en Subversion. También, significa que el cliente
        Subversion se puede compilar y ejecutar dondequiera que lo
        haga el servidor. Actualmente esta lista incluye todas las
        variantes de Unix, Win32, BeOS, OS/2, y Mac OS X.</para>

      <para>Además de proporcionar implemntaciones consistentes de
        llamadas de sistema que difieren entre sistemas operativos,
        <footnote>
          <para>Subversion usa llamadas de sistema y tipos de datos
            ANSI siempre que es posible.</para>
        </footnote> APR le da a Subversion acceso inmediato a muchos
        tipos de datos, como arrays dinámicos o tablas hash<!--
        TODO picadillo? -->.  Subversion usa en gran medida estos
        tipos a lo largo del código fuente. Pero quizás el tipo de
        datos APR más usado, encontrado en casi todo prototipo de la
        API de Subversion, es <literal>apr_pool_t</literal>&mdash;el
        área de memoria de APR.  Subversion usa internamente áreas
        de memoria para todas las peticiones de reserva de memoria
        que necesita (excepto cuando una librería externa requiere
        un esquema de gestión de memoria diferente para los datos
        que pasan por su API), <footnote>
          <para>Neon y la base de datos de Berkeley son tales
            librerías.</para>
        </footnote> y aunque una persona que programa usando las
        APIs de Subversion no está obligada a hacer lo mismo, tiene
        que proporcionar áreas de memoria a las funciones de la API
        que los necesitan. Esto significa que los usuarios de la API
        de Subversion también tienen que enlazar con APR, y deben
        llamar <function>apr_initialize()</function> para iniciar el
        subsistema APR, y entonces adquirir un área de memoria para
        usarla con las llamadas de la API de Subversion. Vea <xref
        linkend="svn-ch-8-sect-5"/> para más información.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.2">
      <title>Requisitos de URL y ruta</title>

      <para>Con operaciones de control de versiones remotas como
        razón de la existencia de Subversion, tiene sentido
        prestar atención al soporte de internacionalización
        (i18n<footnote><para>N.T.: Forma breve de referirse
        a la palabra internacionalización, en inglés
        <quote>internationalization</quote>, que comienza con una
        <quote>i</quote>, seguida de 18 carácteres y terminada en
        <quote>n</quote>.</para> </footnote>). Después de todo,
        aunque <quote>remotas</quote> pueda significar <quote>de
        un lado a otro de la oficina</quote>, podría significar
        perfectamente <quote>de un lado a otro del globo.</quote>.
        Para facilitar esto, todas las interfaces públicas de
        Subversion que aceptan parámetros de rutas esperan que éstas
        sean canónicas, y codificadas en UTF-8.  Esto significa,
        por ejemplo, que cualquier nuevo cliente binario que use
        la interfaz libsvn_client necesita convertir primero las
        rutas de la codificación específica local a UTF-8 antes
        de pasarlas a las librerías de Subversion, y entonces
        reconvertir cualquier resultado generado por Subversion de
        nuevo en la codificación local antes de usar esas rutas con
        propósitos no relacionados con Subversion. Afortunadamente,
        Subversion proporciona un conjunto de funciones (vea
        <filename>subversion/include/svn_utf.h</filename>) que
        pueden ser usadas por cualquier programa para realizar
        estas conversiones.</para>

      <para>Además, las APIs de Subversion requieren que todos los
        parámetros con URLs estén codificados correctamente
        como URIs. Así, que en lugar de pasar <systemitem
        class="url">file:///home/nombreusuario/Mi
        fichero.txt</systemitem> como la
        URL de un fichero llamado <literal>Mi
        fichero.txt</literal>, usted necesita pasar <systemitem
        class="url">file:///home/nombreusuario/Mi%20fichero.txt</systemitem>.
        De nuevo, Subversion proporciona
        funciones de ayuda que su aplicación puede
        usar&mdash;<function>svn_path_uri_encode</function> y
        <function>svn_path_uri_decode</function>, para codificar
        y decodificar URIs, respectivamente.</para>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-2.3">
      <title>Usando lenguajes distintos de C y C++</title>

      <para>Si está interesado en usar las librerías de Subversion
        junto con algo que no sea un programa en C&mdash;digamos que
        un script en Python o una aplicación en Java&mdash;Subversion
        tiene un soporte básico para esto vía el generador
        simplificado de envoltorios e interfaces (SWIG)
        <footnote><para>N.T.: <quote>Simplified wrapper and interface
        generator</quote> en inglés</para></footnote>. Los
        enlaces SWIG para Subversion se encuentran en
        <filename>subversion/bindings/swig</filename> y están
        madurando lentamente hasta llegar a un estado usable. Estos
        enlaces le permiten realizar llamadas a funciones de la
        API de Subversion indirectamente, usando los envoltorios
        que traducen los tipos de datos nativos de su lenguaje de
        script a los tipos de datos necesarios por las librerías
        C de Subversion.</para>

      <para>Hay otro beneficio al acceder a las APIs de Subversion
        a través de un enlace con otro lenguaje&mdash;simplicidad. En
        general, lenguajes como Python y Perl son mucho más flexibles
        y fáciles de usar que C o C++. Los tipos de datos de alto
        nivel y la verificación de tipos por contexto proporcionados
        por estos lenguajes son a menudo mejores manejando la
        información que viene de los usuarios. Como ya sabrá, los
        humanos son muy hábiles fastidiando los datos de entrada de
        un programa, y los lenguajes de script tienden a manejar
        tales incorrecciones con más gracilidad. Por eso usar una
        interfaz y conjunto de librerías altamente optimizados,
        basados en C, combinados con un lenguaje poderoso, flexible,
        es tan atractivo.</para>

      <para>Echemos un vistazo a un ejemplo que usa los envoltorios
        SWIG de Subversion para Python. Nuestro ejemplo hará
        exáctamente lo mismo que el último. ¡Fíjese en la diferencia
        de tamaño y complejidad de esta versión de la función!</para>

      <example id="svn-ch-8-sect-2.3-ex-1">
        <title>Usando la capa de repositorio con Python</title>

        <programlisting>
from svn import fs
import os.path

def crawl_filesystem_dir (root, directory, pool):
  """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
  a list of all the paths at or below DIRECTORY.  Use POOL for all 
  allocations."""

  # Get the directory entries for DIRECTORY.
  entries = fs.dir_entries(root, directory, pool)

  # Initialize our returned list with the directory path itself.
  paths = [directory]

  # Loop over the entries
  names = entries.keys()
  for name in names:
    # Calculate the entry's full path.
    full_path = os.path.join(basepath, name)

    # If the entry is a directory, recurse.  The recursion will return
    # a list with the entry and all its children, which we will add to
    # our running list of paths.
    if fs.is_dir(fsroot, full_path, pool):
      subpaths = crawl_filesystem_dir(root, full_path, pool)
      paths.extend(subpaths)

    # Else, it is a file, so add the entry's full path to the FILES list.
    else:
      paths.append(full_path)

  return paths
</programlisting>
      </example>

      <para>Una implementación en C del ejemplo anterior se alargaría
        bastante más. La misma rutina en C necesitaría prestar
        especial atención al uso de la memoria, y tendría que usar
        tipos de datos de propios para representar las tablas hash
        y la lista de rutas. Python tiene tablas hash (llamadas
        <quote>diccionarios</quote>) y listas como tipos de datos
        nativos, y proporciona una maravillosa selección de métodos
        para operar sobre esos tipos de datos. Y dado que Python
        usa recolección de basura y recuento de referencias,
        los usuarios del lenguaje no necesitan preocuparse con la
        reserva y liberación de memoria.</para>

      <para>En la sección previa de este capítulo, mencionamos la
        interfaz <filename>libsvn_client</filename>, y cómo existe
        con el único propósito de simplificar el proceso de escribir
        un cliente de Subversion. A continuación presentamos un breve
        ejemplo que muestra cómo esta librería puede ser usada vía
        los envoltorios SWIG. ¡En sólo unas pocas línea de Python,
        puede obtener una copia de trabajo local de Subversion
        totalmente funcional!</para>

      <example id="svn-ch-8-sect-2.3-ex-2">
        <title>Un script simple para obtener una copia de trabajo local.</title>

        <programlisting>
#!/usr/bin/env python
import sys
from svn import util, _util, _client

def usage():
  print "Usage: " + sys.argv[0] + " URL PATH\n"
  sys.exit(0)

def run(url, path):
  # Initialize APR and get a POOL.
  _util.apr_initialize()
  pool = util.svn_pool_create(None)

  # Checkout the HEAD of URL into PATH (silently)
  _client.svn_client_checkout(None, None, url, path, -1, 1, None, pool)

  # Cleanup our POOL, and shut down APR.
  util.svn_pool_destroy(pool)
  _util.apr_terminate()

if __name__ == '__main__':
  if len(sys.argv) != 3:
    usage()
  run(sys.argv[1], sys.argv[2])
</programlisting>
      </example>

      <para>Los envoltorios de Subversion para otros lenguajes
        desafortunadamente tienden a no recibir el mismo nivel
        de atención redibido por los módulos principales de
        Subversion. No obstante, se han dado pasos significativos
        hacia la creación de enlaces funcionales para Python,
        Perl y Java. Una vez tenga los ficheros del interfaz SWIG
        configurados correctamente, la generación de envoltorios
        específicos para todos los lenguajes soportados por SWIG
        (que actualmente incluye versiones de C#, Guile, Java,
        MzScheme, OCaml, Perl, PHP, Python, Ruby y Tcl) debería ser
        teóricamente trivial. A pesar de esto, todavía se requiere
        un poco de programación extra para compensar las complejas
        APIs con las que SWIG necesita ayuda. Para más información
        sobre SWIG, vea la página web del proyecto en <systemitem
        class="url">http://www.swig.org/</systemitem>.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  INSIDE THE WORKING COPY ADMINISTRATION AREA     *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-3">
    <title>Dentro del área de administración de la copia local de trabajo</title>
    
    <para>Tal y como mencionamos anteriormente, cada directorio de
      una copia local de trabajo realizada con Subversion contiene
      un subdirectorio especial llamado <filename>.svn</filename>
      que almacena datos administrativos sobre ese directorio
      local de trabajo. Subversion usa la información de
      <filename>.svn</filename> para llevar la pista de cosas
      como:</para>

    <itemizedlist>
      <listitem>
        <para>Qué lugar(es) del repositorio está representado por los
          ficheros y subdirectorios del directorio de la copia local
          de trabajo.</para>
      </listitem>
      <listitem>
        <para>Qué revisión de cada uno de esos ficheros y directorios
          está actualmente presente en la copia local.</para>
      </listitem>
      <listitem>
        <para>Cualquier <!--TODO property--> atributo definido por el
          usuario que pudiese estár asociado a esos ficheros y
          directorios.</para>
      </listitem>
      <listitem>
        <para>Copias prístinas (no editadas) de los ficheros de
          la copia local de trabajo.</para>
      </listitem>
    </itemizedlist>

    <para>A pesar de que hay varios otros datos almacenados en
      el directorio <filename>.svn</filename>, examinaremos sólo
      un puñado de los elementos más importantes.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-3.1">
      <title>El fichero de entradas</title>

      <para>Quizás el fichero más importante en el directorio
        <filename>.svn</filename> es el fichero
        <filename>entries</filename>.  El fichero de entradas es
        un documento XML que contiene el grueso de la información
        administrativa sobre un recurso versionado en el directorio
        de la copia local de trabajo.  Es el fichero que lleva
        la pista a las URLs de repositorio, revisiones prístinas,
        sumas de control de ficheros, textos prístinos y fechas de
        modificación de propiedades, información de planificación y
        estado de conflicto, última información conocida de cambios
        en el repositorio (autor, revisión, fecha de modificación),
        historia de la copia local&mdash;¡prácticamente todo lo que
        un cliente de Subversion puede estar interesado en saber
        sobre un recurso versionado (o por versionar)!</para>

      <sidebar>
        <title>Comparando las áreas administrativas de Subversion
          y CVS</title>

        <para>Un vistazo dentro del típico directorio
          <filename>.svn</filename> revela más cosas <!-- TODO turns
          up a bit more, ¿ein? --> que lo que CVS mantiene en su
          directorio administrativo <filename>CVS</filename>. El
          fichero <filename>entries</filename> contiene
          XML que describe el estado actual del directorio
          de la copia local de trabajo, y básicamente
          sirve para los propósitos de los ficheros de CVS
          <filename>Entries</filename>, <filename>Root</filename>,
          y <filename>Repository</filename> combinados.</para>

      </sidebar>

      <para>A continuación mostramos un ejemplo de un fichero de
        entradas real:</para>

      <example id="svn-ch-8-sect-3-ex-1">
        <title>Contenido de un fichero
          <filename>.svn/entries</filename> típico.</title>
        <programlisting>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name="svn:this_dir"
   committed-date="2002-09-24T17:12:44.064475Z"
   url="http://svn.red-bean.com/tests/.greek-repo/A/D"
   kind="dir"
   revision="1"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2002-09-26T21:09:02.000000Z"
   committed-date="2002-09-24T17:12:44.064475Z"
   checksum="QSE4vWd9ZM0cMvr7/+YkXQ=="
   kind="file"
   prop-time="2002-09-26T21:09:02.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   url="http://svn.red-bean.com/tests/.greek-repo/A/B/delta"
   name="delta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</programlisting>
      </example>

      <para>Tal y como puede ver, el fichero entries es esencialmente
        una lista de entradas. Cada etiqueta <sgmltag>entry</sgmltag>
        representa una de tres posibles cosas: el propio directorio
        de la copia local (entrada conocida como <quote>este
        directorio</quote>, y caracterizada por tener un valor
        vacío para su atributo <structfield>name</structfield>),
        un fichero en esa copia local (caracterizado por tener
        en su atributo <structfield>kind</structfield> el valor
        <literal>"file"</literal>), o un subdirectorio en esa
        copia local (<structfield>kind</structfield> en este caso
        tendrá el valor <literal>"dir"</literal>). Los ficheros
        y subdirectorios cuyas entradas ya están almacenadas en
        este fichero estan o bien bajo control de versiones, o
        (como en el caso del fichero <filename>zeta</filename> más
        arriba) están programados para ser puestos bajo control
        de versiones la siguiente vez que el usuario envíe los
        cambios de este directorio al repositorio. Cada entrada
        tiene un nombre único, y cada entrada es de tipo nodo <!--
        TODO seguro?-->.</para>

      <para>Los desarrolladores deben tener presentes algunas
        reglas especiales que Subversion usa cuando lee y escribe
        sus ficheros <filename>entries</filename>. Aunque cada
        entrada tiene asociada una revisión y URL, fíjese que no toda
        etiqueta <sgmltag>entry</sgmltag> en el fichero de ejemplo
        tiene un atributo <structfield>revision</structfield> o
        <structfield>url</structfield> asociado a ella.  Subversion
        permite que las entradas no almacenen explícitamente esos
        dos atributos cuando sus valores son iguales que (en el
        caso de <structfield>revision</structfield>) o triviales
        de calcular a partir de
        <footnote>
          <para>Es decir, la URL de la entrada es igual que la
            concatenación de la URL del directorio padre y el nombre
            de la entrada.</para>
        </footnote>
        (en el caso de <structfield>url</structfield>)
        los datos almacenados en la entrada <quote>este
        directorio</quote>. Tenga también en cuenta que para
        las entradas de subdirectorios, Subversion almacena
        únicamente los atributos cruciales&mdash;nombre, tipo, url,
        revisión, y acción programada. En un esfuerzo para reducir
        información duplicada, Subversion dicta que el método para
        determinar el conjunto completo de información sobre un
        subdirectorio es descender dentro de ese subdirectorio, y
        leer la entrada <quote>este directorio</quote> de su propio
        fichero <filename>.svn/entries</filename>.  No obstante,
        se mantiene una referencia al subdirectorio en el fichero
        <filename>entries</filename> del padre, con suficiente
        información para permitir operaciones básicas de versionado
        en el evento de que el propio subdirectorio no esté presente
        en el disco<!--TODO aquí la traducción de disco quizás
        pierde calidad, pues se refiere a disco duro-->.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-3.2">
      <title>Copias prístinas y propiedades de ficheros</title>

      <para>Tal y como mencionamos anteriormente, el directorio
        <filename>.svn</filename> también contiene
        versiones <quote>text-base</quote> prístinas
        de los ficheros.  Éstas pueden encontrarse en
        <filename>.svn/text-base</filename>. Los beneficios de
        estas copias son múltiples&mdash;evitan conexiones por
        red cuando se quiere saber si hay modificaciones locales
        y qué es lo que ha cambiado, permiten revertir ficheros
        modificados o eliminados, los cambios que se transmiten al
        servidor son menores&mdash;pero hay que pagar el precio de
        almacenar cada fichero versionado dos veces en el disco.
        Hoy en día, esto parece una desventaja despreciable para
        la mayoría de los ficheros. No obstante, esta situación
        se vuelve más delicada <!-- uglier != delicada --> a
        medida que el tamaño de sus ficheros versionados crece.
        Se está prestando atención para permitir que la presencia de
        <quote>text-base</quote> sea una opción. Pero irónicamente,
        es a medida que los tamaños de sus ficheros versionados
        crecen cuando la existencia de <quote>text-base</quote>
        se vuelve más crucial&mdash;¿quién quiere transmitir un
        fichero enorme por red sólo porque quieren realizar una
        pequeña modificación sobre el mismo?</para>

      <para>Con un propósito similar a los ficheros
        <quote>text-base</quote> existen los ficheros de
        propiedades y sus copias <quote>prop-base</quote>
        prístinas, encontradas en <filename>.svn/props</filename>
        y <filename>.svn/prop-base</filename> respectivamente.  Dado
        que los directorios también pueden tener propiedades, también
        existen los ficheros <filename>.svn/dir-props</filename>
        y <filename>.svn/dir-prop-base</filename>.  Cada uno de
        estos ficheros de propiedades (versiones <quote>base</quote>
        y <quote>en desarrollo</quote>) usan un simple fichero
        de formato <quote>hash-on-disk</quote> para almacenar los
        nombres de las propiedades y sus valores.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  WEBDAV                                          *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-4">
    <title>WebDAV</title>

    <para>WebDAV (acrónimo de <quote>Web-based Distributed Authoring
      and Versioning</quote><footnote><para>N.T.: Gestión y
      versionado distribuído vía web</para></footnote>) es
      una extensión del protocolo estándar HTTP diseñada para
      transformar la web en un medio de lectura y escritura,
      en lugar del medio básicamente de sólo lectura que existe
      hoy en día.  La teoría es que los directorios y ficheros
      pueden ser compartidos&mdash;tanto como objetos de lectura y
      escritura&mdash;sobre la web. Los RFCs 2518 y 3253 describen
      las extensiones WebDAV/DeltaV de HTTP, y están disponibles
      (junto con bastante información útil) en <systemitem
      class="url">http://www.webdav.org/</systemitem>.</para>

    <para>Varios navegadores de ficheros en diferentes sistemas
      operativos ya son capaces de montar directorios por red
      usando WebDAV. En Win32, el explorador de Windows puede
      navegar por lo que llama WebFolders (que son localizaciones
      red montadas con WebDAV) como si fuesen normales carpetas
      compartidas. Mac OS X también tiene esta capacidad, al igual
      que los navegadores Nautilus y Konqueror (bajo GNOME y KDE,
      respectivamente).</para>

    <para>¿Cómo afecta todo esto a Subversion? El módulo mod_dav_svn
      de Apache usa HTTP, extendido por WebDAV y DeltaV, como uno
      de sus protocolos de red. Subversion usa mod_dav_svn para
      relacionar los conceptos de versionado de Subversion con los
      de los RFCs 2518 y 3253.
    </para>

    <para>Puede encontrar una descripción más detallada de WebDAV,
      cómo funciona, y cómo es usado por Subversion en <xref
      linkend="svn-ap-c"/>.  Entre otras cosas, ese apéndice discute
      el grado con el que Subversion se adhiere a la especificación
      WebDAV genérica, y cómo eso afecta la interoperabilidad con
      clientes WebDAV genéricos.</para>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 5:  PROGRAMMING WITH MEMORY POOLS                   *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-5">
    <title>Programando con áreas de memoria</title>

    <para>Casi todo desarrollador que ha usado el lenguaje de
      programación C se ha exasperado ante la desalentadora tarea de
      gestionar la memoria. Reservar suficiente memoria para un uso,
      llevar la pista de estas reservas, liberar la memoria cuando
      ya no se necesita&mdash;estas tareas pueden ser bastante
      complejas. Y por supuesto, errar en estas operaciones puede
      llevar a un programa que se cuelga, o peor, que cuelga todo el
      ordenador. Afortunadamente, la librería APR, de la que depende
      Subversion para su portabilidad, proporciona el tipo de dato
      <structname>apr_pool_t</structname>, el cual representa un
      área de la cual la aplicación puede reservar memoria.</para>

    <para>Un área de memoria es una representación abstracta de
      un bloque de memoria reservado para ser usado por un
      programa. En lugar de pedir memoria directamente al SO
      usando las funciones estándar <function>malloc()</function> y
      compañía, los programas que enlazan con APR pueden simplemente
      solicitar que se cree un área de memoria (usando la función
      <function>apr_pool_create()</function>).  APR reservará un
      trozo de memoria de tamaño moderado del SO, y esa memoria será
      disponible instantáneamente para ser usada por el programa.
      En cualquier momento que el programa necesite algo de memoria,
      usará una de las funciones de área de memoria de la API APR,
      como <function>apr_palloc()</function>, la cual devuelve una
      dirección genérica de memoria que apunta dentro del área. El
      programa puede seguir pidiendo bits y trozos de memoria del
      área, y APR seguirá accediendo a las demandas. Las áreas
      de memoria crecen automáticamente en tamaño para acomodarse
      a los programas que solicitan más memoria que la contenida
      inicialmente por el área, hasta que por supuesto, no quede
      más memoria disponible en el sistema.</para>

    <para>Ahora bien, si este fuese el final de la historia del
      área de memoria, difícilmente se hubiese merecido atención
      especial. Afortunadamente este no es el caso. Las áreas
      no sólo pueden ser creadas; también pueden ser limpiadas y
      destruídas, usando <function>apr_pool_clear()</function> y
      <function>apr_pool_destroy()</function> respectivamente. Esto
      proporciona a los desarrolladores la flexibilidad de
      reservar varios&mdash;o varios miles&mdash;elementos del
      área, ¡y entonces limpiar toda esa memoria con una simple
      llamada! Además, las áreas de memoria tienen jerarquía.
      Puede hacer <quote>sub áreas</quote> de cualquier área de
      memoria previamente creada. Cuando limpia un área, todas sus
      sub áreas son destruídas; si destruye un área, ésta y sus
      sub áreas serán destruídas.</para>

    <para>Antes de continuar, los desarrolladores deben tener
      presente que probablemente no encontrarán muchas llamadas
      a las funciones de áreas de memoria APR que acabamos de
      mencionar en el código fuente de Subversion.  Las áreas
      de memoria APR ofrecen algunos mecanismos de extensión,
      como la posibilidad de tener <quote>datos de usuario</quote>
      personalizados asociados al área de memoria, y mecanismos para
      registrar funciones de limpieza que serán llamadas cuando el
      área de memoria sea destruída.  Subversion hace uso de estas
      extensiones de un modo no trivial. Por lo que Subversion
      proporciona (y la mayoría del código usa) las funciones
      de envoltorio <function>svn_pool_create()</function>,
      <function>svn_pool_clear()</function>, y
      <function>svn_pool_destroy()</function>.</para>

    <para>Aunque las áreas de memoria son útiles para tareas
      básicas de gestiónde memoria, este tipo de estructura
      realmente brilla con los bucles y la recursividad. Dado que
      los bucles a menudo pueden terminar en cualquier momento
      <!-- TODO parafraseado correcto de unbounded loop. Mirar
      si en castellano existe un término más corto que signifique
      lo mismo-->, y las funciones recursivas volver a cualquier
      profundidad, el consumo de memoria en este tipo de situaciones
      puede ser impredecible. Afortunadamente, usar áreas de memoria
      anidadas puede ser un método excelente para tratar con estas
      situaciones peliagudas. El siguiente ejemplo demuestra el
      uso básico de áreas de memoria anidadas en una situación que
      es bastante común&mdash;recorrer de forma recursiva un árbol
      de directorios realizando cierta tarea sobre cada elemento
      del árbol.</para>

    <example id="svn-ch-8-sect-5-ex-1">
      <title>Uso efectivo de áreas de memoria</title>
      <programlisting>
/* Recursively crawl over DIRECTORY, adding the paths of all its file
   children to the FILES array, and doing some task to each path
   encountered.  Use POOL for the all temporary allocations, and store
   the hash paths in the same pool as the hash itself is allocated in.  */
static apr_status_t 
crawl_dir (apr_array_header_t *files,
           const char *directory,
           apr_pool_t *pool)
{
  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */
  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */
  apr_dir_t *dir;
  apr_finfo_t finfo;
  apr_status_t apr_err;
  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;

  apr_err = apr_dir_open (&amp;dir, directory, pool);
  if (apr_err)
    return apr_err;

  /* Loop over the directory entries, clearing the subpool at the top of
     each iteration.  */
  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);
       apr_err == APR_SUCCESS;
       apr_err = apr_dir_read (&amp;finfo, flags, dir))
    {
      const char *child_path;

      /* Clear the per-iteration SUBPOOL.  */
      svn_pool_clear (subpool);

      /* Skip entries for "this dir" ('.') and its parent ('..').  */
      if (finfo.filetype == APR_DIR)
        {
          if (finfo.name[0] == '.'
              &amp;&amp; (finfo.name[1] == '\0'
                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\0')))
            continue;
        }

      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */
      child_path = svn_path_join (directory, finfo.name, subpool);

      /* Do some task to this encountered path. */
      do_some_task (child_path, subpool);

      /* Handle subdirectories by recursing into them, passing SUBPOOL
         as the pool for temporary allocations.  */
      if (finfo.filetype == APR_DIR)
        {
          apr_err = crawl_dir (files, child_path, subpool);
          if (apr_err)
            return apr_err;
        }

      /* Handle files by adding their paths to the FILES array.  */
      else if (finfo.filetype == APR_REG)
        {
          /* Copy the file's path into the FILES array's pool.  */
          child_path = apr_pstrdup (hash_pool, child_path);

          /* Add the path to the array.  */
          (*((const char **) apr_array_push (files))) = child_path;
        }
    }

  /* Destroy SUBPOOL.  */
  svn_pool_destroy (subpool);

  /* Check that the loop exited cleanly. */
  if (apr_err)
    return apr_err;

  /* Yes, it exited cleanly, so close the dir. */
  apr_err = apr_dir_close (dir);
  if (apr_err)
    return apr_err;

  return APR_SUCCESS;
}
</programlisting>
    </example>

    <para>El ejemplo anterior demuestra un uso efectivo de áreas
      de memoria en situaciones con bucles y recursividad. Cada
      recursión comienza creando una sub área de memoria del área
      pasada a la función. Esta sub área es usada por la región con
      bucles, y limpiada en cada iteración. Esto da como resultado
      que el consumo de memoria sea a grandes rasgos proporcional a
      la profundidad de la recursión, no al número total de ficheros
      y directorios presentes como hijos del directorio de nivel
      superior. Cuando la primera llamada a esta función recursiva
      finalmente termina, hay realmente muy pocos datos almacenados
      en el área de memoria que recibió como parámetro. ¡Ahora
      imagine la complejidad adicional que estaría presente en
      esta función si tuviese que reservar y liberar cada pieza
      individual de datos usados!</para>
    
    <para>Pools might not be ideal for every application, but they are
      extremely useful in Subversion.  As a Subversion developer,
      you'll need to grow comfortable with pools and how to wield them
      correctly.  Memory usage bugs and bloating can be difficult to
      diagnose and fix regardless of the API, but the pool construct
      provided by APR has proven a tremendously convenient,
      time-saving bit of functionality.</para>

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 6:  CONTRIBUTING TO SUBVERSION                      *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-8-sect-6">
    <title>Contributing to Subversion</title>
    
    <para>The official source of information about the Subversion
      project is, of course, the project's website at <systemitem
      class="url">http://subversion.tigris.org/</systemitem>.  There
      you can find information about getting access to the source code
      and participating on the discussion lists.  The Subversion
      community always welcomes new members.  If you are
      interested in participating in this community by contributing
      changes to the source code, here are some hints on how to get
      started.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.1">
      <title>Join the Community</title>
      
      <para>The first step in community participation is to find a way
        to stay on top of the latest happenings.  To do this most
        effectively, you will want to subscribe to the main developer
        discussion list (<email>dev@subversion.tigris.org</email>) and
        commit mail list (<email>svn@subversion.tigris.org</email>).
        By following these lists even loosely, you will have access
        to important design discussions, be able to see actual changes
        to Subversion source code as they occur, and be able to
        witness peer reviews of those changes and proposed changes.
        These email based discussion lists are the primary
        communication media for Subversion development.  See the
        Mailing Lists section of the website for other
        Subversion-related lists you might be interested in.</para>

      <para>But how do you know what needs to be done?  It is quite
        common for a programmer to have the greatest intentions of
        helping out with the development, yet be unable to find a good
        starting point.  After all, not many folks come to the
        community having already decided on a particular itch they
        would like to scratch.  But by watching the developer
        discussion lists, you might see mentions of existing bugs or
        feature requests fly by that particularly interest you.  Also,
        a great place to look for outstanding, unclaimed tasks is the
        Issue Tracking database on the Subversion website.  There you
        will find the current list of known bugs and feature requests.
        If you want to start with something small, look for issues
        marked as <quote>bite-sized</quote>.</para>
      
    </sect2>
    
    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.2">
      <title>Get the Source Code</title>
      
      <para>To edit the code, you need to have the code.  This means
        you need to check out a working copy from the public
        Subversion source repository.  As straightforward as that
        might sound, the task can be slightly tricky.  Because
        Subversion's source code is versioned using Subversion itself,
        you actually need to <quote>bootstrap</quote> by getting a
        working Subversion client via some other method.  The most
        common methods include downloading the latest binary
        distribution (if such is available for your platform), or
        downloading the latest source tarball and building your own
        Subversion client.  If you build from source, make sure to
        read the <filename>INSTALL</filename> file in the top level of
        the source tree for instructions.</para>

      <para>After you have a working Subversion client, you are now
        poised to checkout a working copy of the Subversion source
        repository from <systemitem
        class="url">http://svn.collab.net/repos/svn/trunk/</systemitem>:
        <footnote>
          <para>Note that the URL checked out in the example above
            ends not with <literal>svn</literal>, but with a
            subdirectory thereof called <literal>trunk</literal>.  See
            our discussion of Subversion's branching and tagging model
            for the reasoning behind this.</para>
        </footnote></para>

      <screen>
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A  HACKING
A  INSTALL
A  README
A  autogen.sh
A  build.conf
&hellip;
</screen>

      <para>The above command will checkout the bleeding-edge, latest
        version of the Subversion source code into a subdirectory
        named <filename>subversion</filename> in your current working
        directory.  Obviously, you can adjust that last argument as
        you see fit.  Regardless of what you call the new working copy
        directory, though, after this operation completes, you will
        now have the Subversion source code.  Of course, you will
        still need to fetch a few helper libraries (apr, apr-util,
        etc.)&mdash;see the <filename>INSTALL</filename> file in the
        top level of the working copy for details.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.3">
      <title>Become Familiar with Community Policies</title>
      
      <para>Now that you have a working copy containing the latest
        Subversion source code, you will most certainly want to take a
        cruise through the <filename>HACKING</filename> file in that
        working copy's top-level directory.  The
        <filename>HACKING</filename> file contains general
        instructions for contributing to Subversion, including how to
        properly format your source code for consistency with the rest
        of the codebase, how to describe your proposed changes with an
        effective change log message, how to test your changes, and so
        on.  Commit privileges on the Subversion source repository are
        earned&mdash;a government by meritocracy.
        <footnote>
          <para>While this may superficially appear as some sort of
            elitism, this <quote>earn your commit privileges</quote>
            notion is about efficiency&mdash;whether it costs more in
            time and effort to review and apply someone else's changes
            that are likely to be safe and useful, versus the
            potential costs of undoing changes that are
            dangerous.</para>
        </footnote>
        The HACKING file is an invaluable resource when it comes to 
        making sure that your proposed changes earn the praises they
        deserve without being rejected on technicalities.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.4">
      <title>Make and Test Your Changes</title>
      
      <para>With the code and community policy understanding in hand,
        you are ready to make your changes.  It is best to try to make
        smaller but related sets of changes, even tackling larger
        tasks in stages, instead of making huge, sweeping
        modifications.  Your proposed changes will be easier to
        understand (and therefore easier to review) if you disturb
        the fewest lines of code possible to accomplish your task
        properly.  After making each set of proposed changes, your
        Subversion tree should be in a state in which the software
        compiles with no warnings.</para>

      <para>Subversion has a fairly thorough
        <footnote>
          <para>You might want to grab some popcorn.
            <quote>Thorough</quote>, in this instance, translates to
            somewhere in the neighborhood of thirty minutes of
            non-interactive machine churn.</para>
        </footnote>
        regression test suite, and your proposed changes are expected
        to not cause any of those tests to fail.  By running
        <command>make check</command> (in Unix) from the top of the
        source tree, you can sanity-check your changes.  The fastest
        way to get your code contributions rejected (other than
        failing to supply a good log message) is to submit changes
        that cause failure in the test suite.</para>

      <!-- ### TODO: Describe building and testing on Windows. -->

      <para>In the best-case scenario, you will have actually added
        appropriate tests to that test suite which verify that your
        proposed changes work as expected.  In fact,
        sometimes the best contribution a person can make is solely
        the addition of new tests.  You can write regression tests for
        functionality that currently works in Subversion as a way to
        protect against future changes that might trigger failure in
        those areas.  Also, you can write new tests that demonstrate
        known failures.  For this purpose, the Subversion test suite
        allows you to specify that a given test is expected to fail
        (called an <literal>XFAIL</literal>), and so long as
        Subversion fails in the way that was expected, a test result
        of <literal>XFAIL</literal> itself is considered a success.
        Ultimately, the better the test suite, the less time wasted on
        diagnosing potentially obscure regression bugs.</para>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-8-sect-6.5">
      <title>Donate Your Changes</title>
      
      <para>After making your modifications to the source code,
        compose a clear and concise log message to describe those
        changes and the reasons for them.  Then, send an email to the
        developers list containing your log message and the output of
        <command>svn diff</command> (from the top of your Subversion
        working copy).  If the community members consider your changes
        acceptable, someone who has commit privileges (permission to
        make new revisions in the Subversion source repository) will
        add your changes to the public source code tree.  Recall that
        permission to directly commit changes to the repository is
        granted on merit&mdash;if you demonstrate comprehension of
        Subversion, programming competency, and a <quote>team
        spirit</quote>, you will likely be awarded that
        permission.</para>

    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
