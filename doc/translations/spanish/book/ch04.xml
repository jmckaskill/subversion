<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<chapter id="svn-ch-4">
<title>Crear ramas y fusionarlas</title>

  <simplesect>

    <para>Crear ramas, etiquetar y fusionar, son conceptos comunes
      en casi todos los sistemas de control de versiones. Si no
      está familiarizado con estas ideas, le proporcionaremos una
      buena introducción en este capítulo. Si está familiarizado,
      esperamos que encuentre interesante descubrir cómo Subversion
      implementa estas ideas.</para>

    <para>Crear ramas es una parte fundamental del control de
      versiones. Si va a permitir que Subversion gestione
      sus datos, entonces esta es una característica de la
      cual acabará dependiendo. Este capítulo asume que ya está
      familiarizado con los conceptos básicos de Subversion (<xref
      linkend="svn-ch-2"/>).</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-1">
    <title>¿Qué es una rama?</title>

    <para>Supongamos que su trabajo es mantener un documento para
      una de las divisiones de su companía, una especie de
      manual. Un día una división diferente le pide ese manual,
      pero con algunas partes 'retocadas' para ellos, dado que
      <!-- TODO tweak. Puede ser retocado, modificado, personalizado,
      etc. No sé si hay traducción directa.-->
      hacen las cosas de forma ligeramente diferente.</para>

    <para>¿Qué hace en esta situación? Lo más obvio: realiza
      una segunda copia de su documento, y comienza a mantener
      ambas copias de forma separada. A medida que cada departamente
      solicita pequeños cambios, usted los incorpora en una de las
      copias o la otra.</para>

    <para>A menudo desea realizar el mismo cambio en ambas
      copias. Por ejemplo, si descubre un error ortográfico en la
      primera copia, es muy probable que el mismo error exista
      en la segunda copia.  Al fin y al cabo, ambos documentos
      son casi iguales; sólo se diferencian en pequeños detalles
      específicos.</para>

    <para>Este es el concepto de una
      <firstterm>rama</firstterm>&mdash; una línea de desarrollo
      que existe de forma independiente a otra, pero comparte
      una historia común si mira suficientemente atrás en el
      tiempo. Una rama siempre nace como una copia d ealgo, y a
      partir de ahí, pasa a generar su propia historia (vea <xref
      linkend="svn-ch-4-dia-1"/>).</para>

      <figure id="svn-ch-4-dia-1">
        <title>Ramas de desarrollo</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para>Subversion tiene comandos para ayudarle a mantener ramas
      paralelas de sus ficheros y directorios. Le permite crear
      ramas copiando sus datos, y recordando que las copias están
      relacionadas unas a otras. También le ayuda a duplicar cambios
      de una rama a otra. Finalmente, puede reflejar el contenido
      de diferentes ramas en partes de su copia de trabajo local,
      para que pueda
      <!-- TODO mix and match. ¿Qué significa match exactamente? -->
      <quote>mezclar y probar</quote> diferentes líneas de desarrollo
      en su trabajo diario.</para>

  </sect1>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-2">
    <title>Usando ramas</title>

    <para>A estas alturas debería entender que todo cambio en
      el repositorio genera internamente un nuevo árbol de sistema
      de ficheros (llamado <!-- TODO en efecto, hay que ponerse
      de acuerdo con traducir revision.  Por ahora usaré revision
      sin acento para indicar que es una palabra que he decidido
      no traducir --> <quote>revision</quote>). Si no es así,
      debería volver atrás y leer información sobre revisiones en
      <xref linkend="svn-ch-2-sect-3.2"/>.</para>

    <para>En este capítulo, volveremos al ejemplo del segundo
      capítulo.  <!-- TODO pues estaría bien revisar
      ambos ejemplos a la par y verificar que coinciden
      --> Recuerde cómo usted y su compañera, Carmen,
      comparten un repositorio que contiene dos proyectos,
      <filename>paint</filename> y <filename>calc</filename>.
      Fíjese que en <xref linkend="svn-ch-4-dia-2"/>, no obstante,
      cada directorio de proyecto contiene subdirectorios llamados
      <filename>trunk</filename> y <filename>branches</filename>.
      La razón se descubrirá pronto.</para>
    
      <figure id="svn-ch-4-dia-2">
        <title>Estructura inicial del repositorio</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para>Igual que antes, asuma que tanto Carmen como usted tienen
      copias locales del proyecto <quote>calc</quote>. En
      concreto, ambos tienen una copia local de
      <filename>/calc/trunk</filename>.  Todos los ficheros
      del proyecto están en este subdirectorio en lugar de
      <filename>/calc</filename>, porque su equipo ha decidido que
      <filename>/calc/trunk</filename> es donde tendrá lugar la
      <quote>línea principal</quote> de desarrollo.</para>

    <para>Digamos que le han encargado la tarea de realizar una
      reorganización radical del proyecto. Le tomará un largo
      tiempo realizar la modificación, y ésta afectará a todos
      los ficheros del proyecto. En esta situación el problema
      es que no quiere intereferir con Carmen, quien sigue en
      el proceso de corregir pequeños fallos aquí y allá. Ella
      depende del hecho que la última versión del proyecto (en
      <filename>/calc/trunk</filename>) siempre es usable. Si
      comienza a enviar cambios al repositorio poco a poco,
      seguramente fastidiará la tarea de Carmen.</para>

    <para>Una estrategia es esconderse en un agujero: usted y
      Carmen pueden dejar de compartir información durante una o
      dos semanas. Es decir, comienza a reorganizar los ficheros
      en su copia local, pero no envía los cambios al servidor o
      actualiza su copia hasta que ha completado la tarea. Sin
      embargo, hay varios problemas con esto. En primer lugar,
      no es muy seguro. La mayoría de las personas prefieren
      guardar sus cambios en el repositorio con frecuencia,
      por si algo malo pudiera suceder de forma accidental a su
      copia local. Segundo, no es muy flexible.  Si realiza su
      trabajo en diferentes ordenadores (quizás tiene una copia de
      <filename>/calc/trunk</filename> en dos máquinas diferentes),
      necesitará copiar manualmente sus cambios de un lado a otro,
      o realizar todo el trabajo en un solo ordenador. Del mismo
      modo, es dificil compartir sus cambios a mitad del desarrollo
      con otras personas. Una <quote>práctica ideal</quote> común
      en el desarrollo de software es permitir que sus compañeros
      puedan revisar su trabajo a medida que progresa. Si nadie
      ve los cambios que realiza poco a poco, pierde críticas
      potenciales. Finalmente, si ha finalizado con su tarea,
      puede encontrarse con que es muy difícil fusionar su trabajo
      final con el cuerpo principal del repositorio usado por el
      resto de la compañía. Carmen (y otros) puede haber realizado
      cambios en el repositorio que son difíciles de incorporar en
      su copia local&mdash;especialmente si ejecuta <command>svn
      update</command> semanas tras el aislamiento.</para>

    <para>La mejor solución es crear su propia rama, o línea de
      desarrollo, en el repositorio. Esto le permite guardar su
      trabajo a medio hacer con frecuencia sin interferir con otros,
      permitiendo a su vez compartir de forma selectiva información
      con sus colaboradores. Más adelante verá exáctamente como
      funciona esto.</para>

  <sect2 id="svn-ch-4-sect-2.1">
    <title>Creando una rama</title>

      <para>Crear una rama es muy simple&mdash;realize una copia
        del proyecto en el repositorio usando el comando
        <command>svn copy</command>. Subversion no sólo es
        capaz de copiar ficheros individuales, sino también
        directorios. En este caso, desea realizar una copia del
        directorio <filename>/calc/trunk</filename>. ¿Dónde debería
        colocar la nueva copia? Donde desee&mdash;es una cuestión
        de política de su proyecto. Digamos que su equipo tiene
        la política de crear ramas en el area de repositorio
        <filename>/calc/branches</filename>, y quiere nombrar
        la rama <literal>my-calc-branch</literal>. Entonces
        querrá crear un nuevo directorio
        <filename>/calc/branches/my-calc-branch</filename>,
        el cual comienza su vida como una copia de
        <filename>/calc/trunk</filename>. </para>

      <para>Hay dos formas diferentes de realizar una copia. Le
        mostraremos primero el modo engorroso, para asegurarnos
        de que queda claro el concepto. Para comenzar, obtenga
        una copia local del directorio raíz del proyecto,
        <filename>/calc</filename>:</para>

<screen>
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</screen>

      <para>Realizar ahora una copia es cuestión de pasar dos
        rutas locales al comando <command>svn copy</command>:</para>

<screen>
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</screen>

      <para>En este caso, el comando <command>svn copy</command>
        copia recursivamente el directorio
        <filename>trunk</filename> en un nuevo directorio,
        <filename>branches/my-calc-branch</filename>.  Tal y como
        puede ver por el comando <command>svn status</command>,
        el nuevo directorio está ahora a la espera de ser añadido
        al repositorio. Pero fíjese en el signo <quote>+</quote>
        tras la letra A.  Esto indica que la adición pendiente
        es una <emphasis>copia</emphasis> de algo, no algo nuevo.
        Cuando envíe sus cambios al repositorio, Subversion creará
        <filename>/calc/branches/my-calc-branch</filename>
        en el repositorio como una copia de
        <filename>/calc/trunk</filename>, en lugar de reenviar
        todos los datos de su copia local de nuevo a través de
        la red:</para>

<screen>
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</screen>

      <para>Y ahora el método más sencillo para crear una rama,
        que deberíamos haberle explicado en primer lugar:
        <command>svn copy</command> es capaz de operar directamente
        sobre dos URLs.</para>

<screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</screen>

      <para>Realmente no hay diferencia entre estos dos
        métodos. Ambos procedimientos crean un nuevo directorio
        en la revisión 341, y el nuevo directorio es una copia
        de <filename>/calc/trunk</filename>.  Esto se puede ver
        en <xref linkend="svn-ch-4-dia-3"/>. Note cómo el segundo
        método, no obstante, realiza los cambios en el repositorio
        <emphasis>inmediatamente</emphasis>.
        <footnote> 
          <para>Subversion no soporta copias entre diferentes
            repositorios.  Cuando use URLs con <command>svn
            copy</command> o <command>svn move</command>, sólo puede
            copiar elementos dentro del mismo repositorio.</para>
        </footnote>
        Es un procedimiento más sencillo, porque no requiere obtener
        primero una gran copia local de todo el repositorio. De
        hecho, esta técnica ni si quiera requiere que tenga una
        copia local en absoluto.</para>
      
      <figure id="svn-ch-4-dia-3">
        <title>Repositorio con nueva copia</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>
      
      <sidebar>
        <title>Copias ligeras</title>
                
        <para>El repositorio de Subversion sigue un diseño
          especial. Cuando copia un directorio, no necesita
          preocuparse por el crecimiento del repositorio&mdash;en
          realidad Subversion no duplica los datos.  En su lugar,
          crear una nueva entrada de directorio que apunta a un árbol
          <emphasis>existente</emphasis>. Si es un usuario de Unix,
          este es el mismo concepto que un enlace duro. A partir
          de ahí, se dice que la copia es <quote>vaga</quote>. <!--
          TODO lazy copy: copia vaga o copia tardía? --> Es decir, si
          realiza un cambio a un fichero contenido en el directorio
          copiado, sólo cambia ese fichero&mdash;el resto de los
          ficheros continúan su existencia como enlaces a los
          ficheros originales del directorio original.</para>
      
        <para>Por esta razón escuchará a los usuarios de Subversion
          hablar con frecuencia sobre <quote>copias ligeras</quote>.
          No importa cuán grande sea el directorio&mdash;sólo
          requiere un tiempo constante muy pequeño realizar una
          copia del mismo.  De hecho, esta es la característica en
          la que se basan los cambios realizados en Subversion:
          cada revisión es una <quote>copia ligera</quote> de
          la revisión anterior, con algunos elementos cambiados.
          (Para aprender más sobre esto, visite la página web de
          Subversion y lea en los documentos sobre el diseño de
          Subversion el método <quote>bubble up</quote>.)</para>

        <para>Por supuesto, este mecanismo interno usado para copiar
          y compartir datos está oculto al usuario, que simplemente
          ve copias de árboles de ficheros. Lo importante es saber
          que las copias son ligeras, tanto en tiempo como espacio.
          Crée tantas ramas como desee.  <!-- TODO, aquí quizás cheap
          debería traducirse tal cual.  Aparte, "crée" quizás pueda
          reemplazarse por algo mejor--></para>
      </sidebar>

    </sect2>
    
    <sect2 id="svn-ch-4-sect-2.2">
      <title>Trabajando con su rama</title>

      <para>Ahora que ha creado una rama del proyecto, puede obtener
        una nueva copia local para comenzar a usarla:</para>

<screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</screen>

      <para>No hay nada especial sobre esta copia local; simplemente
        refleja un directorio diferente del repositorio. Cuando
        envíe sus cambios, no obstante, Carmen nunca los
        verá cuando se actualice. Su copia local es de
        <filename>/calc/trunk</filename>.  (Asegúrese de leer <xref
        linkend="svn-ch-4-sect-5"/> más adelante en este capítulo:
        el comando <command>svn switch</command> permite crear una
        copia local de una rama de modo diferente.)</para>

      <para>Pretendamos que ha pasado una semana, y se realizan los
        siguientes cambios:</para>

      <itemizedlist>
        <listitem><para>
          Ha realizado un cambio en
          <filename>/calc/branches/my-calc-branch/button.c</filename>,
          creando la revisión 342.</para>
        </listitem>

        <listitem><para>
          Ha realizado un cambio en
          <filename>/calc/branches/my-calc-branch/integer.c</filename>,
          creando la revisión 343.</para>
        </listitem>

        <listitem><para>
          Carmen ha realizado un cambio en
          <filename>/calc/trunk/integer.c</filename>, creando la
          revisión 344.</para>
        </listitem>
      </itemizedlist>

      <para>Ahora hay dos líneas independientes de desarrollo,
        mostradas en <xref linkend="svn-ch-4-dia-4"/>, sobre el
        fichero <filename>integer.c</filename>.</para>

      <figure id="svn-ch-4-dia-4">
        <title>Bifurcación de la historia de un fichero</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <para>Las cosas se ponen interesantes cuando mira el historial
        de cambios realizados a su copia de
        <filename>integer.c</filename>:</para>

<screen>
$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | carmen | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | carmen | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Fíjese como Subversion sigue la historia de
        <filename>integer.c</filename> en su rama hacia atrás,
        traspasando incluso el punto donde el fichero fue copiado.
        Muestra la creación de la rama como un evento en la
        historia, porque <filename>integer.c</filename> fue
        copiado de forma implícita cuando realizó la copia de
        <filename>/calc/trunk/</filename>. Ahora mire qué es lo
        que ocurre cuando Carmen ejecuta el mismo comando sobre su
        copia del fichero:</para>

<screen>
$ pwd
/home/carmen/calc

$ svn log --verbose integer.c
------------------------------------------------------------------------
r344 | carmen | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | carmen | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | carmen | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Carmen ve su propio cambio de la revisión 344, pero no
        el cambio realizado en la revisión 343. Desde el punto de
        vista de Subversion, estos dos cambios afectaron ficheros
        diferentes en distintos lugares del repositorio. No obstante,
        Subversion <emphasis>muestra</emphasis> que ambos ficheros
        comparten una historia común.  Antes de que la rama fuese
        creada en la revisión 341, ambos eran el mismo fichero. Por
        esta razón tanto usted como Carmen ven los cambios realizados
        en las revisiones 303 y 98.</para>

    </sect2>

    <sect2 id="svn-ch-4-sect-2.3">
      <title>Conceptos clave sobre las ramas</title>

      <para>Hay dos lecciones importantes que debería recordar
        de esta sección.</para>

      <orderedlist>
        <listitem>
          <para>A diferencia de muchos otros sistemas de control
            de versiones, las ramas de Subversion existen
            como <emphasis>directorios normales del sistema de
            archivos</emphasis> en el repositorio, no en una
            dimensión extra. Estos directorios simplemente llevan
            información histórica adicional.</para>
        </listitem>
        <listitem>
          <para>Subversion no tiene un concepto interno de
            rama&mdash;sólo copias.  Cuando copia un directorio, el
            nuevo directorio sólo es una <quote>rama</quote> porque
            <emphasis>usted</emphasis> añade esa connotación. Puede
            considerar el directorio de forma diferente, o tratarlo
            de manera diferente, pero para Subversion no es más que
            un directorio ordinario que simplemente fue creado como
            resultado de una operación de copiado.</para>
        </listitem>
      </orderedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-3">
    <title>Copiando cambios entre ramas</title>

    <para>Ahora usted y Carmen están trabajando en ramas paralelas
      del proyecto: usted está trabajando en una rama privada, y
      Carmen está trabajando en el <firstterm>tronco</firstterm>,
      o línea principal de desarrollo.</para>

    <para>En proyectos que tienen grandes cantidades de
      contribuyentes, es habitual que la mayoría tengan copias
      locales del tronco.  Cuando alguien necesita hacer un cambio a
      largo plazo que puede molestar en el tronco, un procedimiento
      estándar es crear una rama privada y realizar ahí los cambios
      hasta que todo el trabajo esté completo.</para>

    <para>Así que las buenas noticias son que usted y Carmen no están
      interfiriendo en sus trabajos. Las malas noticias son
      que es muy fácil derivar <emphasis>demasiado</emphasis>
      lejos. Recuerde que uno de los problemas con la estrategia
      <quote>esconderse en un agujero</quote> es que para cuando
      haya terminado con su rama, puede que sea casi imposible
      fusionar los cambios con el tronco sin un alto número de
      conflictos.</para>
    
    <para>En su lugar, usted y Carmen pueden continuar compartiendo
      cambios a medida que trabajan. Es tarea suya decidir qué
      cambios merece la pena compartir; Subversion le brinda la
      posibilidad de <quote>copiar</quote> cambios entre ramas de
      forma selectiva.  Y para cuando haya finalizado completamente
      con su rama, su conjunto entero de cambios en la rama puede
      ser copiado en el tronco.</para>
    

    <sect2 id="svn-ch-4-sect-3.1">
      <title>Copiando cambios específicos</title>
      
      <para>El la sección anterior, mencionamos que tanto usted
        como Carmen han realizado cambios a
        <filename>integer.c</filename> en ramas diferentes.
        Si observa el informe de cambios de la revisión 344,
        puede ver que ella realizó algunas correcciones de
        ortografía. Sin duda, su copia del mismo fichero debe tener
        todavía los mismos errores de ortografía.  Es probable que
        futuros cambios al fichero afectarán las mismas áreas que
        tienen estos errores ortográficos, lo que potencialmente
        generará conflictos cuando fusione su rama algún día. Es
        mejor, entonces, recibir ahora los cambios de Carmen,
        <emphasis>antes</emphasis> de que comience a trabajar de
        forma intensiva en el mismo sitio.</para>

      <para>Es el momento de usar el comando <command>svn
        merge</command>.  Este comando, descubrirá que es un primo
        cercano del comando <command>svn diff</command> (sobre
        el cual leímos en el tercer capítulo). Ambos comandos son
        capaces de comparar dos objetos cualquiera del repositorio
        y describir sus diferencias.  Por ejemplo, puede preguntar a
        <command>svn diff</command> que le muestre el cambio exacto
        realizado por Carmen en la revisión 344:</para>

<screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info->operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info->operating_system, "Macintosh"); break;
     case 8:  sprintf(info->operating_system, "Z-System"); break;
-    case 9:  sprintf(info->operating_system, "CPM"); break;
+    case 9:  sprintf(info->operating_system, "CP/M"); break;
     case 10:  sprintf(info->operating_system, "TOPS-20"); break;
     case 11:  sprintf(info->operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info->operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info->extra_header = (unsigned char *) my_malloc(total);
     fread(info->extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info->data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info->data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>
      
      <para>El comando <command>svn merge</command> es casi
        exáctamente idéntico.  En lugar de mostrar las diferencias
        en su terminal, no obstante, las aplica directamente
        a su copia local como <emphasis>modificaciones
        locales</emphasis>:</para>
    
<screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</screen>

      <para>La salida del comando <command>svn merge</command>
        muestra que su copia de <filename>integer.c</filename>
        fue parcheada. Ahora contiene el cambio de Carmen&mdash;el
        cambio ha sido <quote>copiado</quote> desde el tronco a su
        copia local de la rama privada, y existe ahora como una
        modificación local. En este punto, es tarea suya revisar
        la modificación local para asegurarse de que funciona
        correctamente.</para>

      <para>En otra situación, es posible que las cosas no hayan
        ido tan bien, y que <filename>integer.c</filename>
        haya entrado en un estado de conflicto. Puede tener que
        resolver el conflicto usando el procedimiento estándar
        (vea el tercer capítulo), o si decide que la fusión fue una
        mala idea, simplemente dé se por vencido y use <command>svn
        revert</command> para revertir el cambio local.</para>

      <para>Pero asumiendo que ha revisado el cambio fusionado, puede
        guardar sus cambios como es habitual con <command>svn
        commit</command>.  En ese punto, el cambio ha sido fusionado
        en su rama del repositorio.  En terminología de control
        de versiones, este acto de copiar cambios entre ramas se
        denomina <firstterm>portar</firstterm> cambios.</para>

      <para>Cuando guarda su modificación local, asegúrese de que
        el mensaje de cambios indica que está portando un cambio
        específico de una rama a otra. Por ejemplo:</para>

<screen>
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</screen>

      <para>As you'll see in the next sections, this is a very
        important <quote>best practice</quote> to follow.</para>

      <sidebar>
        <title>¿Por qué no usar parches?</title>
        
        <para>Una pregunta que tendrá en mente, especialmente si
          es un usuario de Unix: ¿para qué usar el comando
          <command>svn merge</command>?  ¿Por qué no simplemente usar
          el comando <command>patch</command> del sistema operativo
          para realizar la misma tarea?  Por ejemplo:</para>

<screen>
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

        <para>En este caso particular, efectivamente, no hay
          realmente diferencia alguna. Pero <command>svn
          merge</command> tiene características especiales que
          sobrepasan las del programa <command>patch</command>.
          El formato de fichero usado por <command>patch</command>
          es bastante limitado; sólo permite modificar el contenido
          de los ficheros. No hay forma de representar cambios a
          <emphasis>árboles</emphasis>, como añadir, eliminar o
          renombrar ficheros y directorios.  Si el cambio de Carmen,
          digamos, hubiese añadido un nuevo directorio, la salida
          de <command>svn diff</command> ni si quiera lo hubiese
          mencionado. <command>svn diff</command> sólo genera
          salida en el formato limitado de patch, por lo que hay
          algunas ideas que no puede expresar. <footnote> <para>En
          el futuro, el proyecto Subversion planea usar (o inventar)
          un formato de parche que describe cambios a árboles.</para>
          </footnote> El comando <command>svn merge</command>, no
          obstante, puede expresar cambios a árboles directamente
          aplicándolos a su copia local.</para>

      </sidebar>
      
      <para>Aviso: aunque los comandos <command>svn diff</command> y
        <command>svn merge</command> son similares en concepto,
        tienen una diferente sintaxis en muchos casos. Asegúrese de
        leer en el capítulo 8 los detalles, o pregunte a <command>svn
        help</command>.  Por ejemplo, <command>svn merge</command>
        requiere una ruta a una copia local como destino, es decir,
        un lugar donde debe aplicar los cambios del árbol. Si
        el destino no es especificado, asume que está intentando
        realizar una de las siguientes operaciones comunes:</para>

      <orderedlist>
        <listitem> <para>Quiere fusionar cambios de directorio
            directamente en su copia local.</para>
        </listitem>
        <listitem>
          <para>Quiere fusionar los cambios de un fichero específico
            en un fichero que existe con el mismo nombre en su
            directorio de trabajo actual.</para>
        </listitem>
      </orderedlist>

      <para>Si está fusionando un directorio y no ha especificado una
        ruta destino, <command>svn merge</command> asume el
        primer caso mencionado e intenta aplicar los cambios en su
        directorio actual.  Si está fusionando un fichero, y ese
        fichero (o un fichero con el mismo nombre) existe en su
        directorio actual de trabajo, <command>svn merge</command>
        asume el segundo caso mencionado e intenta aplicar los
        cambios al fichero local de mismo nombre.</para>
      
      <para>Si quiere aplicar los cambios en otro lugar, tendrá que
        especificarlo. Por ejemplo, si todavía está en el directorio
        padre de su copia local, tendrá que especificar el directorio
        destino para recibir los cambios:</para>
      
<screen>
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</screen>

      <!-- ### fix the damn left arrow quoting problem in both screen
      examples -->
      
    </sect2>

    <sect2 id="svn-ch-4-sect-3.2">
      <title>Procedimientos ideales de fusionado</title>

      <sect3 id="svn-ch-4-sect-3.2.1">
        <title>Realizar fusiones de forma manual</title>

        <para>Fusionar cambios suena bastante simple, pero en
          la práctica puede convertirse en un dolor de cabeza. El
          problema es que si fusiona cambios con frecuencia de una
          rama a otra, puede acabar fusionando accidentalmente el
          mismo cambio <emphasis>dos veces</emphasis>.  Cuando esto
          ocurre, a veces las cosas seguirán funcionando bien. Cuando
          aplica un parche a un fichero, Subversion normalmente se
          da cuenta de que el fichero ya contiene el cambio, y no
          hace nada. Pero si el cambio ya existente fue modificado
          de algún modo, obtendrá un conflicto.</para>

        <para>Idealmente, su sistema de control de versiones debería
          prevenir la doble aplicación de cambios a una rama. Debería
          recordar automáticamente qué cambios fueron recibidos en la
          rama, y ser capaz de mostrarle un listado de los mismos.
          Debería poder usar esta información para automatizar las
          fusiones tanto como sea posible.</para>

        <para>Desafortunadamente, Subversion no es tal sistema. Al
          igual que CVS, Subversion 1.0 no almacena ninguna
          información sobre operaciones de fusionado. Cuando envía
          sus cambios locales, el repositorio no tiene idea si esos
          cambios vinieron de una ejecución del comando <command>svn
          merge</command>, o de una modificación manual de los
          ficheros.</para>

        <para>¿Qué significa esto para usted, el usuario? Significa
          que hasta que llegue el día que Subversion desarrolle
          esta característica, tendrá que gestionar usted mismo la
          información de fusionado.  El mejor lugar para hacerlo
          es en el informe de cambios cuando envía cambios al
          repositorio. Tal y como se demostró en el ejemplo
          anterior, es recomendable que su informe de cambios
          mencione el número de revisión específico (o rango de
          revisiones) que está siendo fusionado en su rama. Más
          tarde, puede ejecutar <command>svn log</command> para
          revisar qué cambios contiene ya su rama. Esto le permitirá
          construir con cuidado siguientes comandos <command>svn
          merge</command> que no serán redundantes con cambios
          previamente portados.</para>

        <para>En la siguiente sección, le mostraremos algunos
          ejemplos de esta técnica en acción.</para>

      </sect3>
      
      <sect3 id="svn-ch-4-sect-3.2.2">
        <title>Visualización previa de fusiones</title>
        
        <para>Dado que el fusionado sólo genera modificaciones
          locales, normalmente no es una operación de alto riesgo. Si
          se equivoca en el fusionado la primera vez, simplemente
          ejecute <command>svn revert</command> para ignorar los
          cambios y pruebe de nuevo.</para>
        
        <para>Es posible, no obstante, que su copia local ya
          tenga algunas modificaciones. Los cambios aplicados por
          una fusión se mezclarán con sus modificaciones locales,
          por lo que ejecutar <command>svn revert</command> ya no
          es una opción. Los dos conjuntos de cambios quizás sean
          imposibles de separar.</para>

        <para>En casos como este, la gente se reconforta con la idea
          de ser capaces de predecir o examinar las fusiones antes
          de que ocurran. Una manera simple de hacerlo es ejecutar
          <command>svn diff</command> con los mismos argumentos que
          planea pasar a <command>svn merge</command>, tal y como
          ya le enseñamos en el primer ejemplo de fusionado. Otro
          método de visualización previa es pasar la opción
          <option>--dry-run</option> al comando de fusionado:</para>

        <screen>
$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>

        <para>La opción <option>--dry-run</option> en realidad no
          aplica ningún cambio a su copia local. Únicamente muestra
          los códigos de estado que <emphasis>serían</emphasis>
          mostrados durante una fusión de verdad.  Esto es útil
          para obtener una visualización previa de <quote>alto
          nivel</quote> de la potencial fusión, para aquellos
          casos en los que ejecutar <command>svn diff</command>
          proporcionaría demasiados detalles.</para>

      </sect3>

      <sidebar>
        <title>Subversion y los changesets</title>

        <para>Todo el mundo parece tener una idea diferente de la
          definición de <quote>changeset</quote>, o al
          menos expectaciones diferentes sobre lo que
          significa para un sistema de control de versiones
          tener <quote>características de changeset</quote>.
          Para nuestros propósitos, digamos que un changeset es una
          colección de cambios con nombre único. Los cambios pueden
          incluír ediciones textuales a los contenidos de un fichero,
          modificaciones a la estructura de un directorio, o cambios
          en los metadatos. En el habla habitual, un changeset es
          un parche con un nombre al que se puede referir.</para>

        <para>En Subversion, un número global de revisión N nombra el
          árbol en el repositorio: es la forma en la que quedó
          el repositorio tras el cambio número N. También es el
          nombre implícito de un changeset: si compara el árbol
          N con el árbol N-1, puede derivar el parche exacto
          cuyos cambios fueron hechos efectivos. Por esta razón,
          es fácil pensar de la <quote>revisión N</quote> no
          sólo como un árbol, sino también como un changeset. Si
          usa un software de gestión de tareas <!-- TODO buscar
          traducción issue tracker to manage bugs -->para tratar
          fallos, puede usar los números de revisión para hacer
          referencia a los parches específicos que corrigen
          determinados fallos&mdash;por ejemplo, <quote>este
          problema fue corregido en la revisión 9238.</quote>.
          Entonces alguien puede ejecutar <command>svn log
          -r9238</command> para obtener información del changeset
          exacto que corrigió el problema, y ejecutar <command>svn
          diff -r9237:9238</command> para ver el propio parche.
          Y el comando de fusionado de Subversion también usa números
          de revisión. Puede fusionar changesets específicos de una
          rama a otra nombrándolos en los parámetros de fusionado:
          <command>svn merge -r9237:9238</command> fusionaría el
          changeset #9238 en su copia local.</para>
      </sidebar>
      
      <sect3 id="svn-ch-4-sect-3.2.3">
        <title>Teniendo en cuenta o ignorando ascendencia</title>

        <para>Cuando hable con un desarrollador de Subversion, es
          muy posible que oiga alguna referencia al término
          <firstterm>ascendencia</firstterm>.  Esta palabra es
          usada para describir la relación entre dos objetos en un
          repositorio: si ambos están relacionados, entonces se dice
          que un objeto es el ancestro del otro.</para>

        <para>Por ejemplo, suponga que envía cambios al repositorio
          en la revisión 100, los cuales incluyen un
          cambio al fichero <filename>foo.c</filename>.
          Entonces <filename>foo.c@99</filename> es un
          <quote>ancestro</quote> de <filename>foo.c@100</filename>.
          Por otro lado, suponga que hace efectivo el borrado
          de <filename>foo.c</filename> en la revisión 101, y
          entonces añade un nuevo fichero con el mismo nombre en la
          revisión 102. En este caso, <filename>foo.c@99</filename> y
          <filename>foo.c@102</filename> pueden parecer relacionados
          (tienen la misma ruta), pero de hecho son objetos
          completamente diferentes en el repositorio. No comparten
          historial o <quote>ascendencia</quote>.</para>

        <para>La razón de mencionar esto ahora es para señalar
          una diferencia importante entre <command>svn diff</command>
          y <command>svn merge</command>. El primer comando
          ignora la ascendencia, mientras que el segundo es muy
          sensitivo a ella.  Por ejemplo, si usase <command>svn
          diff</command> para comparar las revisiones 99 y 102 de
          <filename>foo.c</filename>, vería ficheros diferenciales
          basados en líneas; el comando diff esta comparando
          a ciegas ambas rutas. Pero si usase <command>svn
          merge</command> para comparar ambos objetos, se daría
          cuenta de que no están relacionados y primero intentaría
          borrar el fichero antiguo, y entonces añadir el nuevo;
          vería <literal>D foo.c</literal> seguido por <literal>A
          foo.c</literal>.</para>

        <para>En la mayoría de las fusiones se comparan árboles que
          están relacionados por ascendencia, y por esta razón
          <command>svn merge</command> sigue este comportamiento
          por defecto. No obstante, ocasionalmente puede querer
          que el comando de fusionado compare dos árboles no
          relacionados. Por ejemplo, puede haber importado
          dos árboles de código fuente representando diferenes
          versiones <!-- TODO vendor release, no veo traducción
          sencilla --> de un proyecto de software (lea <xref
          linkend="svn-ch-7-sect-4"/>).  ¡Si usase <command>svn
          merge</command> para comparar los dos árboles, vería que
          el primero es borrado completamente, seguido de una adición
          completa del segundo!</para>

        <para>En estas situaciones, querrá que <command>svn
          merge</command> realice una comparación basada
          únicamente en rutas de fichero, ignorando cualquier
          relación existente entre ficheros y directorios. Añada
          la opción <option>--ignore-ancestry</option> a su
          comando de fusionado, y se comportará del mismo
          modo que <command>svn diff</command>. (Y de modo
          similar, <!-- TODO conversely? Buscar expresión? -->
          la opción <option>--notice-ancestry</option> hará que
          <command>svn diff</command> se comporte como un comando
          de fusionado.)</para>

      </sect3>

    </sect2>


  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-4">
    <title>Casos habituales de fusionado</title>

      <para>Hay muchos usos diferentes para <command>svn
        merge</command>, y esta sección describe los más comunes
        que posiblemente usará alguna vez.</para>

    <sect2 id="svn-ch-4-sect-4.1">
      <title>Fusionando una rama completa con otra</title>

      <para>Para completar el ejemplo que hemos ido mostrando,
        nos moveremos hacia adelante en el tiempo. Suponga que han
        pasado varios días, y se han realizado muchos cambios tanto
        en el tronco como en su rama privada. Suponga que ya ha
        terminado de trabajar en su rama privada; la característica
        o corrección está finalmente completada, y ahora quiere
        fusionar todos los cambios de su rama en el tronco para
        que otros puedan disfrutarlos. </para>

      <para>¿Cómo usamos <command>svn merge</command> en esta
        situación? Recuerde que este comando compara dos árboles,
        y aplica las diferencias en una copia local. Así que para
        recivir los cambios, necesita tener una copia local del
        tronco. Asumiremos que todavía tiene una copia original
        del tronco por alguna parte (completamente actualizada),
        o que recientemente ha obtenido una copia local fresca de
        <filename>/calc/trunk</filename>.</para>

      <para>¿Pero qué dos árboles deberían ser comparados? A primera
        vista, la respuesta puede parecer obvia: simplemente
        compare el último árbol del tronco con el último
        árbol de su rama. ¡Pero cuidado&mdash;esta asunción
        es <emphasis>incorrecta</emphasis>, y ha confundido
        <!-- TODO burned != confundido --> a muchos usuarios
        nuevos! Dado que <command>svn merge</command> funciona
        como <command>svn diff</command>, comparar el tronco y
        su rama <emphasis>no</emphasis> describirá meramente el
        conjunto de cambios realizados en su rama. Tal comparación
        muestra demasiados cambios: no solo mostraría la adición
        de los cambios en su rama, sino también <emphasis>el
        borrado</emphasis> de cambios en el tronco que nunca
        ocurrieron en su rama.</para>.

      <para>Para expresar únicamente los cambios que ocurrieron en
        su rama, necesita comparar el estado inicial de su rama
        con su estado final.  Usando <command>svn log</command>
        en su rama, puede ver que ésta fue creada en la revisión
        341. Y el estado final puede obtenerlo con la revisión
        <literal>HEAD</literal>. Esto significa que quiere comparar
        las revisiones 341 y <literal>HEAD</literal> del directorio
        de su rama, y aplicar esas diferencias a una copia local
        del tronco.</para>

      <tip>
        <para>Un buen método para encontrar la revisión en
        la cual fue creada una rama (la "base" de la misma)
        es usar la opción <option>--stop-on-copy</option> con
        <command>svn log</command>. El subcomando log normalmente
        muestra todo cambio realizado en la rama, incluyendo
        los de la copia a partir de la cual fue creada. Así que
        normalmente verá también la historia del tronco. La opción
        <option>--stop-on-copy</option> detendrá la salida del
        comando en cuanto <command>svn log</command> detecte que
        la rama fue copiada o renombrada.</para>

        <para>Así que en nuestro ejemplo contínuo:</para>

<screen>
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
&hellip;
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</screen>
        
        <para>Como esperábamos, el número final de revisión
        mostrado por este comando es la revisión en la cual
        <filename>my-calc-branch</filename> fue creado a raíz de
        una operación de copiado.</para>
      </tip>


      <para>De nuevo, aquí está el procedimiento final de
        fusionado:</para>

<screen>
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:HEAD http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</screen>

      <para>De nuevo, fíjese que el mensaje de cambios menciona de
        forma expecífica el rango de cambios que fue fusionado en el
        tronco. Recuerde siempre hacer esto, porque es información
        crítica que necesitará más adelante.</para>

      <para>Por ejemplo, suponga que decide continuar trabajando en
        su rama otra semana, para completar una mejora a una de
        las características originales o corregir un fallo. La
        revisión <literal>HEAD</literal> del repositorio es ahora
        480, y está listo para realizar otra fusión desde su
        rama privada al tronco.  Pero como se discutió en <xref
        linkend="svn-ch-4-sect-3.2"/>, no quiere fusionar los
        cambios que ya fueron fusionados; sólo quiere fusionar todo
        lo <quote>nuevo</quote> en su rama desde la última vez que
        fue fusionada. El truco es descubrir qué es lo nuevo.</para>

      <para>El primer paso es ejecutar <command>svn log</command>
        en el tronco, y buscar un mensaje de cambios sobre la última
        vez que realizó una fusión desde su rama:</para>

      <screen>
$ cd calc/trunk
$ svn log
&hellip;
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
&hellip;
</screen>
      
      <para>¡Ahá! Dado que todos los cambios que ocurrieron en la
        rama entre las revisiones 341 y 405 fueron fusionados
        con el tronco como la revisión 406, ahora sabe que sólo
        quiere fusionar los cambios de la rama posteriores
        a esto&mdash;comparando las revisiones 406 y
        <literal>HEAD</literal>.</para>

<screen>
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</screen>

      <para>Ahora el tronco contiene la segunda oleada completa
        de cambios realizados en la rama. En este punto, puede
        o bien borrar su rama (discutiremos esto más adelante), o
        continuar trabajando en su rama y repetir este procedimiento
        en siguientes operaciones de fusionado.</para>

    </sect2>

    <sect2 id="svn-ch-4-sect-4.2">
      <title>Deshaciendo cambios</title>

      <para>Otro uso común de <command>svn merge</command>
        es deshacer un cambio que acaba de ser enviado al
        repositorio. Suponga que está trabajando felizmente en
        su copia local de <filename>/calc/trunk</filename>,
        y descubre que el cambio realizado hace tiempo en la
        revisión 303, que modificó <filename>integer.c</filename>,
        está completamente mal.  Nunca debería haber llegado al
        repositorio. Puede usar <command>svn merge</command>
        para <quote>deshacer</quote> el cambio en su copia
        local, y entonces enviar las modificaciones locales al
        repositorio. Todo lo que necesita hacer es especificar la
        diferencia <emphasis>al revés</emphasis>:</para>


<screen>
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
&hellip;
# verify that the change is removed
&hellip;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</screen>

      <para>Una forma de pensar sobre las revisiones del repositorio
        es como un grupo de cambios (algunos sistemas de control de
        versiones los llaman <firstterm>changesets</firstterm>). Al
        usar el parámetro <option>-r</option>, puede pedirle a
        <command>svn merge</command> que aplique el changeset,
        o el rango completo de changesets sobre su copia local de
        trabajo. En nuestro caso para deshacer un cambio usamos
        <command>svn merge</command> para aplicar el changeset #303
        a nuestra copia local <emphasis>al revés</emphasis>.</para>
    
      <para>Tenga presente que reshacer un cambio de esta manera es
        como realizar cualquier otra operación <command>svn
        merge</command>, así que debería usar <command>svn
        status</command> y <command>svn diff</command> para
        confirmar que su trabajo está en el estado que usted
        desea, y entonces usar <command>svn commit</command> para
        enviar la versión final al repositorio. Tras el envío,
        este changeset particular ya no se verá reflejado en la
        revisión <literal>HEAD</literal>.</para>

      <para>De nuevo puede estar preguntándose: vaya, eso no deshizo
        el cambio anterior, ¿verdad? El cambio todavía existe en la
        revisión 303. Si alguien obtiene una versión del proyecto
        <filename>calc</filename> entre las revisiones 303 y 349,
        seguirán viendo todavía el cambio malo, ¿verdad?</para>

      <para>Si, en efecto. Cuando hablamos sobre
        <quote>eliminar</quote> un cambio, estamos hablando sobre
        eliminarlo de <literal>HEAD</literal>. El cambio original
        todavía existe en la historia del repositorio. En la
        mayoría de las situaciones, esto es suficiente. De todos
        modos la mayoría de las personas sólo están interesadas en
        seguir la versión <literal>HEAD</literal> de un proyecto.
        No obstante, hay casos especiales en los que realmente
        desearía destruir toda evidencia de un cambio. (Quizás
        alguien puso accidentalmente en el repositorio un documento
        confidencial.) Esto, tal y como verá, no es tan fácil porque
        Subversion fue diseñado deliberadamente para nunca perder
        información. Las revisiones son árboles inmutables que se
        construyen unos sobre otros. Eliminar una revisión de la
        historia podría causar un efecto dominó, creando caos en
        todas las revisiones siguientes y posiblemente invalidando
        todas las copias locales de trabajo.
        <footnote>
          <para>Sin embargo, el proyecto Subversion tiene planes
            para implementar algún día un comando <command>svnadmin
            obliterate</command> que realizaría la tarea de borrar
            información permanentemente. Mientras tanto, lea <xref
            linkend="svn-ch-5-sect-3.1.3"/> para una posible solución
            alternativa.</para>
        </footnote>
      </para>

    </sect2>

    <sect2 id="svn-ch-4-sect-4.3">
      <title>Resucitando elementos borrados</title>

      <para>La mejor característica de los sistemas de control
        de versiones es que la información nunca se pierde. Incluso
        cuando borra un fichero o un directorio, puede haberse
        esfumado de la revisión <literal>HEAD</literal>, pero el
        objeto todavía existe en revisiones anteriores. Una de
        las preguntas más comunes realizadas por nuevos usuarios
        es, <quote>¿Cómo puedo recuperar mi fichero o directorio
        antiguo?</quote></para>

      <para>The first step is to define exactly <emphasis
        role="bold">which</emphasis> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</para>

      <para>Subversion has no <filename>Attic</filename> directory
        like CVS does,
        <footnote><para>Because CVS doesn't version trees, it creates
          an <filename>Attic</filename> area within each repository
          directory as a way of remembering deleted
          files.</para>
        </footnote>
        so you need to use <command>svn
        log</command> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <command>svn log
        --verbose</command> in a directory which used to contain your
        deleted item.  The <option>--verbose</option> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor.)</para>

      <screen>
$ cd parent-dir
$ svn log --verbose
&hellip;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&hellip;
</screen>

      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        807.</para>

      <para>That was the hard part&mdash;the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>
      
      <para>One option is to use <command>svn merge</command> to apply
        revision 808 <quote>in reverse</quote>.  (We've already
        discussed how to undo changes, see <xref
        linkend="svn-ch-4-sect-4.2"/>.)  This would have the effect of
        re-adding <filename>real.c</filename> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <literal>HEAD</literal>.</para>

      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>integer.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <command>svn revert</command> the local modifications to
        <filename>integer.c</filename>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</para>

      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>

      <screen>
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</screen>

      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote> Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.</para>

      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-5">
    <title>Switching a Working Copy</title>

    <para> The <command>svn switch</command> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>

<screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>

    <para>After <quote>switching</quote> to the branch, your working
      copy is no different than what you would get from doing a fresh
      checkout of the directory.  And it's usually more efficient to
      use this command, because often branches only differ by a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>

    <para>The <command>svn switch</command> command also takes a
      <option>--revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the <quote>tip</quote>
      of the branch.</para>

    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>

      <orderedlist>
        <listitem> <para>Copy the project's entire 'trunk' to a new
        branch directory.</para>
        </listitem>
        <listitem>
          <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
        </listitem>
      </orderedlist>
    
    <para>In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal 'trunk' updates to most of their working copy,
      but the switched portions will remain immune (unless someone
      commits a change to their branch).  This feature adds a whole
      new dimension to the concept of a <quote>mixed working
      copy</quote>&mdash;not only can working copies contain a mixture
      of working revisions, but a mixture of repository locations as
      well.</para>
    
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</para>

    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<footnote><para>You <emphasis>can</emphasis>, however, use
      <command>svn switch</command> with the
      <option>--relocate</option> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <command>svn switch</command> section in <xref
      linkend="svn-ch-9"/> for more information and an example.</para>
      </footnote></para>
    
    <sidebar>
      <title>Switches and Updates</title>
      
      <para>Have you noticed that the output of <command>svn
          switch</command> and <command>svn update</command> look the
        same?  The switch command is actually a superset of the
        update command.</para>

      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client. The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        update command always compares two identical paths.</para>
      
       <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, then <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, then <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch-directory in the
        <literal>HEAD</literal> revision.</para>

      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
    </sidebar>

    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</para>

    <para>For example, suppose you have a working copy of
      <filename>/calc/trunk</filename> and make a number of changes to
      it.  Then you suddenly realize that you meant to make the
      changes to a branch instead.  No problem!  When you <command>svn
      switch</command> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-6">
    <title>Tags</title>

    <para>Another common version control concept is a
      <firstterm>tag</firstterm>.  A tag is just a
      <quote>snapshot</quote> of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that&mdash;a snapshot of the filesystem
      after each commit.</para>

    <para>However, people often want to give more human-friendly names
      to tags, like <literal>release-1.0</literal>.  And they want to
      make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release-1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>

    <sect2 id="svn-ch-4-sect-6.1">
      <title>Creating a Simple Tag</title>

      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, then make a copy of it:</para>

<screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</screen>

      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If it
        doesn't, see <xref linkend="svn-ch-9-sect-1.2-re-mkdir"/>).
        After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the project looked in the
        <literal>HEAD</literal> revision at the time you made the
        copy.  Of course you might want to be more precise about
        exactly which revision you copy, in case somebody else may
        have committed changes to the project when you weren't
        looking.  So if you know that revision 350 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 350</option> to
        the <command>svn copy</command> command.</para>

      <para>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>

      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy in there.  (That is,
        make sure they know not to commit to them.)  The second
        approach is more paranoid: you can use one of the
        access-control scripts provided with Subversion to prevent
        anyone from doing anything but creating new copies in the
        tags-area (See <xref linkend="svn-ch-6"/>.)  The paranoid
        approach, however, isn't usually necessary.  If a user
        accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</para>

    </sect2>
    
    <sect2 id="svn-ch-4-sect-6.2">
      <title>Creating a Complex Tag</title>
      
      <para>Sometimes you may want your <quote>snapshot</quote> to be
        more complicated than a single directory at a single
        revision.</para>
      
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bugfixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn update
        -r</command> liberally), or by switching files and directories
        to particular branches (making use of <command>svn
        switch</command>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</para>

      <para>Time to make a snapshot.  Copying one URL to another won't
        work here. In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (which you can read about in Chapter 9),
        including the ability to copy a working-copy tree to the
        repository:</para>

<screen>
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</screen>

      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy&mdash;mixed revisions, urls,
        and all.</para>

      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patchfile (which won't capture
        tree changes), you can instead use <command>svn copy</command>
        to <quote>upload</quote> your working copy to a private area
        of the repository.  Your collaborator can then either checkout
        a verbatim copy of your working copy, or use <command>svn
        merge</command> to receive your exact changes.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 7 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-7">
    <title>Branch Maintenance</title>

    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>

    <sect2 id="svn-ch-4-sect-7.1">
      <title>Repository Layout</title>
      
      <para>There are some standard, recommended ways to organize a
        repository.  Most people create a <filename>trunk</filename>
        directory to hold the <quote>main line</quote> of development,
        a <filename>branches</filename> directory to contain branch
        copies, and a <filename>tags</filename> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</para>

<screen>
/trunk
/branches
/tags
</screen>

      <para>If a repository contains multiple projects, admins
        typically index their layout by project (see <xref
        linkend="svn-ch-5-sect-6.1"/> to read more about
        <quote>project roots</quote>):</para>

<screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <command>svn move</command>
        operation might remove the path from the latest revision.
        When the user next runs <command>svn update</command>, they'll
        be told that their working copy represents a path that no
        longer exists, and the user will be forced to <command>svn
        switch</command> to the new location.
        </para>
      
    </sect2>
    
    <sect2 id="svn-ch-4-sect-7.2">
      <title>Data Lifetimes</title>

      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

<screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</screen>

      <para>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you'll still be able to see
        your old branch.</para>

      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy -r</command> to copy it from the old
        revision:</para>

<screen>
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</screen>

      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable <filename>calc</filename> project to the public, and
        you know it's going to take a couple of months to shake bugs
        out of the software.  You don't want people to add new
        features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>

<screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</screen>

      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bugfixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bugfixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&mdash;that is, as long
        as you continue to support that release for customers.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 8 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-8">
    <title>Summary</title>

    <para>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We've shown how
      to use <command>svn merge</command> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>

    <para>Remember the Subversion mantra: branches and tags are cheap.
      So use them liberally!</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->


