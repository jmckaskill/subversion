<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<appendix id="svn-ap-a">
  <title>Subversion para usuarios de CVS</title>

  <simplesect>

    <para>Este apéndice es una guía para usuarios de CVS nuevos en
      Subversion. Es esencial una lista de diferencias entre los dos
      sistemas <quote>visto desde 10,000 pies de alto</quote><!--TODO:
      viewed from 10,000 feet-->. Para cada sección, proporcionaremos
      cuando sea posible enlaces<!--TODO:backreferences--> a los
      capítulos relevantes.</para>

    <para>Aunque el fín de Subversion es <!--TODO:is to take over the current
      and future CVS user base-->asumir el control de la base actual
      y futura de los usuarios de CVS, algunas nuevas características
      y cambios de diseño fueron requeridos para arreglar ciertos
      comportamientos <quote>rotos</quote> que tenía CVS. Esto
      significa que, como usuario de CVS, puede necesitar romper
      hábitos&mdash;unos que usted olvidó...<!--TODO:ones that you
      forgot were odd to begin with-->.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-1">
    <title>Los números de revisión son diferentes ahora</title>

    <para>En CVS, los números de revisión son por-fichero. Esto es porque
      CVS usa RCS como motor de program<!--TODO:as a backend-->; cada
      fichero tiene su correspondiente fichero RCS en el repositorio,
      y el repositorio se representa<!--TODO:repository is roughly laid
      out according to the structure--> aproximadamente según la
      estructura de su árbol de proyecto.</para>

    <para>En Subversion, el repositorio parece un solo sistema de
      ficheros. Cada envío tiene como resultado<!--TODO:Each commit
      results in an entirely new filesystem-->un nuevo árbol de
      sistema de ficheros entero; en esencia, el repositorio es un
      array de árboles. Cada uno de estos árboles se etiqueta con un
      solo número de revisión. Cuando alguien habla sobre la
      <quote>revisión 54</quote>, ellos están hablando sobre un
      árbol particular (e indirectamente, la forma que el sistema
      de ficheros tenía despues del envío
      54<!--TODO:54th commit-->).</para>

    <para>Técnicamente, no es válido hablar sobre la <quote>revisión
      5 de <filename>foo.c</filename></quote>. En su lugar, uno diría
      <quote><filename>foo.c</filename> como aparece en la revisión
      5</quote>. También, tenga cuidado cuando haga supuestos sobre
      la evolución de un fichero. En CVS, las revisiones 5 y 6 de
      <filename>foo.c</filename> son siempre diferentes. En Subversion,
      es más probable que <filename>foo.c</filename>
      <emphasis>no</emphasis> haya cambiado entre las revisiones 5 y
      6.</para>

    <para>Para más detalles sobre este asunto, vea <xref
    linkend="svn-ch-2-sect-3.2" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-2">
    <title>Versiones de directorios</title>
    
    <para>Subversion sigue estructura de árbol<!--TODO:Subversion tracks
      tree structures-->, no solo el contenido de ficheros. Es una de las
      razones más grandes por las que Subversion fue escrito para
      reemplazar CVS.</para>

    <para>Esto es lo que significa para usted, como anterior usuario
      de CVS:</para>

    <itemizedlist>
      <listitem>
        <para>Los comandos <command>svn add</command> y <command>svn
          delete</command> trabajan ahora sobre directorios, tal como
          trabajan sobre ficheros. Así que haga <command>svn copy</command>
          y <command>svn move</command>. Sin embargo, estos comandos
          <emphasis>no</emphasis> causan ningún tipo de cambio
          inmediato en el repositorio. En su lugar, los objetos de la
          copia de trabajo simplemente se planifican para la adición
          o la eliminación. No sucede ningún cambio en el repositorio
          hasta que ejecute <command>svn commit</command>.</para>
      </listitem>
      <listitem>
        <para>Los directorios no serán contenedores estupidos nunca más;
          tienen número de revisión como los ficheros. (O más
          correctamente, es correcto hablar sobre <quote>directorio
          <filename>foo/</filename> en la revisión 5</quote>.)</para>
      </listitem>
    </itemizedlist>

    <para>Vamos<!--TODO:Let's talk... o es mejor decir "hablaremos"?-->
      a hablar más sobre este último punto. El versionado de directorios
      es un duro problema; porque queremos permitir <!--TODO:
      mixed-revision working copies-->copias de trabajo con revisiones
      mezcladas, hay algunas limitaciones en cómo podemos<!--TODO:
      on how far we can abuse-->abusar de este modelo.</para>

    <para>Desde un punto de vista teórico, definimos <quote>revisión
      5 del directorio <filename>foo</filename></quote> para significar
      una colección específica de directorios-entradas y características.
      Ahora suponga que empezamos a añadir y a quitar ficheros de
      <filename>foo</filename>, y luego envíamos el cambio. Sería una
      mentira decir que todavía tenemos la revisión 5 de
      <filename>foo</filename>. Sin embargo, si vemos <!--TODO:
      if we bumped <filename>foo</filename>'s revision number-->el número
      de revisión de <filename>foo</filename> despues del envío,
      tambien sería esto una mentira; puede haber otros cambios en
      <filename>foo</filename> que todavía no hayamos recibido, porque
      no hemos actualizado todavia.</para>
    
    <para>Subversion trata este problema siguiendo silenciosamente
      <!--TODO:by quietly tracking committed adds and deletes-->
      las agregaciones y las eliminaciones enviadas en el área
      <filename>.svn</filename>. Cuando usted ejecuta finalmente
      <command>svn update</command>, todas las cuentas se fijan
      <!--TODO:are settled--> con el repositorio, y el nuevo número
      de revisión se fija correctamente. <emphasis>Por lo tanto,
      solamente después de una actualización es verdaderamente
      seguro decir que usted tiene una revisión <quote>perfecta</quote>
      de un directorio.</emphasis> La mayoría del tiempo, su copia
      de trabajo contendrá revisiones <quote>imperfectas</quote> del
      directorio.</para>
    
    <para>Similarmente, un problema surge si usted intenta enviar
      <!--TODO:property changes on a directory--> cambios de las
      caracteristicas de un directorio. Normalmente, el envío
      <!--TODO:would bump--> chocaría con  el número local de revisión
      del directorio de trabajo. Pero otra vez, eso sería una mentira,
      porque puede haber añadidos<!--TODO:adds or deletes--> o
      eliminaciones que el directorio todavía no tiene, porque no ha
      habido ninguna actualización. <emphasis>Por lo tanto, usted no
      tiene<!--TODO:you are not allowed--> permiso para enviar
      cambios-características<!--TODO:property-changes--> sobre un
      directorio a menos que el directorio esté
      actualizado.</emphasis></para>

    <para>Para más discusión sobre las limitaciones del versionado de
      directorios, vea <xref linkend="svn-ch-2-sect-3.4"/>.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-3">
    <title>Más operaciones estando desconectado</title>
    <!--More Disconnected Operations-->

    <para>En años recientes, ha llegado a ser <!--TODO:outrageously cheap-->
      muy barata y abundante, pero el ancho de banda de red no. Por lo
      tanto, la copia de trabajo se Subversion ha sido optimizada alrededor
      del recurso más escaso.</para>

    <para>El directorio administrativo <filename>.svn</filename> tiene el
      mismo proposito que el directorio <filename>CVS</filename>, excepto
      que este también almacena copias <quote>pristinas</quote> de
      solo-lectura de sus ficheros. Esto le permite hacer muchas cosas
      desconectado:</para>
    
    <variablelist>
      
      <varlistentry>
        <term><command>svn status</command></term>
        <listitem>
          <para>Le muestra cualquier cambio local que haya hecho (vea <xref
              linkend="svn-ch-3-sect-4.3.1"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn diff</command></term>
        <listitem>
          <para>Le muestra los detalles de sus cambios (vea <xref
              linkend="svn-ch-3-sect-4.3.2"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn revert</command></term>
        <listitem>
          <para>Borra sus cambios locales (vea <xref
              linkend="svn-ch-3-sect-4.3.3"/>)</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>También, los ficheros prístinos almacenados permiten al cliente
      de Subversion enviar las diferencias al repositorio<!--TODO:client
      to send differences when committing-->, lo que CVS no puede
      hacer.</para>

    <para>El último subcomando en la lista es nuevo; este no solo borrará
      las modificaciones locales, sino que desprogramará
      <!--TODO: un-schedule-->las operaciones tales como adiciones y
      eliminaciones. Es la manera preferida para revertir un fichero;
      ejecutando <command>rm file; svn update</command> seguirá funcionando,
      pero empaña el propósito de actualización<!--TODO:it blurs the
      purpose of updating-->. Y, mientras nosotros estamos en este
      asunto&hellip;

    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-4">
    <title>Distinciones entre estado (status) y actualización (update)</title>

    <para>En Subversion, hemos intentado eliminar muchas de las confusiones
      entre los comandos <command>cvs status</command> y
      <command>cvs update</command>.</para>

    <para>El comando <command>cvs status</command> tiene dos propositos:
      primero, mostrarle al usuario cualquier modificación local en la
      copia de trabajo, y segundo, mostrarle al usuario qué ficheros
      están desactualizados. Desafortunadamente, debido a la dificil de
      leer salida de estado<!--TODO:status output-->, muchos usuarios de
      CVS no se aprobechan del todo de este comando. En cambio, han
      desarrollado el habito de ejecutar <command>cvs update</command>
      o <command>cvs update -n</command> para ver rapidamente sus
      modificaciones. Si los usuarios olvidan usar la opción
      <option>-n</option>, esto tiene el efecto secundario de combinar
      cambios del repositorio que no están preparados<!--TODO:this has the
      side effect of merging repository changes they may not be ready
      to deal with-->.</para>

    <para>Con Subversion, hemos intentado eliminar este desorden haciendo
      la salida de <command>svn status</command> facil de leer para los
      humanos y los programas de análisis sintacticos<!--TODO:parsers-->.
      También, <command>svn update</command> solo imprime información
      sobre los ficheros que están actualizados, <emphasis>no</emphasis>
      sobre modificaciones locales.</para>

    <para><command>svn status</command> imprime todos los ficheros que
      tienen modificaciones locales. Por defecto, no se contacta con el
      repositorio<!--TODO:the repository is not contacted...eso de "el
      repositorio no es contactado" no queda muy bien-->. Mientras
      este subcomando acepta un número justo de opciones, los siguientes
      son los usados más comúnmente:</para>

    <variablelist>
      <varlistentry>
        <term><option>-u</option></term>
        <listitem>
          <para>Contacta con el repositorio para determinar, y después
            mostrar, la información más desactualizada<!--TODO:
            out-of-dateness information-->.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term><option>-v</option></term>
        <listitem>
          <para>Muestra <emphasis>todas</emphasis> las entradas bajo
            el control de versiones.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-N</option></term>
        <listitem>
          <para>Se ejecuta no-recursivamente (no desciende hacia los
            subdirectorios).</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>El comando <command>status</command> tiene dos formatos de
      salida. En el formato <quote>corto</quote> por defecto, las
      modificaciones locales se parecen a esto:</para>

    <screen>
% svn status
M     ./foo.c
M     ./bar/baz.c
</screen>

    <para>Si usted especifica la opción <option>--show-updates</option>
      (<option>-u</option>), <!--TODO:a longer output format is
      used-->un formato de salida más largo es usado:</para>

    <screen>
% svn status -u
M             1047    ./foo.c
       *      1045    ./faces.html
       *         -    ./bloo.png
M             1050    ./bar/baz.c
Status against revision:   1066
</screen>

    <para>En este caso, aparecen dos columnas nuevas. La segunda columna
      contiene un asterisco si el fichero o directorio está desactualizado.
      La tercera columna muestra el número de revisión del objeto en la
      copia de trabajo. En el ejemplo de arriba, el asterisco indica que
      <filename>faces.html</filename> será parcheado si actualizamos, y
      que <filename>bloo.png</filename> es un nuevo fichero añadido
      en el repositorio. (El <command>-</command> al lado de
      <filename>bloo.png</filename> significa que todavía no existe en
      la copia de trabajo.)</para>

    <!-- ###TODO describe -u here as well as -uv. -u and -v use
         different <quote>long</quote> formats and need to be
         documented separately. Moreover, as you can combine -u and
         -v, it needs to be explained what each of them does. As -u is
         much more important than -v, and the example following that
         paragraph *is* about -u, not -v, my patch concentrated on
         that. -->

    <para>Por último<!--TODO:lastly-->, aquí está un resumen rápido de
      los códigos de estado más comunes que usted puede ver:</para>

    <screen>
A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local modifications
C    Resource has conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is external to this working copy (comes from another
       repository.  See <xref linkend="svn-ch-7-sect-2.3.6" />)
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
</screen>

    <!-- ###TODO:  This paragraph should be moved elsewhere.  We are
                   talking about status codes here, and not update.
                   Although CVS uses update as a form of status... -->
    <para>Subversion ha combinado los codigos de CVS <command>P</command>
      y <command>U</command> en<!--TODO:into just--> <command>U</command>.
      Cuando ocurre una fusión o un conflicto, Subversion simplemente
      imprime <command>G</command> o <command>C</command>, antes que
      una oración entera sobre esto<!--TODO:rather than a whole sentence
      about it-->.</para>

    <para>Para una discusión más detallada sobre <command>svn
    status</command>, vea <xref linkend="svn-ch-3-sect-4.3.1" />.</para>


  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-5">
    <title>Ramas y etiquetas</title>

    <para>Subversion no distingue entre el espacio del sistema de
      ficheros y el espacio de <quote>rama</quote>; las ramas y
      etiquetas son directorios ordinarios dentro del sistema de
      ficheros. Ésta es probablemente la única gran valla mental
      que un usuario de CVS tiene que superar. Lea todo sobre esto
      en <xref linkend="svn-ch-4"/>.</para>


    <warning>
      <para>Puesto que Subversion trata las ramas y etiquetas como
        directorios ordinarios, recuerde siempre descargar el directorio
        <literal>trunk</literal>
        (<literal>http://svn.example.com/repos/calc/trunk/</literal>)
        de su proyecto, y no el proyecto en si mismo<!--TODO:itself-->
        (<literal>http://svn.example.com/repos/calc/</literal>). Si
        comete el error de descargar el proyecto en sí mismo, obtendrá
        una copia<!--TODO:you'll wind up with a working copy that contains
        a copy--> de trabajo que contendrá una copia de su proyecto
        para cada rama y etiqueta que tenga.<footnote><para>Esto es,
        <!--TODO:providing you don't run out of disk space before
        your checkout finishes....no tengo ni idea de como traducirlo-->
        proporcionando no ejecute hacia afuera el espacio en disco
        antes de que su descarga finalice.</para> </footnote></para>
    </warning>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-6">
    <title>Propiedades de los metadatos</title>

    <para>Una característica nueva de Subversion es que usted puede
      unir metadatos arbitrarios (o <quote>propiedades</quote>) a
      ficheros y directorios. Las propiedades son pares arbitrarios
      nombre/valor asociados con ficheros y directorios en su copia
      de trabajo.</para>
    
    <para>Para fijar u obtener un nombre de propiedad, use los
      subcomandos <command>svn propset</command> y
      <command>svn propget</command>. Para enumerar todas las
      propiedades de un objeto, use <command>svn proplist</command>.
    </para>

    <para>Para más información, vea <xref linkend="svn-ch-7-sect-2"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 7 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-7">
    <title>Resolución de conflictos </title>

    <para>CVS marca conflictos en linea con <quote>marcas de
      conflicto</quote>, e imprime una <command>C</command>
      durante la actualización. Historicamente, esto ha causado
      promlemas, porque CVS no está haciendo bastante. Muchos
      usuarios se olvidan (o no ven) la <command>C</command>
      después de que <!--TODO:after it whizzes by on their terminal-->
      esta silbe en sus terminales. Se olvidan a menudo de que las
      marcas de conflicto están incluso presentes, y después
      accidentalmente envian los ficheros conteniendo las marcas
      de conflicto.</para>

    <para>Subversion solventa este problema haciendo los conflictos
      más tangibles. Recuerde que un fichero está en estado de
      conflicto, y no permitirá que envie sus cambios hasta que
      ejecute <command>svn resolved</command>.  Vea <xref
      linkend="svn-ch-3-sect-4.4"/> para más detalles.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 8 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-8">
    <title>Ficheros binarios y traducción</title>

    <para>En el sentido más general, Subversion maneja ficheros
      binarios más elegantemente que CVS. Porque CVS usa RCS, solo
      puede almacenar copias completas sucesivas de un fichero
      binario que cambia. Pero internamente, Subversion expresa
      diferencias entre ficheros usando un algoritmo de
      diferenciador de binarios<!--TODO:binary-differencing-->,
      sin importar si contienen datos o datos binarios. Esto
      significa que todos los ficheros son almacenados
      diferenciados<!--TODO:differentially--> (comprimidos) en el
      repositorio, y las pequeñas diferencias son siempre enviadas
      a traves <!--TODO:over the network...a traves o sobre la red?-->
      de la red.</para>
    
    <para>Los usuarios de CVS tienen que marcar los ficheros binarios con
      los parámetros <option>-kb</option>, para evitar que los datos sean
      mutilados (debido a la traducción de la expansión de la palabra
      clave y del final de linea<!--TODO:due to keyword expansion and
      line-ending translations-->. A veces se olvidan de hacerlo.</para>

    <para>Subversion toma la ruta más paranoica: primero, nunca realiza
      ningún tipo de traducción de la palabra clave  o del fin de linea
      a menos que usted le diga explicitamente que lo haga (vea <xref
      linkend="svn-ch-7-sect-2.3.4"/> y <xref
      linkend="svn-ch-7-sect-2.3.5"/> para más detalles). Por defecto,
      Subversion trata todos los datos del ficheros como una cadena
      literal de bytes, y los ficheros son siempre guardados en el
      repositorio en un estado sin traducir.</para>

    <para>Segundo, Subversion mantiene una noción interna de si un
      fichero es <quote>texto</quote> o datos <quote>binarios</quote>,
      pero esta noción es <emphasis>solamente</emphasis> existente
      en la copia de trabajo. Durante un <command>svn update</command>,
      Subversion realizará fusiones contextuales<!--TODO:contextual
      merges... fusiones de texto--> en ficheros de texto modificados
      localmente, pero no intentará hacer eso para los ficheros
      binarios.</para>

    <para>Para determinar si es posible una fusión de contexto,
      Subversion examina la propiedad <literal>svn:mime-type</literal>.
      Si el fichero no tiene la propiedad <literal>svn:mime-type</literal>,
      o tiene un tipo MIME que es textual (por ejemplo
      <literal>text/*</literal>), Subversion asume que es texto. Si no,
      Subversion asume que el fichero es binario. Subversion también
      ayuda a los usuarios ejecutando un algoritmo de detección de
      binarios en los comandos <command>svn import</command> y
      <command>svn add</command>. Estos comandos harán una buena
      conjetura y despues (posiblemente) fije una propiedad
      <literal>svn:mime-type</literal> binaria en el fichero que es
      agregado. (Si Subversion supone mal, el usuario siempre puede
      borrar o editar a mano la propiedad.)</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 9 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-9">

    <title>Versionado de modulos</title>

    <para>A diferencia de CVS, una copia de trabajo de Subversion es
      consciente que ha descargado un modulo. Eso significa que si
      alguien cambia la definición de un módulo, entonces una llamada
      a <command>svn update</command> actualizará la copia de trabajo
      apropiadamente.</para>

    <para>Subversion define los módulos como una lista de directorios
      dentro de una propiedad del directorio: vea
      <xref linkend="svn-ch-7-sect-3"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 10 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-10">

    <title>Autentificación</title>

    <para>Con el servidor de CVS, usted está obligado<!--TODO:you are
      required to login--> a <quote>loguearse</quote> al servidor
      antes de cualquier operación de lectura o escritura&mdash;usted
      incluso tiene que loguearse para operaciones anonimas. Con un
      repositorio de Subversion usando Apache HTTPD como el servidor,
      en principio usted no proporcionará ningún credencial de
      autentificación<!--TODO:you don't provide any authentication
      credentials at the outset-->&mdash;si una operación que usted
      realiza requiere de autentificación, el servidor le desafiará
      para sus credenciales<!--TODO:the server will challenge you for
      your credentials--> (donde<!--TODO:wheter--> esos credenciales
      son username y password, una certificación de cliente, o
      incluso ambos). De este modo si su repositorio es world-readable
      <!--TODO:como traducir esto?-->no le requerirán autentificarse
      para las operaciones de lectura.<!--TODO:you will not be required
      to authenticate at all for read operations--></para>

    <para>As with CVS, Subversion still caches your credentials on
      disk (in your <filename>~/.subversion/auth/</filename>
      directory) unless you tell it not to by using the
      <option>--no-auth-cache</option> switch.</para>



  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 11 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-11">

    <title>Convirtiendo un repositorio de CVS a Subversion</title>

    <para>Quizá la manera más importante de familiarizar a usuarios de
      CVS con Subversion es dejarles continuar trabajando en sus
      proyectos usando el nuevo sistema. Y mientras que eso se puede
      lograr usando una importación plana<!--TODO:flat import into a
      Subversion repository--> a un repositorio de Subversion de un
      repositorio exportado de CVS, la solución más cuidadosa implica
      el transferir no solo la última foto<!--TODO:snapshot--> de sus
      datos, sino toda la historia detras de esta también, a partir
      de un sistema al otro. Éste es un problema extremadamente dificil
      a solucionar que implica<!--TODO:that deducing changesets in the
      absence of atomicity--> la deducción de cambios en ausencia de
      atomicidad, y traducción entre las politicas de ramificación
      <!--TODO:between the system' completely orthogonal branching
      policies-->totalmente ortogonal de los sistemas, entre otras
      complicaciones. No obstante, hay un puñado de herramientas que
      que demandan apoyar por lo menos parcialmente la capacidad de
      convertir los repositorios existentes de CVS en unos de
      Subversion<!--TODO:to convert existing CVS repositories into
      Subversion ones-->.</para>

    <para>Una herramienta<!--TODO:one such tool--> de estas es
      cvs2svn (<systemitem
      class="url">http://cvs2svn.tigris.org/</systemitem>), un script de
      Python creado originalmente por miembros miembros de la propia
      comunidad de desarrollo de Subversion. Otros incluidos el módulo
      conversor para<!--TODO:converter plugin to the VCP tool--> la
      herramienta VCP de Chia-liang Kao (<systemitem
      class="url">http://svn.clkao.org/revml/branches/svn-perl/</systemitem>)
      y el RefineCVS de Lev Serebryakov's (<systemitem
      class="url">http://lev.serebryakov.spb.ru/refinecvs/</systemitem>).
      Estas herramientas tienen varios niveles en estado completo<!--
      TODO:levels of completeness-->, y pueden tomar decisiones enteramente
      diferentes sobre cómo manejar la historia de su repositorio de CVS.
      Cualquier herramienta que decida usar, asegurese de realizar tantas
      verificaciones como pueda basandose en el resultado de conversión<!--
      TODO:perform as much verification as you can stand on the
      conversion results-->&mdash;¡después de todo, usted ha trabajado
      duro para construir esa historia!</para>

    <para>Para una colección actualizada de enlaces a herramientas
      <!--TODO:links to known converter tools-->conversoras conocidas,
      visite la página de enlaces del website de Subversion (<systemitem
      class="url">http://subversion.tigris.org/project_links.html</systemitem>).</para>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
