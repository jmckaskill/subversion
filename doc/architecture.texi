@node Architecture
@chapter Architecture


Subversion is conceptually divided into a number of seperable layers.

Assuming that the interface (API) of each layer is well-defined, it is
easy to customize the system; new client apps, new network protocols,
new servers, and new database back-ends are possible.

The following diagram illustrates the "layered" architecture, and where
each particular interface lies.

@c Should we bother to maintain the "dia"/postscript version of this
@c diagram?  It would look much nicer when printed.  But maybe it's just
@c not worth it.

@example

             +--------------------+  
             | commandline or GUI |
             |    client app      |           
 +---------------------+-------------------+ <====== Client interface
 |    Working Copy     |  Network Access   |                         
 |   Management Lib    |       Lib         |                         
 +---------------------+---------+---------+ <====== Network interface
                       |      libneon      |                          
                       +---------+---------+   
                      ^              ^        
                     /              / 
               DAV  /              /  HTTP
                   /              /       
                  v              v        
          +---------+    +---------+      
          |         |    |         |        
          | Apache  |    | Apache  |        
          |         |    |         |      
          +---------+    +---------+      
          | mod_DAV |    |         |      
        +-------------+  | mod_SVN |
        | mod_DAV_SVN |  |         |
 +------+-------------+--+---------+-------+ <===== Server interface
 |                                         |                        
 |            Main SVN Library             |                        
 |                                         |                        
 +-----------------------------------------+ <===== Filesystem interface
 |                                         |                            
 |          Subversion Filesystem          |                            
 |                                         |                            
 +-+--------------+--------+---------+-----+                            
   | Berkeley DBM |        |   SQL   |                                  
   +--------------+        +---------+      
               
@end example
@c Let's just say that emacs' "picture" mode is an excellent thing!


@menu
* Semantics::
* Client Layer::                   
* Network Layer::  
* Server Layer::
@end menu

@c ------------------------------------------------------------------
@node Semantics
@section Semantics

In order to communicate properly, the Subversion client and server must
agree on a set of high-level operations that are required to perform
version control.  This includes:

@itemize *
@item
      the ability to discuss differences between repository and working
      copy (by exchanging "delta" objects)
@item
      the ability to read or write a file's text or properties
@item
      the ability to update or commit a working copy
@item
      the ability to work with branches and tags
@end itemize

These operations are made concrete in the interfaces (APIs) provided by
certain client and server header files.  (More on this below.)

@c ------------------------------------------------------------------
@node Client Layer
@section Client Layer

The Subversion client is a binary application (either command-line or
GUI) which links to two shared libraries.

The first shared library provides an API for managing the client's
"working copy" of a project.  This includes concepts like local renaming
or removal of files, patching files, extracting diffs, and a slew of
routines for maintaining administrative files in the SVN/ directory.

The second shared library provides an API for requests that require
talking to a subversion server.  This includes routines to open a
connection to a server via a protocol of choice.  However, most of the
API represents operations defined by the "main" Subversion library.
(@xref{Semantics}.)

For interface details, @xref{Client}.
        
@c ------------------------------------------------------------------
@node Network Layer
@section Network Layer

The network layer's job is to move Subversion's semantics over a wire.

On the client side, a network library translates these ideas into a set
of either HTTP 1.1 or WebDAV method extensions.  (HTTP 1.1 allows one to
define new methods.)  For interface specifics, see the header files for
@dfn{libneon}.

The information is sent over TCP/IP to an Apache server.  Apache is used
for the following reasons:

@itemize *
@item
      time-tested and extremely stable
@item
      built-in load-balancing
@item
      built-in proxy and firewall support
@item
      built-in authentication and encryption
@item
      allows client-side caching
@item
      extensible module system
@end itemize

The general suspicion is that any attempt to write a dedicated
"subversion server" (with a "subversion protocol") would inevitably end
up evolving towards Apache's already-existing feature set.  (However,
Subversion's layered architecture certainly doesn't @emph{prevent}
anyone from writing a totally new network layer!)

Depending on whether DAV or HTTP 1.1 is used, an appropriate Apache
module will translate the method-requests back into Subversion
semantics, making calls to the "main" Subversion library.

For details, @xref{Protocol}.

@c ------------------------------------------------------------------
@node Server Layer
@section Server Layer

The back-end of Subversion consists of two libraries: the Main
Subversion library and the Subversion Filesystem.

The @dfn{Main Subversion library} provides an API representing general
version-control services that the client requires (@xref{Semantics}.)

These high-level routines make calls directly into the @dfn{Subversion
Filesystem library}.  The Subversion Filesystem defines a simple,
abstract UNIX-like filesystem with a twist: write () calls are versioned
and atomic, and no data is ever deleted!  (@xref{Filesystem}.)

These filesystem calls then talk to disk, either through a set of
Berkeley DBM files, or a more powerful SQL database.  (Although any
back-end with a concept of atomic "transactions" will work.)

For a more detailed explanation: @xref{Server}.
