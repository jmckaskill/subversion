@node Server
@chapter Server

@c Ben is hacking on this.

The @dfn{Subversion server} isn't a simple, monolithic daemon process
like sshd or ftpd; rather, it's a set of well-defined interface layers
that is meant to be flexible and open to future innovations.

However, please remember that after all is said and done, it's
@emph{Apache} that is the actual Subversion server process; all of the
lower layers are simply shared libraries running in Apache's address
space!

In a nutshell:

@enumerate
@item
    Apache receives a Subversion-specific HTTP method request.
@item
    An appropriate Apache module handles the request, and makes calls
    into the "main" Subversion library.
@item
    The "main" library interacts with an abstract, versioned filesystem
    and returns a response.
@item
    The Apache module converts this response back into an HTTP response
    to be sent to the client.
@end enumerate


To build our concepts cleanly, we'll explore the server-side of
Subversion from the bottom up.  (For full diagram, @xref{Architecture}.)

@example

 +------+-------------+--+---------+-------+ <===== Server interface
 |                                         |
 |            Main SVN Library             |
 |                                         |
 +-----------------------------------------+ <===== Filesystem interface
 |                                         |
 |          Subversion Filesystem          |
 |                                         |
 +-+--------------+--------+---------+-----+ <===== Database interface
   | Berkeley DBM |        |   SQL   |
   +--------------+        +---------+

@end example

@menu
* Database::                  Putting the information on disk.
* Filesystem::                The low-level Subversion Filesystem.
* Locking::                   How read/write locks work in the Filesystem.
* Main Library::              The highest-level server interface.
* Apache::                    The actual server process.
@end menu

@c ----------------------------------------------------------------

@node Database
@section Database

At the bottom of our design, we require a way of storing information on
disk.  More specifically, we need @dfn{transactions}.

A @dfn{transaction} is a term that refers to a set of modifications made
to a database; however, these modifications behave as a @emph{single
unit} of change.  Specifically,

@enumerate
@item
   If a transaction succeeds, the database recognizes a single unit of
   work as having been performed.  (And if the database allows you to
   "undo" the work, the entire set of changes is undone as a unit.)
@item
   If some portion of the transaction fails (for either logical or
   hardware-crash reasons), then the @emph{entire}
   transaction fails, and no changes are made at all.  The database is
   guaranteed to remain in a good, consistent state.
@end enumerate

This inability to divide the set of changes is known as @dfn{atomicity},
and is the critical concept behind transactions.

Subversion's @dfn{database interface} (@dfn{svn_db.h}), therefore, is a
simple API for reading and writing information to any sort of disk-based
system that supports transactions.  The Subversion Filesystem
(@xref{Filesystem}.)  is the only library that depends on this
interface.

@c OK, guys, this is tricky to specify.  This requires a good knowledge
@c of Berkeley DBM's API, SQL, and database API's in general!  What's
@c written here is a simplification of a typical DBM API:

@table @code
@item svn_db_init ()
   tell the database to initialize itself
@item svn_db_open (path)
   open a particular database file (or object)
@item svn_db_close (db)
   close a database file (or object)
@item svn_db_txn_begin (db, *txn_id)
   start a transaction, receiving transaction_id
@item svn_db_put (db, *txn_id, *key, *value)
   write a key/value pair into the database
@item svn_db_get (db, *txn_id, *key, *value)
   read a key/value pair from the database
@item svn_db_del (db, *txn_id, *key)
   remove a key/value pair from the database
@item svn_db_txn_commit (db, *txn_id)
   commit the transaction
@item svn_db_txn_abort (db, *txn_id)
   abort the transaction in progress
@end table

For the initial release of Subversion, we will probably use the
open-source Berkeley DBM library.  (For information, see
@uref{http://www.sleepycat.com, Sleepycat Software}.)

In the future, of course, contributors are free to write libraries that
implement this same API on top of a more powerful SQL system.


@c ----------------------------------------------------------------

@node Filesystem
@section Filesystem

The @dfn{Subversion Filesystem} (abbreviated: @dfn{svn_fs}) gives us an
abstract way of thinking about the way files are stored and versioned,
independent of the actual means of storage.

Like any typical UNIX-like filesystem, files are stored in a tree.
However, while CVS uses the actual UNIX filesystem to store items, the
svn_fs implements files and directories as database objects
(@xref{Database}.)

To begin, please be sure that you're already casually familiar with
Subversion's ideas of files, directories, and version histories.  If
not, @xref{Model}.

@subsection Definitions

For completeness, we can now offer a precise, technical description of
these terms.  Here is the schema used by svn_fs:

@c This is taken from jimb's very first Subversion spec!
@c <jimb> -----------------------------

@quotation

A @dfn{text string} is a string of Unicode characters which is
canonically decomposed and ordered, according to the rules described in
the Unicode standard.

A @dfn{string of bytes} is what you'd expect.

A @dfn{property list} is an unordered list of properties with unique
names.  A @dfn{property} is a pair @code{(@var{name}, @var{value})},
where @var{name} is a text string, and @var{value} is a string of bytes.

A @dfn{file} is a property list and a string of bytes.

A @dfn{node} is either a file or a directory.  (We define a directory
below.)  Nodes are distinguished unions --- you can always tell whether
a node is a file or a directory.

A @dfn{node table} is an array mapping some set of positive integers,
called @dfn{node numbers}, onto @dfn{nodes}.  If a node table maps some
number @var{i} to some node @var{n}, then @var{i} is a @dfn{valid node
number} in that table, and @dfn{node @var{i}} is @var{n}.  Otherwise,
@var{i} is an @dfn{invalid node number} in that table.

A @dfn{directory entry} is a triple @code{(@var{name}, @var{props},
@var{node})}, where @var{name} is a text string, @var{props} is a
property list, and @var{node} is a node number.

A @dfn{directory} is an unordered list of directory entries.

A @dfn{version} is a node number and a property list.

A @dfn{history} is an array of versions, indexed by a contiguous range
of positive integers containing 1.

A @dfn{repository} consists of node table and a history.

@end quotation
@c  </jimb> ----------------------


@subsection Basic Reading

Here are functions to retrieve information from the filesystem, designed
to be fast and convenient for any process using svn_fs.

@table @code
@item latest ()
 returns the latest global version of the repository
@item read (version, path)
 if path is a file, return full text (which includes property stream);@*
 if path is a directory, return list of directory entries.
@item get_node_props (version, path)
 return a list of all props of a file or directory entry
@item get_version_props (version)
 return a list of all props of a version
@item read_node_prop (version, path, propname)
 read a particular property of a file or directory entry
@item read_version_prop (version, propname)
 read a particular property of a version (such as a log)
@end table


@subsection Deltas

A @dfn{delta} object is a specific data structure in Subversion which
efficiently describes the difference between two file trees.  Deltas are
absolutely critical in the communication between Subversion clients and
servers.  For a full explanation, @xref{Protocol}. 

A single basic routine is provided which asks the server to build and
return a delta from the Subversion filesystem:

@table @code
@item request_delta (versionX, pathA, versionY, pathB)
 return a delta object which converts subtree A:X into subtree B:Y
@end table


@subsection Basic Writing

Anytime a process needs to modify the filesystem, it must do three
things:

@enumerate
@item
  Build a delta object, representing a group of changes to a base
  revision of a tree.  (This must be done either on the client side, or
  using a separate delta library.)
@item
  Request permission from the server to write the delta as a transaction.
@item
  If permission is granted, apply the delta.
@end enumerate

Please remember that because we're dealing with the "Big Bytestring"
model of files, that this process includes any sort of change to a
file's text @emph{or} properties!

@table @code
@item submit (delta)
 ask filesystem's lock manager for approval of delta; returns token (or
failure)
@item write (delta, token)
 actually write the delta into the filesystem
@item abandon (token)
 tell lock manager that the delta will @emph{not} be written (despite
 previous approval)
@end table

For a fuller description of Subversion's write-locking mechanism,
@xref{Locking}.


@c ----------------------------------------------------------------

@node Locking
@section Locking

The Subversion Filesystem has a locking mechanism built into it.

The locking system was designed to have these features:

@enumerate
@item
    There can any number of concurrent filesystem @dfn{readers}, and a
    reader never has to wait for any other process.
@item
    There can any number of concurrent filesystem @dfn{writers},
    provided that their changes do not directly conflict.  When writers
    @emph{do} need to wait, the waiting is kept to an absolute minimum.
@end enumerate

@subsection Read Locks

Reading is easy; if a server process wants to execute a @code{read()}
call into the filesystem, it goes right through.  The design of the
versioning filesystem (@xref{Model}.) allows a reader to simply skip
down the version history, locate the correct "root" node, and then
follow the particular tree downwards to the file or directory it wishes
to read.  Any number of readers can follow this algorithm without
interfering with another; and because writers don't link to the version
history until they're finished writing everything, there's no way for a
reader to accidentally stumble upon an unfinished tree.

@subsection Write Locks

Each Subversion filesystem has a process called a @dfn{lock manager}.
The lock manager isn't always running;  when a server process wishes to
execute a @code{write()} on the filesystem, it must first determine if a
lock manager is running.  If not, it starts one.

@example

                  D              /
                   \            /
                    \          /
                     |        /
                     v       /
       +--------------------|--------------+
       |                    v              |
       |             Approved?             |
       |                |                  |
       |                |                  |
       |                v                  |
       |          Concurrency Pool         |
       |       +--------------------+      |
       |       |     D            D |      |
       |       |  D        D   D    |      |
       |       +--------------------+      |
       +-----------------------------------+

@end example

After the lock manager is up, the server process first sends it a
@code{submit()} call containing the delta it would like to write.

The lock manager contains a pool of "approved changes".  This pool is a
set of deltas which have been okayed for concurrent application to the
filesystem.  After receiving a delta from @code{submit()}, the lock
manager determines if it is safe to apply the new delta at the same time
as the other ones in progress.@footnote{This rule is actually quite
simple:  a set of deltas may be concurrently written @emph{if and only
if} the order in which they are applied does not matter!}

If the lock manager decides that the requested delta conflicts with
other deltas being applied at that moment, it returns a failure to the
server, and the server must wait and try again with another
@code{submit()} request.

If the lock manager decides that the requested delta does not conflict,
it returns a transaction token to the server.  The server then uses this
token to execute a @code{write()} on the filesystem.

After the @code{write()} is completed, the delta is removed from the
lock manager's concurrency pool, and the server closes its connection.

When the lock manager has no more open server connections, it dies.




@c ----------------------------------------------------------------

@node Main Library
@section Main Library

The Main Subversion Library (@dfn{svn_main}) provides a high-level
server API to the Subversion client.

In general, it provides an API that maps to CVS concepts whereever
possible.

@subsection Methods

The Subversion server makes itself useful to clients by providing
@dfn{methods}.  This term is used intentionally, because it lines up
well with our initial implementation of the network layer (done with
Apache and custom HTTP "methods", @xref{Protocol}.)

@table @code
@item available_methods ()
  return a list of methods that the server supports 
@end table

@subsection Basic Methods

These are the basic methods made available to clients.

@table @code
@item checkout (repository, version, path)
  grab a working copy of a section of the filesystem, rooted at
  @emph{path}
@item commit (repository, delta)
  check a delta object into the repository (the delta is generated by
  the client)
@end table

@subsection Simple Filesystem Reads

Here are some methods for doing quick, easy reads from the Subversion
filesystem;  they're essentially identical to the direct Filesystem
calls, except that they require the name of a specific repository as the
first argument.

@table @code
@item latest (repository)
 returns the latest global version of the repository
@item read (repository, version, path)
 if path is a file, return full text (which includes property stream);@*
 if path is a directory, return list of directory entries.
@item get_node_props (repository, version, path)
 return a list of all props of a file or directory entry
@item get_version_props (repository, version)
 return a list of all props of a version
@item read_node_prop (repository, version, path, propname)
 read a particular property of a file or directory entry
@item read_version_prop (repository, version, propname)
 read a particular property of a version (such as a log)
@end table


@subsection Plug-Ins

It's important that svn_main be extensible;  by allowing users to write
their own server-side libraries, the server's abilities can potentially
grow forever.

We define the term @dfn{plug-in} to refer to a library designed to be
loaded into svn_main's address space.  This term is used intentionally
(instead of "module") so as not to be confused with Apache modules.
Each plug-in can potentially implement a new set of server "methods"
(@xref{Methods}.)

When starting up, svn_main will read a configuration file @dfn{svn.conf}
(much like Apache's @emph{httpd.conf}) which, among other things, will
specify a list of available plug-ins and their actual locations on
disk.  If and when a client requests a particular method, svn_main then
knows which plug-in to "auto-load" as necessary.

A plug-in needs access to the svn_main internals, and therefore uses
svn_main's private header files.  Additionally, we define:

@c Hand-waving this API for now, not critical to define just yet:

@table @code
@item register_method (name)
  register a new method in svn_main's list of available methods
@end table


Here are some ideas for future plug-ins:

@itemize @bullet
@item
  @strong{annotate} : provides annotation of individual files (i.e. who
  wrote which line in which version).  This is a basic command in CVS,
  but is not critical for Subversion's first release.  By implementing
  it later as a plug-in, the command becomes much more customizable.
@item
  @strong{grep} : the ability to search the Subversion filesystem
  quickly for text or properties
@item
  @strong{guile} : a plug-in which provides glue between svn_main and
  libguile.so, thereby giving the Subversion server an extensible
  scripting language.  (This could also be done with @strong{perl} or
  @strong{python}.)
@end itemize

