@node Server
@chapter Server

The term ``server'' is ambiguous, because it has at least two different
meanings: it can refer to a powerful computer which offers services to
users on a network, or it can refer to a CPU process designed to receive
network requests.

In Subversion, however, the @dfn{server} is just a set of libraries that
implement a set of @dfn{repositories} and make them available to other
programs.  No networking is required.

Of course, for the initial release of Subversion, the ``server'' process
will be Apache interacting with the Subversion server libraries.  The
``server'' computer will be any machine running this special Apache
process.  (@xref{Protocol}.)

@menu
* Filesystem::                The Subversion Filesystem.
* Main Library::              The highest-level server interface.
@end menu


@c ----------------------------------------------------------------

@node Filesystem
@section Filesystem

@subsection Overview

@itemize
@item
  @b{Requires:}
  @itemize
  @item
    the Subversion database interface
  @item
    an operating system that supports interprocess communication (IPC)
  @end itemize
@item
  @b{Provides:}
  @itemize
  @item
    an abstract representation of a repository
  @item
    support for multiple concurrent accesses (via a lock manager)
  @item
    enforcement of user & group permissions (via ACLs)
  @end itemize
@end itemize


The @dfn{Subversion Filesystem} (abbreviated: @dfn{svn_fs}) gives us an
abstract way of thinking about the way files are stored and versioned in
a repository -- independent of the actual means of storage.  

Like any typical UNIX-like filesystem, files are stored in a tree.
However, while CVS uses the actual UNIX filesystem to hold a repository,
svn_fs implements files and directories as database objects
(@xref{Database}.)  This not only gives us low-level transactions,
but allows us to store @dfn{properties} ( or ``meta-data'') with each
file, directory, directory entry, and even version number.  (For
example, some useful properties might be @{author, creation date,
modification date, Access Control List (ACL), file type (text, binary),
file encoding, ...@}.)

@subsection Schema

To begin, please be sure that you're already casually familiar with
Subversion's ideas of files, directories, and version histories.  If
not, @xref{Model}.  For completeness, we can now offer a precise,
technical description of these terms.

@c This is taken from jimb's very first Subversion spec!
@c Is there some standardized notation for describing schemas like this?
@c <jimb>

@quotation

A @dfn{text string} is a string of Unicode characters which is
canonically decomposed and ordered, according to the rules described in
the Unicode standard.

A @dfn{string of bytes} is what you'd expect.

A @dfn{property list} is an unordered list of properties.  A
@dfn{property} is a pair @code{(@var{name}, @var{value})}, where
@var{name} is a text string, and @var{value} is a string of bytes.
No two properties in a property list have the same name.

A @dfn{file} is a property list and a string of bytes.

A @dfn{node} is either a file or a directory.  (We define a directory
below.)  Nodes are distinguished unions --- you can always tell whether
a node is a file or a directory.

A @dfn{node table} is an array mapping some set of positive integers,
called @dfn{node numbers}, onto @dfn{nodes}.  If a node table maps some
number @var{i} to some node @var{n}, then @var{i} is a @dfn{valid node
number} in that table, and @dfn{node @var{i}} is @var{n}.  Otherwise,
@var{i} is an @dfn{invalid node number} in that table.

A @dfn{directory entry} is a triple @code{(@var{name}, @var{props},
@var{node})}, where @var{name} is a text string, @var{props} is a
property list, and @var{node} is a node number.

A @dfn{directory} is an unordered list of directory entries, and a
property list.

A @dfn{version} is a node number and a property list.

A @dfn{history} is an array of versions, indexed by a contiguous range
of non-negative integers containing 0.

A @dfn{repository} consists of node table and a history.

@end quotation

@c Some definitions: we say that a node @var{n} is a @dfn{direct child} 
@c of a directory @var{d} iff @var{d} contains a directory entry whose 
@c node number is @var{n}. A node @var{n} is a @dfn{child} of a 
@c directory @var{d} iff @var{n} is a direct child of @var{d}, or if 
@c there exists some directory @var{e} which is a direct child of 
@c @var{d}, and @var{n} is a child of @var{e}. Given this definition of 
@c ``direct child'' and ``child,'' the obvious definitions of ``direct 
@c parent'' and ``parent'' hold.

@c In these restrictions, let @var{r} be any repository.  When we refer,
@c implicitly or explicitly, to a node table without further clarification,
@c we mean @var{r}'s node table.  Thus, if we refer to ``a valid node
@c number'' without specifying the node table in which it is valid, we mean
@c ``a valid node number in @var{r}'s node table''.  Similarly for
@c @var{r}'s history.

Now that we've explained the form of the data, we make some restrictions
on that form.

@b{Every version has a root directory.}  Every version's node number is
a valid node number, and the node it refers to is always a directory.
We call this the version's @dfn{root directory}.

@b{Version 0 always contains an empty root directory.}  This baseline
makes it easy to check out whole projects from the repository.

@b{Directories contain only valid links.}
Every directory entry's @var{node} is a valid node number.

@b{Directory entries can be identified by name.}
For any directory @var{d}, every directory entry in @var{d} has a
distinct name.

@b{There are no cycles of directories.}  No node is its own child.

@b{Directories can have more than one parent.}  The UNIX file system
does not allow more than one hard link to a directory, but Subversion
does allow the analogous situation.  Thus, the directories in a
Subversion repository form a directed acyclic graph (@dfn{DAG}), not a
tree.  However, it would be distracting and unhelpful to replace the
familiar term ``directory tree'' with the unfamiliar term ``directory
DAG'', so we still call it a ``directory tree'' here.

@b{There are no dead nodes.}  Every node is a child of some version's
root directory.

@c  </jimb> ----------------------



@subsection API

@subsubsection Data Types

The filesystem API routines require and return a number of data types
specific to Subversion's model and schema.

@dfn{bool} is a simple Boolean value, used to indicate success or
failure.

A @dfn{user} is a username (presumed to be previously authenticated by
the network layer) which is attempting to perform a filesystem action.

A @dfn{path} refers to an absolute path in the Subversion filesystem,
e.g. @code{/trunk/gdb/i386.c}

A @dfn{proplist} is a list of properties (key/value pairs).

A @dfn{propname} is particular property key.

A @dfn{propnamelist} is a list of all the keys in a proplist.

A @dfn{file} is a string of bytes that contains both a ``text stream''
and a ``property stream''.  The text stream contains the main contents
of the file, while the property stream decodes into a proplist.

A @dfn{directory entry} (@dfn{dirent}) points to a file or directory.

A @dfn{directory} (@dfn{dir}) is a list of directory entries.

A @dfn{filesystem object} (@dfn{fs_obj}) contains either a file or
directory. 

A @dfn{version} (abbreviated @dfn{ver}) refers to a global version
number in a repository's history.

A @dfn{diff} is a standard GNU diff, a textual context diff.

A @dfn{delta} is a structure that describes a difference between two
file trees.  For a detailed discussion, @xref{Protocol}.

A @dfn{skelta} is a identical to a delta, but smaller.  It mentions only
the files being changed, but does @emph{not} contain the actual diffs.
This data type is for fast network negotiation (see the @code{submit ()}
call below).

A @dfn{token} is a token used to represent a write transaction in
progress.


@subsubsection Basic Reading

There are two functions to retrieve information from the filesystem,
designed to be fast and convenient for any process using svn_fs.

@table @code
@item ver latest (user)
 returns the latest global version of a repository's tree
@item fs_obj read (user, version, path)
 if path is a file, return full contents in fs_obj;@*
 if path is a directory, return list of directory entries in fs_obj
@end table


@subsubsection Property Reading

There are a total of nine functions for retrieving information about the
properties of a file, dirent, or dir.

@table @code
@item char *get_node_prop(user, ver, path, propname)
  return the value of @emph{propname} for a file or directory
@item char *get_dirent_prop(user, ver, path, propname)
  return the value of @emph{propname} for a directory entry
@item char *get_ver_prop(user, ver, propname)
  return the value of @emph{propname} for a version (such as the log message)
@item proplist get_node_proplist(user, ver, path)
  return all properties of a file or directory
@item proplist get_dirent_proplist(user, ver, path)
  return all properties of a directory entry
@item proplist get_ver_proplist(user, ver)
  return all properties of a version
@item propnames get_node_propnames(user, ver, path)
  return all property keys for a file or directory
@item propnames get_node_propnames(user, ver, path)
  return all property keys for a file or directory
@item propnames get_dirent_propnames(user, ver, path)
  return all property keys for a directory entry
@item propnames get_ver_propnames(user, ver)
  return all property keys for a version
@end table


@subsubsection Difference Queries

@table @code
@item delta get_delta (user, versionX, pathX, versionY, pathY)
 return a delta object which converts subtree X into subtree Y
@item diff get_diff (user, versionX, pathX, versionY, pathY)
 return a diff between any two files in the repository
@end table


@subsubsection Basic Writing

If a program needs to modify a repository's filesystem in any way (even
if just modifying properties), it must do three things:

@enumerate
@item
  Build a delta object, representing a group of changes against some
  base revision of a tree.
@item
  Request permission from the server to write the delta as a transaction.
@item
  If permission is granted, apply the delta.
@end enumerate

@table @code
@item token submit (user, skelta)
  ask filesystem's lock manager for approval of skelta; returns either a
  transaction token or failure.  A skelta is used to speed this
  round-trip over the network.
@item write (user, delta, token)
  actually write the delta into the filesystem
@item abandon (user, token)
  tell lock manager that the delta will @emph{not} be written (despite
  previous approval)
@end table

A more detailed description of Subversion's write-locking mechanism is
explained in the next section.


@c -----------------
@subsection Locking

The Subversion Filesystem has a locking mechanism built into it.

The locking system was designed to have these features:

@enumerate
@item
    There can any number of concurrent filesystem @dfn{readers}, and a
    reader never has to wait for any other process.
@item
    There can any number of concurrent filesystem @dfn{writers},
    provided that their changes do not directly conflict.  When writers
    @emph{do} need to wait, the waiting is kept to an absolute minimum.
@end enumerate

@subsubsection Read Locks

Reading is easy; if a server process wants to execute a @code{read()}
call into the filesystem, it goes right through.  The design of the
versioning filesystem allows a reader to simply skip down the version
history, locate the correct "root" node, and then follow the particular
tree downwards to the file or directory it wishes to read.  Any number
of readers can follow this algorithm without interfering with another;
and because writers don't link to the version history until they're
finished writing everything, there's no way for a reader to accidentally
stumble upon an unfinished tree.

@subsubsection Write Locks

Each Subversion filesystem has a process called a @dfn{lock manager}.
The lock manager isn't always running; when a server process wishes to
execute a @code{write()} on the filesystem, it must first determine if a
lock manager is running.  If not, it starts one and speaks to it via
IPC.

@example

                  D              /
                   \            /
                    \          /
                     |        /
                     v       /
       +--------------------|--------------+
       |                    v              |
       |             Approved?             |
       |                |                  |
       |                |                  |
       |                v                  |
       |          Concurrency Pool         |
       |       +--------------------+      |
       |       |     D            D |      |
       |       |  D        D   D    |      |
       |       +--------------------+      |
       +-----------------------------------+

@end example

After the lock manager is up, the server process first sends it a
@code{submit()} call containing the skelta it would like to write.

The lock manager contains a pool of "approved changes".  This pool is a
set of skeltas which have been okayed for concurrent application to the
filesystem.  After receiving a new skelta from @code{submit()}, the lock
manager determines if it is safe to apply it at the same time as the
other ones in progress.@footnote{This rule is actually quite simple: a
set of skeltas may be concurrently written @emph{if and only if} the
order in which they are applied does not matter!}

If the lock manager decides that the requested skelta conflicts it
returns a failure to the server, and the server must wait and try again
with another @code{submit()} request.

If the lock manager decides that the requested skelta does not conflict,
it returns a transaction token to the server.  The server then uses this
token to execute a @code{write()} on the filesystem.

After the @code{write()} is completed, the skelta is removed from the
lock manager's concurrency pool, and the server closes its connection.

When the lock manager has no more open server connections, it dies.

@subsection Implementation

For the initial release of Subversion, we will implement the filesystem
library on UNIX.  The lock manager will communicate with other processes
via UNIX domain sockets.  Transactions will be handled in the ``back
end'' by the Berkeley Database library, which works on top of the UNIX
filesystem.@footnote{In the future, of course, contributors are free
modify the Subversion filesystem to operate with more powerful SQL
database.}  (For information, see @uref{http://www.sleepycat.com,
Sleepycat Software}.)



@c ----------------------------------------------------------------

@node Main Library
@section Main Library

A @dfn{repository} (@dfn{repos}) represents the name of a particular
repository. 

The Main Subversion Library (@dfn{svn_main}) provides a high-level
server API to the Subversion client.

In general, it provides an API that maps to CVS concepts whereever
possible.

@subsection Methods

The Subversion server makes itself useful to clients by providing
@dfn{methods}.  This term is used intentionally, because it lines up
well with our initial implementation of the network layer (done with
Apache and custom HTTP "methods", @xref{Protocol}.)

@table @code
@item available_methods ()
  return a list of methods that the server supports 
@end table

@subsection Basic Methods

These are the basic methods made available to clients.

@table @code
@item checkout (repository, version, path)
  grab a working copy of a section of the filesystem, rooted at
  @emph{path}
@item commit (repository, delta)
  check a delta object into the repository (the delta is generated by
  the client)
@end table

@subsection Simple Filesystem Reads

Here are some methods for doing quick, easy reads from the Subversion
filesystem;  they're essentially identical to the direct Filesystem
calls, except that they require the name of a specific repository as the
first argument.

@table @code
@item latest (repository)
 returns the latest global version of the repository
@item read (repository, version, path)
 if path is a file, return full text (which includes property stream);@*
 if path is a directory, return list of directory entries.
@item get_node_props (repository, version, path)
 return a list of all props of a file or directory entry
@item get_version_props (repository, version)
 return a list of all props of a version
@item read_node_prop (repository, version, path, propname)
 read a particular property of a file or directory entry
@item read_version_prop (repository, version, propname)
 read a particular property of a version (such as a log)
@end table


@subsection Plug-Ins

It's important that svn_main be extensible;  by allowing users to write
their own server-side libraries, the server's abilities can potentially
grow forever.

We define the term @dfn{plug-in} to refer to a library designed to be
loaded into svn_main's address space.  This term is used intentionally
(instead of "module") so as not to be confused with Apache modules.
Each plug-in can potentially implement a new set of server "methods"
(@xref{Methods}.)

When starting up, svn_main will read a configuration file @dfn{svn.conf}
(much like Apache's @emph{httpd.conf}) which, among other things, will
specify a list of available plug-ins, the new methods they provide, and
their actual locations on disk.  If and when a client requests a
particular method, svn_main then knows which plug-in to "auto-load" as
necessary.

Here are some ideas for future plug-ins:

@itemize @bullet
@item
  @strong{annotate} : provides annotation of individual files (i.e. who
  wrote which line in which version).  This is a basic command in CVS,
  but is not critical for Subversion's first release.  By implementing
  it later as a plug-in, the command becomes much more customizable.
@item
  @strong{grep} : the ability to search the Subversion filesystem
  quickly for text or properties
@item
  @strong{guile} : a plug-in which provides glue between svn_main and
  libguile.so, thereby giving the Subversion server an extensible
  scripting language.  (This could also be done with @strong{perl} or
  @strong{python}.)
@end itemize

