@node Server
@chapter Server

The term ``server'' is ambiguous, because it has at least two different
meanings: it can refer to a powerful computer which offers services to
users on a network, or it can refer to a CPU process designed to receive
network requests.

In Subversion, however, the @dfn{server} is just a set of libraries that
implement a set of @dfn{repositories} and make them available to other
programs.  No networking is required.

Of course, for the initial release of Subversion, the ``server'' process
will be Apache interacting with the Subversion server libraries, a the
``server'' computer will be any machine running this special Apache
process.  (@xref{Protocol}.)

There are two main libraries:  the @dfn{Subversion Filesystem} library,
and the @dfn{Main Subversion} library.

@menu
* Filesystem::                The Subversion Filesystem.
* Main Library::              The Subversion Server interface.
@end menu


@c ----------------------------------------------------------------

@node Filesystem
@section Filesystem

@subsection Overview

@itemize @bullet
@item
  @b{Requires:}
  @itemize
  @item
    a reasonable about of writable disk space
  @end itemize
@item
  @b{Provides:}
  @itemize
  @item
    a repository for storing files
  @item
    support for multiple concurrent accesses (via a lock manager)
  @item
    enforcement of user & group permissions (via ACLs)
  @end itemize
@end itemize

The @dfn{Subversion Filesystem} implements a hierarchical filesystem
which supports atomic changes to arbitrary groups of files, and records
the complete history of the tree -- including directory and file
contents.

Because Subversion avoids using the UNIX filesystem directly, it can
store @dfn{properties} (or ``meta-data'') with each file, directory,
directory entry, and version number.  For example, some useful
properties might be @{author, creation date, modification date, Access
Control List (ACL), file type (text, binary), file encoding, ...@}.
Similarly, a version in a repository's history can store the log message
as a property.

@subsection Schema

To begin, please be sure that you're already casually familiar with
Subversion's ideas of files, directories, and version histories.  If
not, @xref{Model}.  For completeness, we can now offer a precise,
technical description of these terms.

@c This is taken from jimb's very first Subversion spec!
@c Is there some standardized notation for describing schemas like this?
@c <jimb>
 
@quotation

A @dfn{text string} is a string of Unicode characters which is
canonically decomposed and ordered, according to the rules described in
the Unicode standard.

A @dfn{string of bytes} is what you'd expect.

A @dfn{property list} is an unordered list of properties.  A
@dfn{property} is a pair @code{(@var{name}, @var{value})}, where
@var{name} is a text string, and @var{value} is a string of bytes.
No two properties in a property list have the same name.

A @dfn{file} is a property list and a string of bytes.

A @dfn{node} is either a file or a directory.  (We define a directory
below.)  Nodes are distinguished unions --- you can always tell whether
a node is a file or a directory.

A @dfn{node table} is an array mapping some set of positive integers,
called @dfn{node numbers}, onto @dfn{nodes}.  If a node table maps some
number @var{i} to some node @var{n}, then @var{i} is a @dfn{valid node
number} in that table, and @dfn{node @var{i}} is @var{n}.  Otherwise,
@var{i} is an @dfn{invalid node number} in that table.

A @dfn{directory entry} is a triple @code{(@var{name}, @var{props},
@var{node})}, where @var{name} is a text string, @var{props} is a
property list, and @var{node} is a node number.

A @dfn{directory} is an unordered list of directory entries, and a
property list.

A @dfn{version} is a node number and a property list.

A @dfn{history} is an array of versions, indexed by a contiguous range
of non-negative integers containing 0.

A @dfn{repository} consists of node table and a history.

@end quotation

@c Some definitions: we say that a node @var{n} is a @dfn{direct child} 
@c of a directory @var{d} iff @var{d} contains a directory entry whose 
@c node number is @var{n}. A node @var{n} is a @dfn{child} of a 
@c directory @var{d} iff @var{n} is a direct child of @var{d}, or if 
@c there exists some directory @var{e} which is a direct child of 
@c @var{d}, and @var{n} is a child of @var{e}. Given this definition of 
@c ``direct child'' and ``child,'' the obvious definitions of ``direct 
@c parent'' and ``parent'' hold.

@c In these restrictions, let @var{r} be any repository.  When we refer,
@c implicitly or explicitly, to a node table without further clarification,
@c we mean @var{r}'s node table.  Thus, if we refer to ``a valid node
@c number'' without specifying the node table in which it is valid, we mean
@c ``a valid node number in @var{r}'s node table''.  Similarly for
@c @var{r}'s history.

Now that we've explained the form of the data, we make some restrictions
on that form.

@b{Every version has a root directory.}  Every version's node number is
a valid node number, and the node it refers to is always a directory.
We call this the version's @dfn{root directory}.

@b{Version 0 always contains an empty root directory.}  This baseline
makes it easy to check out whole projects from the repository.

@b{Directories contain only valid links.}
Every directory entry's @var{node} is a valid node number.

@b{Directory entries can be identified by name.}
For any directory @var{d}, every directory entry in @var{d} has a
distinct name.

@b{There are no cycles of directories.}  No node is its own child.

@b{Directories can have more than one parent.}  The UNIX file system
does not allow more than one hard link to a directory, but Subversion
does allow the analogous situation.  Thus, the directories in a
Subversion repository form a directed acyclic graph (@dfn{DAG}), not a
tree.  However, it would be distracting and unhelpful to replace the
familiar term ``directory tree'' with the unfamiliar term ``directory
DAG'', so we still call it a ``directory tree'' here.

@b{There are no dead nodes.}  Every node is a child of some version's
root directory.

@c  </jimb> ----------------------



@subsection API

@c  @subsubsection Data Types

@c  The filesystem API routines require and return a number of data types
@c  specific to Subversion's model and schema.

@c  @dfn{bool} is a simple Boolean value, used to indicate success or
@c  failure.

@c  A @dfn{user} is a username (presumed to be previously authenticated by
@c  the network layer) which is attempting to perform a filesystem action.

@c  A @dfn{path} refers to an absolute path in the Subversion filesystem,
@c  e.g. @code{/trunk/gdb/i386.c}

@c  A @dfn{proplist} is a list of properties (key/value pairs).

@c  A @dfn{propname} is a particular property key.

@c  A @dfn{propnamelist} is a list of all the keys in a proplist.

@c  A @dfn{file} is a string of bytes that contains both a ``text stream''
@c  and a ``property stream''.  The text stream contains the main contents
@c  of the file, while the property stream decodes into a proplist.

@c  A @dfn{directory entry} (@dfn{dirent}) points to a file or directory.

@c  A @dfn{directory} (@dfn{dir}) is a list of directory entries.

@c  A @dfn{filesystem object} (@dfn{fs_obj}) contains either a file or
@c  a directory. 

@c  A @dfn{version} (abbreviated @dfn{ver}) refers to a global version
@c  number in a repository's history.

@c  A @dfn{diff} is a standard GNU diff, a textual context diff.

@c  A @dfn{delta} is a structure that describes a difference between two
@c  file trees.  For a detailed discussion, @xref{Protocol}.

@c  A @dfn{skelta} A @dfn{skelta} is the skeleton of a delta: while it does
@c  indicate which files are changed, it does not describe the specific
@c  changes to the files' text.  This datatype allows the filesystem to
@c  detect conflicts between transactions before the client has computed or
@c  transmitted the (possibly large) textual deltas.

@c  A @dfn{token} is a token used to represent a write transaction in
@c  progress.

@c ---------------------

This is the same API that the client calls, prefixed with @code{fs_}.
For a full explanation, see @xref{The repository access library}.

@table @code
@item ver_t fs_latest (repos, user)
@item prop_t fs_get_ver_prop (repos, user, ver, propname)
@item proplist_t fs_get_ver_proplist (repos, user, ver)
@item proplist_t fs_get_ver_propnames (repos, user, ver)
@item node_t fs_read (repos, user, ver, path)
@item str_t fs_get_node_prop (repos, user, ver, path, propname)
@item str_t fs_get_dirent_prop (repos, user, ver, path, propname)
@item proplist_t fs_get_node_proplist (repos, ver, path)
@item proplist_t fs_get_dirent_proplist (repos, user, ver, path)
@item proplist_t fs_get_node_propnames (repos, user, ver, path)
@item proplist_t fs_get_dirent_propnames (repos, user, ver, path)
@item skelta_t fs_get_status (repos, user, skelta)
@item delta_t fs_get_update (repos, user, skelta)
@item delta_t fs_get_delta (repos, user, ver1, path1, ver2, path2)
@item diff_t fs_get_diff (repos, user, ver1, path1, ver2, path2)
@item token_t fs_submit (repos, user, skelta)
@item ver_t fs_write (repos, user, delta, token)
@item bool_t fs_abandon (repos, user, token)
@end table


@c -----------------
@subsection Locking

The Subversion Filesystem has a locking mechanism.

The locking mechanism deals with @dfn{readers} and @dfn{writers}.
Readers never have to wait for writers;  writer only have to wait for
other writers whose changes conflict with theirs.

@subsubsection Read Locks

Reading is easy; if a server process wants to execute a @code{read()}
call into the filesystem, it goes right through.  The design of the
versioning filesystem allows a reader to simply skip down the version
history, locate the correct "root" node, and then follow the particular
tree downwards to the file or directory it wishes to read.  Any number
of readers can follow this algorithm without interfering with another;
and because writers don't link to the version history until they're
finished writing everything, there's no way for a reader to accidentally
stumble upon an unfinished tree.

@subsubsection Write Locks

Each Subversion filesystem has a process called a @dfn{lock manager}.
The lock manager isn't always running; when a server process wishes to
execute a @code{write()} on the filesystem, it must first determine if a
lock manager is running.  If not, it creates one.

@example

                  D              /
                   \            /
                    \          /
                     |        /
                     v       /
       +--------------------|--------------+
       |                    v              |
       |             Approved?             |
       |                |                  |
       |                |                  |
       |                v                  |
       |          Concurrency Pool         |
       |       +--------------------+      |
       |       |     D            D |      |
       |       |  D        D   D    |      |
       |       +--------------------+      |
       +-----------------------------------+

@end example

After the lock manager is up, the server process first sends it a
@code{submit()} call containing the skelta it would like to write.

The lock manager contains a pool of "approved changes".  This pool is a
set of skeltas which have been okayed for concurrent application to the
filesystem.  After receiving a new skelta from @code{submit()}, the lock
manager determines if it is safe to apply it at the same time as the
other ones in progress.@footnote{This rule is actually quite simple: a
set of skeltas may be concurrently written @emph{if and only if} the
order in which they are applied does not matter!}

If the lock manager decides that the requested skelta conflicts it
returns a failure to the server, and the server must wait and try again
with another @code{submit()} request.

If the lock manager decides that the requested skelta does not conflict,
it returns a transaction token to the server.  The server then uses this
token to execute a @code{write()} on the filesystem.

After the @code{write()} is completed, the skelta is removed from the
lock manager's concurrency pool, and the server closes its connection.

When the lock manager has no more open server connections, it dies.

@subsection Implementation

For the initial release of Subversion,

@itemize @bullet
@item 
  The filesystem will be implemented as a library on UNIX.
@item
  The lock manager will communicate with other processes via UNIX domain 
  sockets.  
@item
  The filesystem's data will probably be stored in a collection of .db
  files, using the Berkeley Database library.@footnote{In the future, of
  course, contributors are free modify the Subversion filesystem to
  operate with more powerful SQL database.}  (For more information, see
  @uref{http://www.sleepycat.com, Sleepycat Software}.)
@end itemize


@c ----------------------------------------------------------------

@node Main Library
@section Main Library


@subsection Overview

@itemize @bullet
@item
  @b{Requires:}
  @itemize
  @item
    the Subversion Filesystem interface
  @end itemize
@item
  @b{Provides:}
  @itemize
  @item
    the ability to interact with any repository on a system
  @item
    the ability to enforce server-side ``policies'' (via a config file)
  @item
    the ability to load server-side ``plug-ins'' (via a config file)
  @end itemize
@end itemize


@subsection Multiplexing

The Main Subversion Library (@dfn{svn_main}), in its simplest sense,
acts a basic multiplexer for the repository API calls coming from the
Subversion client.  (@xref{The repository access library}.)

Specifically, note that all of the client's calls into the repository
begin with a @code{repos} argument.  The Main Subversion Library
provides the exact same API as the client repository library, prefixed
by @code{main_}:

@table @code
@item ver_t main_latest (repos, user)
@item prop_t main_get_ver_prop (repos, user, ver, propname)
@item proplist_t main_get_ver_proplist (repos, user, ver)
@item proplist_t main_get_ver_propnames (repos, user, ver)
@item node_t main_read (repos, user, ver, path)
@item str_t main_get_node_prop (repos, user, ver, path, propname)
@item str_t main_get_dirent_prop (repos, user, ver, path, propname)
@item proplist_t main_get_node_proplist (repos, ver, path)
@item proplist_t main_get_dirent_proplist (repos, user, ver, path)
@item proplist_t main_get_node_propnames (repos, user, ver, path)
@item proplist_t main_get_dirent_propnames (repos, user, ver, path)
@item skelta_t main_get_status (repos, user, skelta)
@item delta_t main_get_update (repos, user, skelta)
@item delta_t main_get_delta (repos, user, ver1, path1, ver2, path2)
@item diff_t main_get_diff (repos, user, ver1, path1, ver2, path2)
@item token_t main_submit (repos, user, skelta)
@item ver_t main_write (repos, user, delta, token)
@item bool_t main_abandon (repos, user, token)
@end table

These routines are ``wrappers'' that make the real filesystem calls into
a particular repository.

@subsection Policy Enforcement

When starting up, svn_main will read a configuration file @file{svn.conf}
(much like Apache's @file{httpd.conf}) which, among other things, will
specify a list of server policies to implement.

Because filesystem calls are ``wrappered'' by svn_main, it has the
opportunity to intercept and interpret them according to policy.  

For example, an administrator may wish to take a repository ``off-line''
for backup purposes.  She can specify this in the @file{svn.conf} file,
and any filesystem calls to the particular repository are then
intercepted and (kindly) rejected by svn_main.


@subsection Plug-Ins

It's important that svn_main be extensible;  by allowing users to write
their own server-side libraries, the server's abilities can potentially
grow forever.

We define the term @dfn{plug-in} to refer to a library designed to be
loaded into svn_main's address space.  This term is used intentionally
(instead of "module") so as not to be confused with either Apache
modules or ``CVS-like'' modules.  Each plug-in potentially implements a
new set of server "methods" availabe to the client.

The @file{svn.conf} file specifies a list of available plug-ins, the new
methods they provide, and the real shared-object pathnames on disk.
When a client requests a particular method, svn_main then knows which
plug-in to "auto-load" as necessary.

Here are some ideas for future plug-ins:

@itemize @bullet
@item
  @strong{annotate} : provides annotation of individual files (i.e. who
wrote which line in which version).  This is a basic command in CVS, but
is not critical for Subversion's first release.  By implementing it
later as a plug-in, the command becomes more customizable.
@item
  @strong{grep} : the ability to search the Subversion filesystem
quickly for text or properties
@item
  @strong{guile} : a plug-in which provides glue between svn_main and
libguile.so, thereby giving the Subversion server-libraries an
extensible scripting language.  (This could also be done with
@strong{perl} or @strong{python}.)
@end itemize

