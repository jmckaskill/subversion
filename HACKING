If you are contributing code to the Subversion project, please read
this first.



Building from a working copy
============================

Unlike a packaged distribution, the Subversion working tree does not
contain a `configure' script nor any other of the generated files
normally used in configuration and building.  You have to regenerate
them inside your working copy first, then configure, and then build.
So, first run

   ./autogen.sh

which invokes `autoheader', `automake', `aclocal', and `autoconf' (so
make sure you have those tools installed).  Afterwards, do

   ./configure
   make

to build Subversion.


Building on Win32
=================

There is some support for building Subversion on Win32 platforms. The
project files included in the source tree are from Microsoft Visual
C++ 6.x; earlier versions of the compiler are not supported at this
time.

If you want to build the server components, you'll also need a copy of
Berkeley DB, version 3.1.14 or newer. The sources are available at
http://www.sleepycat.com, but you can download a binary distribution of
version 3.1.17 libraries and tools from

    http://www.xbc.nu/svn/db3-win32.zip

Unpack the distribution, then set the environment variable
SVN_DB3_WIN32 to the full path of the db-win32 directory (use the
System control panel on WinNT/Win2k). MSVC will look for the include
files in $(SVN_DB3_WIN32)\include, and the libraries in
$(SVN_DB3_WIN32)\lib.

The workspace `subversion.dsw' at the top of the source tree includes
all the necessary projects. Right now, only static libraries are
built. The "__build__" project (active by default) builds all the
libraries and programs.. The "__check__" project builds the test
drivers.

You will have to edit the file config.hw to set the correct paths for
diff and patch.


Coding Style
============

To understand how things work, read doc/svn-design.{texi,info,ps,pdf},
and read the header files, which tend to have thoroughly-commented
data structures.

We're using ANSI C, and following the GNU coding standards.  Emacs
users can just load svn-dev.el to get the right indentation behavior
(most source files here will load it automatically, if
`enable-local-eval' is set appropriately).

Read http://www.gnu.org/prep/standards.html for a full description of
the GNU coding standards; but here is a short example demonstrating
the most important formatting guidelines:

   char *                                     /* func type on own line */
   argblarg (char *arg1, int arg2)            /* func name on own line */
   {                                          /* first brace on own line */
     if ((some_very_long_condition && arg2)   /* indent 2 cols */
         || remaining_condition)              /* new line before operator */
       {                                      /* brace on own line, indent 2 */
         arg1 = some_func (arg1, arg2);       /* space before opening paren */
       }                                      /* close brace on own line */
     else
       {
         do                                   /* format do-while like this */
           {
             arg1 = another_func (arg1);
           }
           while (*arg1);
       }
   }

In general, be generous with parentheses even when you're sure about
the operator precedence, and be willing to add spaces and newlines to
avoid "code crunch".  Don't worry too much about vertical density;
it's more important to make code readable than to fit that extra line
on the screen.



Using Page Breaks
=================

We're using page breaks (the Ctrl-L character, ASCII 12) for section
boundaries in both code and plaintext prose files.  This file is a
good example of how it's done: each section starts with a page break,
and the immediately after the page break comes the title of the
section.

This helps out people who use the Emacs page commands, such as
`pages-directory' and `narrow-to-page'.  Such people are not as scarce
as you might think, and if you'd like to become one of them, then type
C-x C-p C-h in Emacs sometime.



Writing Log Entries
===================

Certain guidelines should be adhered to when writing log messages:

Make a log entry for every change.  The value of the log becomes much
less if developers cannot rely on its completeness.  Even if you've
only changed comments, write an entry that says, "Doc fix."  The only
changes you needn't log are small changes that have no effect on the
source, like formatting tweaks.

Log entries should be full sentences, not sentence fragments.
Fragments are more often ambiguous, and it takes only a few more
seconds to write out what you mean.  Fragments like `New file' or `New
function' are acceptable, because they are standard idioms, and all
further details should appear in the source code.

The log entry should name every affected function, variable, macro,
makefile target, grammar rule, etc, including the names of symbols
that are being removed in this commit.  This helps people do automated
searches through the logs later.  Don't hide names in wildcards,
because the globbed portion may be what someone searches for later.
For example, this is bad:

   (twirling_baton_*): removed these obsolete structures.
   (handle_parser_warning): pass data directly to callees, instead of
   storing in twirling_baton_*.

Later on, when someone is trying to figure out what happened to
`twirling_baton_fast', they may not find it if they just search for
"fast".  A better entry would be:

   (twirling_baton_fast, twirling_baton_slow): removed these obsolete
   structures. 
   (handle_parser_warning): pass data directly to callees, instead of
   storing in twirling_baton_*.

The wildcard is okay in the description for `handle_parser_warning',
but only because the two structures were mentioned by full name
elsewhere in the log entry.

There are some common-sense exceptions to the need to name everything
that was changed:

   * If you have made a change which requires trivial changes
     throughout the rest of the program (e.g., renaming a variable),
     you needn't name all the functions affected.

   * If you have rewritten a file completely, the reader understands
     that everything in it has changed, so your log entry may simply
     give the file name, and say "Rewritten".

In general, there is a tension between making entries easy to find by
searching for identifiers, and wasting time or producing unreadable
entries by being exhaustive.  Use your best judgement --- and be
considerate of your fellow developers.

For large changes or change groups, group the log entry into
paragraphs separated by blank lines.  Each paragraph should be a set
of changes that accomplishes a single goal.  Independent changes
should be in separate paragraphs.  It helps to start out each group
with a sentence or two summarizing the change.

One should never need the log entries to understand the current code.
If you find yourself writing a significant explanation in the log, you
should consider carefully whether your text doesn't actually belong in
a comment, alongside the code it explains.  Here's an example of doing
it right:

       (consume_count): If `count' is unreasonable, return 0 and don't
       advance input pointer.  

And then, in `consume_count' in `cplus-dem.c':

   while (isdigit ((unsigned char)**type))
     {
       count *= 10;
       count += **type - '0';
       /* A sanity check.  Otherwise a symbol like
         `_Utf390_1__1_9223372036854775807__9223372036854775'
         can cause this function to return a negative value.
         In this case we just consume until the end of the string.  */
      if (count > strlen (*type))
        {
          *type = save;
          return 0;
        }

This is why a new function, for example, needs only a log entry saying
"New Function" --- all the details should be in the source.

These guidelines are paraphrased from Jim Blandy's excellent essay
"Maintaining the ChangeLog".  It is in `doc/WritingChangeLogs.txt'.


Generating ChangeLogs
---------------------

Subversion does not keep ChangeLog files, because they're redundant
with the CVS log entries.  But ChangeLog is an easier format to
browse, so it's often handy to generate a ChangeLog from the cvs log
data.  You can do so with the script `cvs2cl.pl', from:

   http://www.red-bean.com/cvs2cl/

If you've never used it before, try invoking it like this:

   cd subversion/subversion
   cvs2cl.pl --fsf -r

That will produce a ChangeLog in the current directory (the "-r" flag
says include revision numbers, and "--fsf" means do auto-wrapping in a
way friendly to log entries written in GNU ChangeLog style).

Run "cvs2cl.pl --help" for more information.



Other Conventions:
==================

In addition to the GNU standards, Subversion uses these conventions:

   * Use only spaces for indenting code, never tabs.  Tab display
     width is not standardized enough, and anyway it's easier to
     manually adjust indentation that uses spaces.

   * Stay within 80 columns, the width of a minimal standard display
     window.

   * Signify internal variables by two underscores after the prefix.
     That is, when a symbol must (for technical reasons) reside in the
     global namespace despite not being part of a published interface,
     then use two underscores following the module prefix.  For
     example:

        svn_fs_get_rev_prop ()       /* Part of published API. */
        svn_fs__parse_props ()       /* For internal use only. */

   * Put this comment at the bottom of new source files to make Emacs
     automatically load svn-dev.el:

        /* 
         * local variables:
         * eval: (load-file "../svn-dev.el")
         * end:
         */

     (This assumes the C file is located in a subdirectory of
     subversion/subversion/, which most are.)




Automated Tests:
================

For a description of how to use and add tests to Subversion's
automated test framework, please read subversion/tests-common/README.


APR Status Codes:
=================

Always check for APR status codes (except APR_SUCCESS) with the
APR_STATUS_IS_...() macros, not by direct comparison. This is
required for portability to non-Unix platforms.
