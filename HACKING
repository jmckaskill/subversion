If you are contributing code to the Subversion project, please read
this first.


Building from a working copy
============================

Unlike a packaged distribution, the Subversion working tree does not
contain a `configure' script nor any other of the generated files
normally used in configuration and building.  You have to regenerate
them inside your working copy first, then configure, and then build.
So, first run

   ./autogen.sh

which invokes `autoheader', `automake', `aclocal', and `autoconf' (so
make sure you have those tools installed).  Afterwards, do

   ./configure
   make

to build Subversion.


Coding
================================

To understand how things work, read doc/svn-design.{texi,info,ps,pdf},
and read the header files, which tend to have thoroughly-commented
data structures.

We're using ANSI C, and following the GNU coding standards.  Emacs
users can just load svn-dev.el to get the right indentation behavior
(most source files here will load it automatically, if
`enable-local-eval' is set appropriately).

Read http://www.gnu.org/prep/standards.html for a full description of
the GNU coding standards; but here is a short example demonstrating
the most important formatting guidelines:

   char *                                     /* func type on own line */
   argblarg (char *arg1, int arg2)            /* func name on own line */
   {                                          /* first brace on own line */
     if ((some_very_long_condition && arg2)   /* indent 2 cols */
         || remaining_condition)              /* new line before operator */
       {                                      /* brace on own line, indent 2 */
         arg1 = some_func (arg1, arg2);       /* space before opening paren */
       }                                      /* close brace on own line */
     else
       {
         do                                   /* format do-while like this */
           {
             arg1 = another_func (arg1);
           }
           while (*arg1);
       }
   }

In general, be generous with parentheses even when you're sure about
the operator precedence, and be willing to add spaces and newlines to
avoid "code crunch".  Don't worry too much about vertical density;
it's more important to make code readable than to fit that extra line
on the screen.


Writing Log Entries
===================

Certain guidelines should be adhered to when writing log messages:

Make a log entry for every change.  The value of the log becomes much
less if developers cannot rely on its completeness.  Even if you've
only changed comments, write an entry that says, "Doc fix."  The only
changes you needn't log are small changes that have no effect on the
source, like formatting tweaks.

Log entries should be full sentences, not sentence fragments.
Fragments are more often ambiguous, and it takes only a few more
seconds to write out what you mean.  Fragments like `New file' or `New
function' are acceptable, because they are standard idioms, and all
further details should appear in the source code.

The log entry should name every affected function, variable, macro,
makefile target, grammar rule, etc, including the names of symbols
that are being removed in this commit.  This helps people do automated
searches through the logs later.  Don't hide names in wildcards,
because the globbed portion may be what someone searches for later.
For example, this is bad:

   (twirling_baton_*): removed these obsolete structures.
   (handle_parser_warning): pass data directly to callees, instead of
   storing in twirling_baton_*.

Later on, when someone is trying to figure out what happened to
`twirling_baton_fast', they may not find it if they just search for
"fast".  A better entry would be:

   (twirling_baton_fast, twirling_baton_slow): removed these obsolete
   structures. 
   (handle_parser_warning): pass data directly to callees, instead of
   storing in twirling_baton_*.

The wildcard is okay in the description for `handle_parser_warning',
but only because the two structures were mentioned by full name
elsewhere in the log entry.

There are some common-sense exceptions to the need to name everything
that was changed:

   * If you have made a change which requires trivial changes
     throughout the rest of the program (e.g., renaming a variable),
     you needn't name all the functions affected.

   * If you have rewritten a file completely, the reader understands
     that everything in it has changed, so your log entry may simply
     give the file name, and say "Rewritten".

In general, there is a tension between making entries easy to find by
searching for identifiers, and wasting time or producing unreadable
entries by being exhaustive.  Use your best judgement --- and be
considerate of your fellow developers.

For large changes or change groups, group the log entry into
paragraphs separated by blank lines.  Each paragraph should be a set
of changes that accomplishes a single goal.  Independent changes
should be in separate paragraphs.  It helps to start out each group
with a sentence or two summarizing the change.

One should never need the log entries to understand the current code.
If you find yourself writing a significant explanation in the log, you
should consider carefully whether your text doesn't actually belong in
a comment, alongside the code it explains.  Here's an example of doing
it right:

       (consume_count): If `count' is unreasonable, return 0 and don't
       advance input pointer.  

And then, in `consume_count' in `cplus-dem.c':

   while (isdigit ((unsigned char)**type))
     {
       count *= 10;
       count += **type - '0';
       /* A sanity check.  Otherwise a symbol like
         `_Utf390_1__1_9223372036854775807__9223372036854775'
         can cause this function to return a negative value.
         In this case we just consume until the end of the string.  */
      if (count > strlen (*type))
        {
          *type = save;
          return 0;
        }

This is why a new function, for example, needs only a log entry saying
"New Function" --- all the details should be in the source.

These guidelines were excerpted from Jim Blandy's excellent essay
"Maintaining the ChangeLog".  It is in `doc/WritingChangeLogs.txt'.

Generating ChangeLogs
---------------------

Subversion does not keep ChangeLog files, because they're redundant
with the CVS log entries.  But ChangeLog is an easier format to
browse, so it's often handy to generate a ChangeLog from the cvs log
data.  You can do so with the script `cvs2cl.pl', from:

   http://www.red-bean.com/kfogel/cvs2cl.shtml

If you've never used it before, try invoking it like this:

   cd subversion/subversion
   cvs2cl.pl -S -r      /* produces `ChangeLog' in the current directory */
   more ChangeLog

That will produce a readable general-purpose ChangeLog; the "-r" flag
means to include revision numbers.  Run "cvs2cl.pl --help" to see more
about how to use it.


Other Conventions:
==================

In addition to the GNU standards, Subversion uses these conventions:

   * Use only spaces for indenting code, never tabs.  Tab display
     width is not standardized enough, and anyway it's easier to
     manually adjust indentation that uses spaces.

   * Stay within 80 columns, the width of a minimal standard display
     window.

   * Signify internal variables by two underscores after the prefix.
     That is, when a symbol must (for technical reasons) reside in the
     global namespace despite not being part of a published interface,
     then use two underscores following the module prefix.  For
     example:

        svn_fs_get_ver_prop ()       /* Part of published API. */
        svn_fs__parse_props ()       /* For internal use only. */

   * Put this comment at the bottom of new source files to make Emacs
     automatically load svn-dev.el:

        /* 
         * local variables:
         * eval: (load-file "svn-dev.el")
         * end:
         */

     (This assumes the C file is located in subversion/subversion/,
     where svn-dev.el is.)
