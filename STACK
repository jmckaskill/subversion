								-*-text-*-

If you're looking for a task to take on, please see the TASKS file.

This file merely lists immediate, short-term (next few days) stuff on
people's stacks.  It may make reference to phone conversations and
private emails, so a given item might not make much sense unless one
is familiar with its out-of-band context.  We keep this file under
version control mainly for convenience -- feel free to add your own
short-term tasks to it, if that's helpful.

------------------------------------------------------------------------

General Problems (someone grab these):

   - updates (right now) don't bump the revision of every entry as
     they should;  instead we're only bumping the changed entries.

   - unable to update specific targets right now;  we need to
     distinguish between specific targets and general full recursive
     updates.

   - don't use stdio's BUFSIZ (portability?). define an SVN specific
     constant and use it throughout.

   - refactor client/main.c's cmdline handling and place it into
     libsvn_subr. use the new functions within svnadmin/main.c.

   - switch the copyright notices from "... 2000 ..." to "2000-2001".
     note: tools/check-license.py is handy for this

Ben & Karl todo:

   - clean up the interface in libsvn_client.  make it more canonical.
     (This may happen automatically as the Win32 and Gnome clients are
      developed after-hours!)

Ben todo:

   - filesystem work -- oh gawd, the humanity!

   - make a new mini-crawler (lots of shared code with adm_crawler.c)
     which reports "version differences" to an editor.  this will be
     used to communicate the working copy's state to the repository
     *before* receiving an update.
         |
         +-- Specifically: we need to define a new vtable with just
             replace_dir() and replace_file().  This vtable is part of
             the RA interface, and designed for nothing other than
             reporting WC revisions.  (We will NOT use an editor for
             reporting WC state!)


Mike Pilato wc todo:

   - Big Ol' Change #2 below.
   - From Bill Tutt:
     This is just more an FYI, as it isn't preventing me from doing
     any work atm, but the paths returned from svn_wc_statuses are
     looking like: "C:\SVN\subversion\subversion\client\tests\t1\/iota"
     Seemingly fixed by Mike's changes to apr_subr/path.c, but Bill
     sez he too will verify this at some point in the near future.
         

Karl wc todo:

   - Propagate changes down into libsvn_client.  Currently, the client
     usually takes a `targets' list and iterates over it, invoking
     some libsvn_client routine each time.  There are cases where the
     libsvn_client routine should get the target list directly and do
     the iteration internally, or even pass the list on down into
     libsvn_wc.
   - make an is_textfile test, so at least we can create .alt files
     instead of .rej for those that `patch' can't handle.
   - write the log/lock recovery function.
   - with Ben, review locking protocol in wc adm directories for sanity.
   - check apr_open calls, do they assume failure implies null handle?
   - fix working copy identification/allergy code
   - make sure type-changing replacements work right
   - do the generic entry/adm-path grabber abstraction, as talked
     about with Ben, change everyone around to use it (chore, whoa).

Ben and Karl (longer term):

   - xml dtd, for both xml deltas and wc formats

   - for milestone 3: TREE DELTAS.  Quake before them.  This problem
     has many aspects to it, *including* {the need for commands to
     take lists of paths, canconicalizing these lists, testing paths
     if they exist and/or what their entries say about them, etc.}
     Just a tip of the iceberg.

Greg:

   - mod_dav_svn:
      - finish repository hooks (waiting on FS a bit)
        need: MKCOL, DELETE, GET, PUT
	defer copy/move

      - liveprop hooks:
	core: getcontentlength, creationdate, getetag,
	      getlastmodified, resourcetype
	deltav: target, activity-collection-set, version-name

      - vsn hooks: ???  REPORT and MKACTIVITY first
        REPORT: need the SVN:status-report
	need: MERGE (activity)
	validate proper support for VERSION-CONTROL. this would be the 
	  missing piece for DeltaV "Core" support.

      - MKACTIVITY should begin a txn
      - version resource URL prep should look up the node
      - CHECKOUT of a VR URL should verify the node ID of the
        REPOS_PATH in the latest revision matches the node ID in the
	VR URL (if not, they are checking out an old copy)

   - mod_dav: no apparent changes until vsn comes in
      - need: MERGE
      - verify Vasta's work against our needs: REPORT, LABEL
      - probably need BASELINE-CONTROL

   - libsvn_ra_dav:
      - update editor
      - commit editor

   - APR: move apr_copy_file() from SVN. and apr_append_file, etc.

   - security checks (e.g. system() usage in wc/get_editor)

Filesystem:

  (Branko and Karl have made this list here to keep straight the order in
  which they're doing stuff in the fs.)

  We've got svn_fs_begin_txn(), svn_fs_close_txn(), svn_fs_open_txn(),
  svn_fs_txn_name(), svn_fs_list_transactions(). Next, let's do:

    1.  svn_fs_abort_txn()

  These don't do anything useful by themselves, of course, but they're
  prerequisites for:

    2. Begin, open a txn
    3. Make a change to some node in that txn
    4. Get txn's name
    5. close the txn
    6. re-open the same txn, by name
    7. check that our change is still there!

  I'm not sure yet what specific functions are required to implement
  steps 2-7; we'll first establish the concrete list of functions,
  then implement them.

  (O.K., I'll take a guess, at the DAG layer:

      -4. svn_fs__dag_clone_root
      -3. svn_fs__dag_make_file
      -2. svn_fs__dag_txn_node
      -1. svn_fs__dag_close
       0. svn_fs__dag_delete  (that's for svn_fs_abort_txn)

   Hmm ... Oh, yes:

      -5. Decide what exactly a dag_node_t is.

   and of course whatever's missing below.  -xbc)

  Once that's working, we can do the Big One: svn_fs_commit_txn(). :-)

  -Karl

Changes to svn_delta_edit_fns_t:

   These are the summary emails Ben sent to the dev list (lightly
   edited), concerning changes proposed and accepted at the meetings
   in Chicago on January 14-16.  A few of these are still being
   discussed on the list; see the "STATUS" lines for more.

   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

   Change #2:  Modify prototypes of replace_*() and add_*()
   STATUS: discussing on list
   The Way It Works Now:
      These editor functions now take arguments "ancestor_path" and
      "ancestor_revision".
   
   Proposed Change:
      Replace these two arguments with "base_revision" and
      "target_revision" instead within replace_*(), and nothing but a
      "target_revision" in add_*().
   
   Rationale:
      We agreed in a previous discussion (on the dev list) that the
      "ancestor_path" argument is meaningless in these routines;  this
      path can be inferred via the sequence of parent dir_batons.
   
      This leaves only a single "revision" argument left.  The problem is
      that the meaning of this argument is unclear.
   
      Why we need a "target" revision:
          When updating the WC, the RA layer needs to specify the new
          version of the object being created.  There's currently no way
          to do this.  Both replace_*() and add_*() routines need this
          ability. 
   
      Why we also need a "base" revision for replace_*():
          When updating the WC, the RA layer needs to specify *which*
          object it is trying to replace.  This is a problem also
          discussed on the dev list;  it's possible that the revision of
          a working copy object might change in the *middle* of a larger
          update, creating the risk of the RA layer applying an incorrect
          patch.  There are many ways to solve this via WC locking or
          bookkeeping, but the simplest answer is to have the RA layer
          declare what it's trying to replace and allow the update-editor
          to bail if there's a descrepancy.
   
          In the commit use-case, the WC declares the "base" revision on
          which it is sending local changes.

   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #3:  New "WC" properties.
   STATUS: Will be done by Ben, Mike, or self, unless someone volunteers.
   The Way It Works Now:
      Properties attached to objects in the repository also appear in the
      WC.  Similarly, properties added to WC objects get committed to the
      repository. 
   
   Proposed Change:
      Create a new class of properties that *only* exist in the WC.
      These properties are stored for the benefit of RA layers.  We add
      new editor functions:
   
            set_wc_dir_props (dir_baton, name, val)
            set_wc_file_props (file_baton, name, val)
   
      If driving an editor:  if WC props exist for the object you're
      describing, you *must* send them via these functions.
   
      If implementing an editor: if you receive WC props, you *must*
      store them somewhere.
   
   Rationale:
      The idea here is that RA layers often need to store and retrieve
      RA-specific information in the working copy.  This is "out of band"
      data" that is irrelevant to the repository.
   
      In the case of ra_dav, these properties are actually the versioned
      resource URLs.  In the case of ra_local, we may store
      authentication information this way (instead of using a .cvspass
      file).  There may be other ra layers someday that need to store
      private data in the same way, so we now have a general method for
      doing so.
   
      Note:  this is the only editor change that *truly* has nothing to
      do with "describing a tree change", which should make all of us
      raise our collective eyebrows suspiciously.  However, I don't think
      the "plug n' play" vision of editors is lost here, although we're
      skirting the near the line.
   
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #4:  Revise the commit cleanup process.  (in svn_ra.h)
   STATUS: Will be done by Ben, Mike, or self, unless someone volunteers.
   The Way It Works Now:
      The client calls get_commit_editor() in the RA layer, drives the
      commit editor, and finishes the edit.  Assuming the commit is
      successful, RA sets the new filesystem head revision in the
      *new_revision argument.  At this point, the client bumps all WC
      revisions to this new number.
   
   Proposed Change:
      Remove the *new_revision argument; in the call to
      get_commit_editor(), the client passes pointers to two new
      functions and a baton:
   
            close_baton
            close_commit_func (close_baton, relative_path, new_rev)
            set_wc_prop_func (close_baton, relative_path, name, val)
   
      After finishing with RA's commit editor, RA does the "cleanup" by
      calling the two functions above.  close_commit_func() bumps the
      revision number of a path, and set_wc_prop_func() stores WC
      properties on that path.
   
   Rationale:
      Following on the heels of the previous issue, RA needs the ability
      to store special "WC properties" after a commit.  In the case of
      ra_dav, these are the magical "versioned resource URL" cookies.  In
      the case of ra_local, perhaps someday these WC props will be
      something else.
   
      As long as RA is doing this, it's simpler and more elegant to let
      it bump revision numbers as well.  Right now the WC is storing a
      list of all committed targets and doing the cleanup manually;  it's
      far easier to let RA do the work.  In the end, WC won't have to do
      anything but cleanup lockfiles.  Much simpler.
   
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #5:  The "report" editor doesn't exist.
   STATUS: Will be done by Ben, Mike, or self, unless someone volunteers.
   The Way It Works Now:
      To perform an update: 
           - the client fetches a "report" editor from RA
           - the client drives the report editor, describing the state
             (revision numbers) of all objects in the working copy.
           - RA then drives the "update" editor with custom changes.
   
   Proposed Change:
      To perform an update:
           - client describes working copy state using a new vtable with
             just two simplified functions: replace_dir() and
             replace_file() 
           - RA then drives the "update" editor with custom changes.
   
   Rationale:
       It occurred to us that it's inappropriate to use an editor to
       report all the revision numbers in a working copy.  To do so would
       completely distort the semantics of the editor: it has *nothing*
       to do with describing a tree delta!
    
       One might argue that you *could* report working copy state as a
       tree-delta.  In this scenario, you grab the revision of the WC's
       root (say, version N), and then send a tree-delta that describes
       how to change a tree at revision N into a multi-versioned tree
       that looks like the working copy's hodgepodge of revisions.  Every
       single object in the WC that isn't at N must be reported; pretty
       inefficient.  Every call to replace_*() would have a base_revision
       of N, and some different target revision.
   
       Needless to say, even in this scenario, no text-deltas are being
       sent, and things are inefficient.  As Jimb says, "let's just write
       an interface that really does what we want."  :)
   
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #6:  Move textdeltas to the "other side" of the editor.
   STATUS: Being discussed on list; holding off on making this change.
   The Way It Works Now:
      The driver of an editor takes a source and target stream, puts them
      together via svn_txdelta() to produce a stream of "windows".  The
      driver then pushes these windows at the editor's window-handler.
   
   Proposed Change:
      Move this process to the other side of the interface, into the
      editor implementation, giving the editor the power to deal with the
      source and target streams directly.
   
      Specifically:
                - remove the editor's apply_txdelta() routine
                - create two new routines:
                   apply_delta (filebaton, [src_stream], target_stream)
                   set_file_contents (filebaton, [src_stream], delta,
                                      enum delta_type)
   
                   apply_delta() sends svndiff deltas.
                   set_file_contents() can send plain text or other
                   types. 
   
                It becomes the obligation of the editor implementation to
                implement at least one of these two routines;  if one
                routine is NULL, the driver must use the other.
   
   Rationale:
      It's too restrictive to force every editor implementation to accept
      and deal with small svndiff windows.  For example: Greg Stein wants
      to send plain text while debugging his commit-editor and network
      layer.  It's best to allow the RA layer to make it's own choice
      about how to break up the two streams most efficiently.
   
      The reason [src_stream] is optional is that it may be NULL;  this
      presumably means that the editor already has access to the src
      stream.
   
      (Greg and Jim, did I get this explanation totally wrong?  My notes
      here aren't perfectly clear.  Please elaborate if you need to.)
   
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #7:  New filesystem "copy" nodes (and renaming add_*() args)
   STATUS: Will be done by Brane, now that he's dug what this is all about.
   The Way It Works Now:
      When we copy (or move) a node in the filesystem, we're currently
      losing information about where it came from.  Our "lazy cloning"
      model goes a long way, but in the end we get just a bunch of
      duplicated pointers to the same node revision numbers.
   
      E.g.: if a node A points to the same node revision that two others
      (B and C) point to, there's no way to know whether A was copied
      from B or C.
   
   Proposed Changes:
      1.  In the filesystem model, create a 3rd node type called a "copy"
          node.  (This is in addition to our "file" and "dir" nodes.)
   
          A copy node contains a pointer to a revision and a path.
   
          When we create node B as a "copy" of node A, we create a new
          copy node.  This copy node allows us to discover the proper
          node-revision, but it also tracks the history of the copy.
   
      2.  Remember that a copy command is really just an "add with
          history", and a move command is really just a "delete, followed
          by an add with history".  Thus it's the *add* command, which,
          when given an ancestor path and revision, creates a copy node.
          (If there's no history given, then the add command creates a
          regular node.)
   
          For clarity sake, the history arguments to the editor's add()
          function should reflect this copying.  Instead of
          "ancestor_path" and "ancestor_revision", we'd like to call the
          arguments "copyfrom_url" and "copyfrom_revision".
      
   Rationale:
      I think it's all been explained above.  Other folks, feel free to
      add to this explanation.
