								-*-text-*-

If you're looking for a task to take on, please see the TASKS file.

This file merely lists immediate, short-term (next few days) stuff on
people's stacks.  It may make reference to phone conversations and
private emails, so a given item might not make much sense unless one
is familiar with its out-of-band context.  We keep this file under
version control mainly for convenience -- feel free to add your own
short-term tasks to it, if that's helpful.

------------------------------------------------------------------------

General Problems (someone grab these):

   - updates (right now) don't bump the revision of every entry as
     they should;  instead we're only bumping the changed entries.

   - unable to update specific targets right now;  we need to
     distinguish between specific targets and general full recursive
     updates.

   - don't use stdio's BUFSIZ (portability?). define an SVN specific
     constant and use it throughout.

   - refactor client/main.c's cmdline handling and place it into
     libsvn_subr. use the new functions within svnadmin/main.c.

   - switch the copyright notices from "... 2000 ..." to "2000-2001".
     note: tools/check-license.py is handy for this

   - svn_string.c::svn_string_createf(): follow the comments about
     refactoring to prevent double memory usage

Ben & Karl todo:

   - clean up the interface in libsvn_client.  make it more canonical.
     (This may happen automatically as the Win32 and Gnome clients are
      developed after-hours!)

Ben todo:

   Ben's magic list of bugs:

       - svn add a file, then run svn status.  you can see it.
         svn add a dir, then run svn status.  you can't see it.

            -why?  because we should format the new dir as soon as we add
             it (make it into a wc subir.)

            -whoops, svn_client_add() assumes files only!!!

       - svn ci --xml-file foo.xml
         this command segfaults, but not if we add a --revision arg.

       - svn rm some/dir/
         when you run svn status, the dir doesn't show up as being
         marked for deletion, *unless* you remove it... ???  I know
         that a dir can't be deleted unless it's empty, but this is
         going too far.

   Ben's todo list:

       - finish svn_fs_is_different, make status command use it.

       - change svn_ra.h so that we can check out a specific revision.



Mike Pilato wc todo:

   - Big Ol' Change #2 below.
   - From Bill Tutt:
     This is just more an FYI, as it isn't preventing me from doing
     any work atm, but the paths returned from svn_wc_statuses are
     looking like: "C:\SVN\subversion\subversion\client\tests\t1\/iota"
     Seemingly fixed by Mike's changes to apr_subr/path.c, but Bill
     sez he too will verify this at some point in the near future.
         

Karl wc todo:

   - Propagate changes down into libsvn_client.  Currently, the client
     usually takes a `targets' list and iterates over it, invoking
     some libsvn_client routine each time.  There are cases where the
     libsvn_client routine should get the target list directly and do
     the iteration internally, or even pass the list on down into
     libsvn_wc.
   - make an is_textfile test, so at least we can create .alt files
     instead of .rej for those that `patch' can't handle.
   - write the log/lock recovery function.
   - with Ben, review locking protocol in wc adm directories for sanity.
   - check apr_open calls, do they assume failure implies null handle?
   - fix working copy identification/allergy code
   - make sure type-changing replacements work right
   - do the generic entry/adm-path grabber abstraction, as talked
     about with Ben, change everyone around to use it (chore, whoa).

Ben and Karl (longer term):

   - xml dtd, for both xml deltas and wc formats

   - for milestone 3: TREE DELTAS.  Quake before them.  This problem
     has many aspects to it, *including* {the need for commands to
     take lists of paths, canconicalizing these lists, testing paths
     if they exist and/or what their entries say about them, etc.}
     Just a tip of the iceberg.

Greg:

   - mod_dav_svn:
      - finish repository hooks (waiting on FS a bit)
        need: MKCOL, DELETE, GET, PUT
	defer copy/move

      - liveprop hooks:
	core: getcontentlength, creationdate, getetag,
	      getlastmodified, resourcetype
	deltav: checked-in, version-name, label-name-set, baseline-collection
      - OPTIONS handling: activity-collection-set

      - vsn hooks: ???  REPORT and MKACTIVITY first
        REPORT: need the SVN:status-report
	need: MERGE (activity)
	validate proper support for VERSION-CONTROL. this would be the 
	  missing piece for DeltaV "Core" support.

      - MKACTIVITY should begin a txn
      - version resource URL prep should look up the node
      - CHECKOUT of a VR URL should verify the node ID of the
        REPOS_PATH in the latest revision matches the node ID in the
	VR URL (if not, they are checking out an old copy)

   - mod_dav: no apparent changes until vsn comes in
      - need: MERGE
      - verify Vasta's work against our needs: REPORT, LABEL
      - probably need BASELINE-CONTROL

   - libsvn_ra_dav:
      - update editor
      - commit editor

   - APR: move apr_copy_file() from SVN. and apr_append_file, etc.

   - security checks (e.g. system() usage in wc/get_editor)


Working Copy:

  TBDesigned:
    The WC will need to have some knowledge of "the repository"
    associated with any given resource. Given a working copy, the
    client cannot know whether a two URLs are within the same
    repository or not, so it doesn't know whether one or multiple
    commit sequences are required to commit the whole working copy.

    The RA layer (in conjunction with the server) will need to somehow
    tell the WC about the repository associated with a given directory
    (or long term, each file?). At commit time, the WC sorts out how
    many repositories are involved, and performs a commit per
    repository.

    [ We never really had a story for discriminating multiple
      repositories within a given WC. Stopping to think about it, it
      was just a hand-wave. Given the flexibility in URLs and virtual
      hosting on the server and whatnot, static analysis of a URL will
      never be sufficient, but the server can always state
      definitively the repository for any given resource. ]


Filesystem:

  Anyone, WRT filesystem:

     We need a function that will remove the *first*, not the last,
     component from a path. We need this to support full-path lookups
     in the new FS interface, specifically, for open_path.

     Suggest something like this:

       int svn_path_first_component (const char **name,
                                     char **path,
                                     enum svn_path_style style);

     This would point *NAME to the first component in *PATH, and
     modify *PATH to split the first component off. Return 0 if *NAME
     is empty, otherwise 1. See the pseudocode in open_path in tree.c
     to see how this would be used.
  
Changes to svn_delta_edit_fns_t:

   These are the summary emails Ben sent to the dev list (lightly
   edited), concerning changes proposed and accepted at the meetings
   in Chicago on January 14-16.  A few of these are still being
   discussed on the list; see the "STATUS" lines for more.

   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #3:  New "WC" properties.
   STATUS: Will be done by Ben, Mike, or self, unless someone volunteers.
   The Way It Works Now:
      Properties attached to objects in the repository also appear in the
      WC.  Similarly, properties added to WC objects get committed to the
      repository. 
   
   Proposed Change:
      Create a new class of properties that *only* exist in the WC.
      These properties are stored for the benefit of RA layers.  We add
      new editor functions:
   
            set_wc_dir_props (dir_baton, name, val)
            set_wc_file_props (file_baton, name, val)
   
      If driving an editor:  if WC props exist for the object you're
      describing, you *must* send them via these functions.
   
      If implementing an editor: if you receive WC props, you *must*
      store them somewhere.
   
   Rationale:
      The idea here is that RA layers often need to store and retrieve
      RA-specific information in the working copy.  This is "out of band"
      data" that is irrelevant to the repository.
   
      In the case of ra_dav, these properties are actually the versioned
      resource URLs.  In the case of ra_local, we may store
      authentication information this way (instead of using a .cvspass
      file).  There may be other ra layers someday that need to store
      private data in the same way, so we now have a general method for
      doing so.
   
      Note:  this is the only editor change that *truly* has nothing to
      do with "describing a tree change", which should make all of us
      raise our collective eyebrows suspiciously.  However, I don't think
      the "plug n' play" vision of editors is lost here, although we're
      skirting the near the line.
   
   
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #6:  Move textdeltas to the "other side" of the editor.
   STATUS: Being discussed on list; holding off on making this change.
   The Way It Works Now:
      The driver of an editor takes a source and target stream, puts them
      together via svn_txdelta() to produce a stream of "windows".  The
      driver then pushes these windows at the editor's window-handler.
   
   Proposed Change:
      Move this process to the other side of the interface, into the
      editor implementation, giving the editor the power to deal with the
      source and target streams directly.
   
      Specifically:
                - remove the editor's apply_txdelta() routine
                - create two new routines:
                   apply_delta (filebaton, [src_stream], target_stream)
                   set_file_contents (filebaton, [src_stream], delta,
                                      enum delta_type)
   
                   apply_delta() sends svndiff deltas.
                   set_file_contents() can send plain text or other
                   types. 
   
                It becomes the obligation of the editor implementation to
                implement at least one of these two routines;  if one
                routine is NULL, the driver must use the other.
   
   Rationale:
      It's too restrictive to force every editor implementation to accept
      and deal with small svndiff windows.  For example: Greg Stein wants
      to send plain text while debugging his commit-editor and network
      layer.  It's best to allow the RA layer to make it's own choice
      about how to break up the two streams most efficiently.
   
      The reason [src_stream] is optional is that it may be NULL;  this
      presumably means that the editor already has access to the src
      stream.
   
      (Greg and Jim, did I get this explanation totally wrong?  My notes
      here aren't perfectly clear.  Please elaborate if you need to.)
   
   Problem:
      Editor composition becomes more difficult if we use streams.  A
      window is a discrete chunk of data that can be used by several
      consumers, but streams are different: if consumer A reads some
      data off a stream, then when consumer B reads, she'll get
      different results.  You'd have to design your streams in a funky
      way to make this not be a problem.

      In some circumstances, this isn't an issue.  After all, usually
      a set of composed editors is a bunch of lightweight editors,
      that don't do much, surrounding a core editor that does the real
      work.  For example, an editor that prints out filenames wrapped
      with an editor that actually updates those files.  In such
      cases, the lightweight editor simply never reads data off the
      stream, so the core editor is not deprived of anything.

      But other editors (say, a commit guard?) might want to actually
      examine file data.  That could have bad consequences if we
      switch from windows to streams.

   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   Change #7:  New filesystem "copy" nodes (and renaming add_*() args)
   STATUS: Will be done by Brane, now that he's dug what this is all about.
   The Way It Works Now:
      When we copy (or move) a node in the filesystem, we're currently
      losing information about where it came from.  Our "lazy cloning"
      model goes a long way, but in the end we get just a bunch of
      duplicated pointers to the same node revision numbers.
   
      E.g.: if a node A points to the same node revision that two others
      (B and C) point to, there's no way to know whether A was copied
      from B or C.
   
   Proposed Changes:
      1.  In the filesystem model, create a 3rd node type called a "copy"
          node.  (This is in addition to our "file" and "dir" nodes.)
   
          A copy node contains a pointer to a revision and a path.
   
          When we create node B as a "copy" of node A, we create a new
          copy node.  This copy node allows us to discover the proper
          node-revision, but it also tracks the history of the copy.
   
      2.  Remember that a copy command is really just an "add with
          history", and a move command is really just a "delete, followed
          by an add with history".  Thus it's the *add* command, which,
          when given an ancestor path and revision, creates a copy node.
          (If there's no history given, then the add command creates a
          regular node.)
   
          For clarity sake, the history arguments to the editor's add()
          function should reflect this copying.  Instead of
          "ancestor_path" and "ancestor_revision", we'd like to call the
          arguments "copyfrom_url" and "copyfrom_revision".
      
   Rationale:
      I think it's all been explained above.  Other folks, feel free to
      add to this explanation.

Anyone:

   These three mails between Greg Stein and Ben explain the issue:

   ----------------------------------------------------------------------
   From: Greg Stein <gstein@lyra.org>
   Subject: Re: CVS update: subversion/subversion/libsvn_ra_local \
            Makefile.am ra_local.h ra_plugin.c split_url.c
   To: dev@subversion.tigris.org
   Date: Fri, 9 Feb 2001 17:27:06 -0800
   
   On Sat, Feb 10, 2001 at 12:59:19AM -0000, sussman@tigris.org wrote:
   >...
   >   @@ -283,7 +296,10 @@
   >                       apr_pool_t *pool,
   >                       const svn_ra_plugin_t **plugin)
   >    {
   >   -  *plugin = ra_local_plugin;
   >   +  svn_ra_plugin_t *p = apr_pcalloc (pool, sizeof (*p));
   >   +  memcpy (p, &ra_local_plugin, sizeof (ra_local_plugin));
   >   +
   >   +  *plugin = p;
   
   Overkill. Use:
   
       *plugin = &ra_local_plugin;
   
   >      /* are we ever going to care about abi_version? */
   
   Yes.
   
   >... [ split_url ]
   
   This function would be a *lot* simpler, if you:
   
   1) make a dup of the URL
   2) strip the leading file:// portion (leaving "/abs/path/foo/bar")
   3) loop:
      a) try to open FS with the path. succeed: break
      b) chop the last component off
   4) fs_path is what remains, repos_path is &URL[strlen(fs_path) + 7]
      (the +7 is to account for "file://" at the start of the URL)
   
   The whole algorithm only requires one string dup to hold the shrinking path.
   stripping the leading "file://" is simply advancing string->data (we should
   have a utility function for this, because string->blocksize must shrink).
   The chopping just drops in '\0' into the dup'd path. The return is done by
   duplicating the input URL, or altering the input ->data and ->blocksize
   field values.
   
   And warning: I'm not sure whether a file URL is in "local" or "URL" style
   separators. Strictly speaking, our "URL style" is really "http scheme URL
   style". If the file URL uses "/" no matter what, then we would (strictly)
   need to convert the dup'd path (the fs_path) to local style before beginning
   the loop/test.
   
   Cheers,
   -g
   ----------------------------------------------------------------------
   From: Ben Collins-Sussman <sussman@newton.ch.collab.net>
   Subject: Re: CVS update: subversion/subversion/libsvn_ra_local \
            Makefile.am ra_local.h ra_plugin.c split_url.c
   To: Greg Stein <gstein@lyra.org>
   Cc: dev@subversion.tigris.org
   Date: 09 Feb 2001 20:06:42 -0600
   
   Greg Stein <gstein@lyra.org> writes:
   
   > Overkill. Use:
   > 
   >     *plugin = &ra_local_plugin;
   > 
   
   Heh, sure.  :)
   > 
   > >... [ split_url ]
   > 
   > This function would be a *lot* simpler, if you:
   > 
   > 1) make a dup of the URL
   > 2) strip the leading file:// portion (leaving "/abs/path/foo/bar")
   > 3) loop:
   >    a) try to open FS with the path. succeed: break
   >    b) chop the last component off
   > 4) fs_path is what remains, repos_path is &URL[strlen(fs_path) + 7]
   >    (the +7 is to account for "file://" at the start of the URL)
   
   Oh, this is the *easy* way, which I purposely avoided.
   
   I wanted to be "correct" by searching from the other direction,
   thereby always finding the repository with the shortest path, not the
   longest.
   
   Yes, I know, we agreed that we will never allow nested repositories.
   I guess I was being paranoid and trying to emulate Apache's search
   methods.  :)
   
   Do you think it's worth re-writing?

   ----------------------------------------------------------------------
   From: Greg Stein <gstein@lyra.org>
   Subject: Re: CVS update: subversion/subversion/libsvn_ra_local \
            Makefile.am ra_local.h ra_plugin.c split_url.c
   To: dev@subversion.tigris.org
   Date: Fri, 9 Feb 2001 19:19:57 -0800
   
   On Fri, Feb 09, 2001 at 08:06:42PM -0600, Ben Collins-Sussman wrote:
   > Greg Stein <gstein@lyra.org> writes:
   >...
   > > >... [ split_url ]
   > > 
   > > This function would be a *lot* simpler, if you:
   > > 
   > > 1) make a dup of the URL
   > > 2) strip the leading file:// portion (leaving "/abs/path/foo/bar")
   > > 3) loop:
   > >    a) try to open FS with the path. succeed: break
   > >    b) chop the last component off
   > > 4) fs_path is what remains, repos_path is &URL[strlen(fs_path) + 7]
   > >    (the +7 is to account for "file://" at the start of the URL)
   > 
   > Oh, this is the *easy* way, which I purposely avoided.
   > 
   > I wanted to be "correct" by searching from the other direction,
   > thereby always finding the repository with the shortest path, not the
   > longest.
   
   Ah. Right. Sorry...
   
   But still a simple change. Search from the left for '/'; replace with '\0';
   test for an FS; if not found, then put the '/' back and look for the next
   '/' (repeat).
   
   >...
   > Do you think it's worth re-writing?
   
   Yes, given how much simpler it could be, I think it would be a STACK item
   that anybody could pick up. It works now, but for long-term maintenance, it
   would be nice to have a simplifed version.
   
   Cheers,
   -g
   ----------------------------------------------------------------------
