@node Goals
@chapter Goals

The goal of the Subversion project is to take over CVS's current and
future user base.  The first release has all the major features of CVS,
plus certain new features that CVS users often wish they had.

Generally, Subversion's interface to a particular feature is similar to
CVS's, except when there's a compelling reason to do otherwise.

So what does Subversion have that CVS doesn't?

@itemize *
@item
It versions directories, file-metadata, renames, and
removals/resurrections.  In other words, Subversion records the
changes users make to directory trees, not just changes to file
contents.

@item
Tagging and branching are constant-time and constant-space.

@item
It is natively client/server, hence much more maintainable than CVS.
(In CVS, the client/server protocol was added as an afterthought.
This means that most new features have to be implemented twice, or at
least more than once: code for the local case, and code for the
client/server case.)

@item
The repository is organized efficiently and comprehensibly.  (Without
going into too much detail, let's just say that CVS's repository
structure is showing its age.)

@item
Commits are atomic.  Each commit results in a single version number;
that version refers to the state of the entire tree; files no longer
have their own version numbers.

@item
The locking scheme is only as strict as absolutely necessary.
Reads are never locked, and writes lock only the files being
written, for only as long as needed.

@item
It has internationalization support.

@item
It handles binary files gracefully (experience has shown that CVS's
binary file handling is prone to user error).

@item
It has a fully-realized internal concept of users and access
permissions.

@item
It takes advantage of the Net's experience with CVS by choosing better
default behaviors for certain situations.

@end itemize

Some of these advantages are clear and require no further discussion.
Others are not so obvious, and are explained in greater detail below.

@menu
* Rename/removal/resurrection support::
* Text vs binary issues::
* I18N/Multilingual support::
* Branching and tagging::
* Merging and ancestry::
* Miscellaneous new behaviors::
@end menu

@c -----------------------------------------------------------------------
@node Rename/removal/resurrection support
@subsection Rename/removal/resurrection support

Full rename support means you can trace through ancestry by name
@emph{or} by entity.  For example, if you say "Give me version 12 of
foo.c", do you mean version 12 of the file whose name is @emph{now}
foo.c (but perhaps it was named bar.c back at version 12), or the file
whose name was foo.c in version 12 (perhaps that file no longer exists,
or has a different name now)?

In Subversion, these two kinds of information are stored independently,
so you can choose which interpretation to use.  When you update to a
particular revision, Subversion just does the right thing.

@c -----------------------------------------------------------------------
@node Text vs binary issues
@subsection Text vs binary issues

Historically, binary files have been problematic in CVS for two
unrelated reasons: keyword expansion, and line-end conversion.

@dfn{Keyword expansion} is when CVS expands "$Revision$" into "$Revision
1.1$", for example.  There are a number of keywords in CVS: "$Author$",
"$Date$", and so on.

@dfn{Line-end conversion} is when CVS gives plaintext files in the
working copy the appropriate line-ending conventions for that platform.
For example, a Unix working copy would use LF, but a Windows working
copy would use CRLF.  (Like CVS, the repository always stores text files
in Unix LF format).

Both keyword substitution and line-end conversion are sensible only for
plain text files.  CVS only recognizes two file types anyway: plaintext
and binary.  And CVS assumes files are plain text unless you tell it
otherwise.

Subversion recognizes the same two types.  The question is, how does it
determine which type a file is?

Experience with CVS suggests that assuming text unless told otherwise
is a losing strategy -- people frequently forget to mark images and
other opaque formats as binary, then later they wonder why CVS mangled
their data.

So Subversion assumes a file is binary, unless it matches a standard
text pattern (.c, .h, .pl, .html, .txt, README, and so on).  When
necessary, the user can explicitly set the type for a file or file
pattern.

Text files undergo line-end conversion by default.  Users can turn
line-end conversion on or off per file pattern, or per file.

Text files do *not* undergo keyword substitution by default, on the
theory that if someone wants substitution and isn't getting it, they'll
look in the manual; but if they are getting it and didn't want it, they
might just be confused and not know what to do.  Users can turn
substitution on or off per project, or per file pattern, or per file.

Both of these changes are done on the client side; the repository does
not even know about them.

Changes to any of these properties are versioned -- the properties are
associated with a particular version of the file, and new versions
inherit from previous versions except when told otherwise.  Thus,
changes to file type are recorded like any other historical data (the
type will probably be stored in the entity's property list).

@c -----------------------------------------------------------------------
@node I18N/Multilingual support
@subsection I18N/Multilingual support

Subversion is internationalized -- commands, user messages, and errors
can be customized to the appropriate human language at build-time (or
run time, if that's not much harder).

File names and contents may be multilingual; Subversion does not assume
an ASCII-only universe.  For purposes of keyword expansion and line-end
conversion, Subversion also understands the UTF-* encodings (but this
may happen after the first release).

TODO: think about this

(It may be workable to just treat everything as UTF-8 at first; for
non-UTF-8 text files with a few "meta" characters, this might at worst
result in some number of bytes after the meta character being
ignored... no big loss, except when a keyword code or line-end falls
within the lost bytes, but that probably wouldn't happen too often...)

@c -----------------------------------------------------------------------
@node Branching and tagging
@subsection Branching and tagging

CVS makes an unnecessary distinction between branches and tags, and
then goes on to implement them in an inefficient way.

Subversion supports them both with one efficient operation: `clone'.  To
clone a tree is to create another tree exactly like it, except that the
new project "knows" its ancestry relationship with the old tree.

At the moment of creation, a clone requires only a small, constant
amount of space in the repository -- the clone is like an "alias" for
the ancestor.  And if you never commit anything on the clone, then it's
just like a CVS tag.

If you start committing on the clone, then it's a branch.  Voila!

This also gets us "vendor branching" for free (since we'll have real
rename and directory support).

Note that from the user's point of view, there may still be separate
branch and tag commands, with the latter initializing the clone as
read-only (i.e., if a static snapshot is going to become an active line
of development, one at least wants users to be aware of the change).

(Ben sez:  don't forget to mention that branches and clones are visible
in the Subversion filesystem namespace!)

@c -----------------------------------------------------------------------
@node Merging and ancestry
@subsection Merging and ancestry

(TODO: rewrite this a bit to emphasize that ancestor sets consist of
*deltas*, not versions.  The notation below doesn't make this clear.)

Subversion defines merges the same way CVS does: to merge means to take
a set of previously committed changes and apply them as a patch to the
working copy.

In CVS, performing a merge is equivalent to hand-editing the working
copy into the same state as it would have been after the merge.  But
Once the merge is committed, CVS has no memory of the source of the
changes; this can, and frequently does, lead to conflicts when users
unintentionally merge in the same changes again.  (Experienced CVS users
avoid this problem by using branch- and merge-point tags, but that
itself involves a lot of unwieldy bookkeeping.)

In Subversion, merges are remembered by storing @dfn{ancestry}
information.  Think of an ancestry as a set -- the set of all commits
(diffs) that went into a particular version of a particular file.  (Ben
sez: don't you mean "set of all changes to a tree"?) By keeping these
sets up-to-date, and consulting them when doing merges, Subversion can
avoid applying the same patch twice and spare the user the necessity of
remembering what's been merged and what hasn't.

For example, in this history of the file A

@example
 _____        _____        _____        _____        _____ 
|     |      |     |      |     |      |     |      |     |
| A:1 |----->| A:2 |----->| A:3 |----->| A:4 |----->| A:5 |
|_____|      |_____|      |_____|      |_____|      |_____|
             
@end example

the ancestor set of A:5 is

@example
  @{ A:1, A:2, A:3, A:4, A:5 @}
@end example

(If you're surprised to see A:5 itself in the ancestor set, try thinking
of the set as "changes accounted for" in that version.  Naturally, the
commit resulting in A:5 is accounted for in A:5, as is the commit
resulting in A:4, and so on.)

Now suppose there's a branch B rooted at A:2, and that we want to merge
this branch with A:5 to produce A:6.

But what does it mean to "merge this branch"?  Merging a branch is
ambiguous; according to the definition of merging, we need to know
exactly which commits (changes) are being merged.

Thus, although a common shorthand merge diagram looks like this

@example
 _____        _____        _____        _____        _____        _____
|     |      |     |      |     |      |     |      |     |      |     |
| A:1 |----->| A:2 |----->| A:3 |----->| A:4 |----->| A:5 |----->| A:6 |
|_____|      |_____|      |_____|      |_____|      |_____|  ^   |_____|
                \                                            |
                 \                                           |
                  \  _____        _____        _____        /
                   \|     |      |     |      |     |      /
                    | B:1 |----->| B:2 |----->| B:3 |--->-'
                    |_____|      |_____|      |_____|
@end example

a more explicit diagram would be:

@example
 _____        _____        _____        _____        _____        _____
|     |      |     |      |     |      |     |      |     |      |     |
| A:1 |----->| A:2 |----->| A:3 |----->| A:4 |----->| A:5 |----->| A:6 |
|_____|      |_____|      |_____|      |_____|      |_____|  ^   |_____|
                |                                            |
                |                             _______________|
                |               _____________/
                |              /            /
                \_____________/            /
                 \           /            /
                  \  _____   |    _____   |    _____ 
                   \|     |  |   |     |  |   |     |
                    | B:1 |----->| B:2 |----->| B:3 |
                    |_____|      |_____|      |_____|
@end example

And A:6's ancestry set would look like this after the merge:

@example
  @{ A:1, A:2, A:3, A:4, A:5, B:1, B:2, B:3 @}
@end example

Although this merge happened to include all the changes on the branch,
that needn't be the case for all merges.  For example:

@example
 _____        _____        _____        _____        _____        _____
|     |      |     |      |     |      |     |      |     |      |     |
| A:1 |----->| A:2 |----->| A:3 |----->| A:4 |----->| A:5 |----->| A:6 |
|_____|      |_____|      |_____|      |_____|      |_____|  ^   |_____|
                |                                            |
                |                           _________________|
                |                          /
                |                         /
                \              __________/
                 \            /          |
                  \  _____   |    _____  |     _____        _____ 
                   \|     |  |   |     | |    |     |      |     |
                    | B:1 |----->| B:2 |----->| B:3 |----->| B:4 |----->
                    |_____|      |_____|      |_____|      |_____|
@end example

which leaves A:6's ancestry set at

@example
  @{ A:1-6, B:2-3 @}
@end example

If a user now tells Subversion to "merge branch B into A", meaning merge
all the "accounted for" in B:4 into A, then Subversion will
automagically notice that B:2 and B:3 are already accounted for and
apply only the patches for B:1 and B:4.  In the end, A:7's ancestry set
would look like this:

@example
  @{ A:1-7, B:1-4 @}
@end example

There is no requirement that the merge source be a contiguous range of
revisions.  One might apply the change for B:1 and B:3, but omit B:2 and
B:4 (for example, if you knew that 1 and 3 were stable bugfix changes,
but 2 and 4 were experimental code not ready for the trunk yet).

Although every merge comes from a @emph{set} of changes, the client
interface to merges may allow one or both sides to be specified
implicitly.  When this is done, the full merge information is derived
via clearly understandable rules.

The above describes how merging and ancestry work both within a
repository and across repositories.  However, inter-repository merging
will probably not be implemented until a future release of Subversion.

(Note that the repository stores ancestry sets efficiently, collapsing
into ranges wherever possible, etc.)

@c -----------------------------------------------------------------------
@node Miscellaneous new behaviors
@subsection Miscellaneous new behaviors

@menu
* Log messages
* Client side diff plug-ins
* Conflict resolution
* Multisite and local repository
@end menu

@c -----------------------------------------------------------------------
@node Log messages
@subsubsection Log messages

Subversion has a flexible log message policy (a small matter, but one
dear to our hearts...).

Log messages should be a matter of project policy, not version control
software policy.  If a user commits with no log message, then Subversion
defaults to an empty message.

(CVS tries to require log messages, but fails: we've all seen empty
log messages in CVS, where the user committed with deliberately empty
quotes.  Let's stop the madness now.)

@c -----------------------------------------------------------------------
@node Client side diff plug-ins
@subsubsection Client side diff plug-ins

Subversion supports client-side plug-in diff programs

There is no need for Subversion to have every possible diff mechanism
built in.  It can invoke a user-specified client-side diff program on
the two versions of the file(s) locally.

@c -----------------------------------------------------------------------
@node Conflicts resolution
@subsubsection Conflicts resolution

Conflicts are handled as in CVS, but a little better.

For text files, Subversion resolves conflicts similarly to CVS, by
folding repository changes into the working files with conflict markers.
But (for @emph{both} text and binary files), Subversion also always puts
the pristine repository version in one temporary file, and the pristine
working copy version in another temporary file.

Thus, in a text conflict, the user has three files to choose from

@enumerate
@item the combined file, with conflict markers
@item the original working copy file
@item the repository revision from which the update was taken
@end enumerate

(CVS provides the first two, but doesn't directly provide the third.
It's true that one could retrieve the repository version from the
repository (using update -p or whatever), but it's more convenient to
have it readily at hand.  When the conflict has been resolved and the
working copy is committed, Subversion can automatically remove the two
pristine files.)

A more general solution would allow plug-in merge resolution tools on
the client side; but this is not scheduled for the first release.  Note
that users can use their own merge tools anyway, since all the original
files are available.

@c -----------------------------------------------------------------------
@node Multisite and local repository
@subsubsection Multisite and local repository

Two commonly requested enhancements for CVS are "multisite" and "local
repositories".  Although the two terms are sometimes used
interchangably, they refer to two different things (explained below).
Subversion can eventually support both, but they are not priorities
for the first release.  Nothing in the design prevents them from being
added on later.

(Ben sez:  The "Multisite" section below needs to be rewritten to
describe the master/slave replicating server-caching model.  The "Local"
repository section needs to be rewritten to explain how cheap clones
(branches) give us this behavior for free;  of course, for the first
release of subversion, these quick branches will only be
intra-repository, not inter-.)


@enumerate

@item Multisite

This is like the ClearCase multisite feature.  Essentially, it is a
redundant distributed repository.  The repository exists on two or
more cooperatively mirroring servers (each one presumably being close,
network-wise, to its intended users).  Commits on any server are
visible on all of them.  I'm not sure how conflict resolution is
handled when people at different mirrors change the same file at at
the same time -- perhaps one of the commits is backed out and returned
to that user?  Hmmm.

Anyway, CVS has gotten away with simply assuming decent Net access for
all users; this doesn't satisfy everyone, but for the first release of
Subversion we should probably do the same.

@item Local repository

This is one that people request a lot: the ability to commit changes
first to a local "working repository" (not visible to the rest of the
world), and then commit what's in the working repository to the real
repository (with the several commits maybe being folded into one
commit).

Why do people want this?  I think mostly it's the psychological
comfort of making a snapshot whenever one reaches a good stopping
point, but not necessarily wanting all those "comfort points" to
become publically-visible commits.  This is understandable, but of
course the local repository will have to refuse to commit changes if
any of the files turn out not to be up-to-date.  (There may also be a
very cheap way to implement 90% of this feature by making skeleton
duplicates of the working copy's directory tree and copying the
changed files into that skeleton...)

(Are there any other reasons people want this feature?  I remember
seeing posts on info-cvs explaining what appeared to be other reasons,
but frankly I could never understand them very well...)

For now, similar effects are achievable without involving the version
control system, so this feature is not a priority for the first
release of Subversion.  Unless someone can explain a clear way to
implement it, and another reason why it's important to support it.
@end enumerate
