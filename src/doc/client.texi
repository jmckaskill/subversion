@node Client
@chapter Client

The Subversion client is built on three libraries.  One operates
strictly on the working copy and does not talk to the repository.
Another talks to the repository but never changes the working copy.  The
last library uses the first two to provide user-level operations such as
@code{commit} and @code{update}, that both talk to the repository and
change the working copy.

The initial client is a Unix-style command-line tool (like standard
CVS), but there is no reason why that has to be the only client.  The
libraries exist to separate Subversion-specific functionality from
user-interface decisions; a GUI client can use the libraries as easily
as a command-line client can.

This chapter describes the libraries, and the physical layout of working
copies.

@menu
* Terminology
* The working copy management library
* The repository access library
* The client operation library
* The layout of working copies
@end menu

@c todo: make sure skelta gets define somewhere

@c -----------------------------------------------------------------------
@node Terminology
@subsection Terminology

This chapter uses a few fundamental concepts that have not been
introduced previously.  Here they are briefly defined, but see
@pxref{Protocol} for more complete descriptions.

@table @b
@item vdelta, vdiff 
A generic format for expressing the differences between two files.
Unlike traditional @code{diff} format, vdeltas can express differences
between non-text files.  Vdeltas are not human-readable and can only be
used as patches if the base file is absolutely unmodified -- they have
no concept of context.

@item diff 
A line-based text diff, like the output of the GNU diff program.

@item pdelta, pdiff
Deltas for property lists..
May include vdeltas. 

@item delta
A data structure capable of representing changes to directory trees.
Handles not only vdeltas between files, but also adds, deletes, renames,
and permission changes.

A deltas uses vdeltas and pdeltas to express changes to file contents
and metadata.

@item skelta 
A "skeleton delta".  That is, a delta with empty slots where the pdeltas
and vdeltas would be.  A skelta is used to @emph{list} the changes that
happened to a directory tree, omitting the changes to file contents

FOOO working here


@item node" 
File or directory.


@end table

@c -----------------------------------------------------------------------
@node The working copy management library
@subsection The working copy management library

This library performs "offline" operations on the working copy.  The
prefix @code{wc_} is used to identify that this is the "working copy"
library.

@table @code

@item skelta wc_make_skelta (path1, ...)

Returns a skelta -- a delta object describing the changes to
@emph{paths} but not including the actual content of the changes (i.e.,
the vdeltas).  In other words, this is how you get a list of all local
modifications.

A @emph{path} can be a directory or a file; if directory, then it's a
root from which to start looking for modifications.

Takes multiple @code{path} arguments because you might want to do
something like this:

@example
   $ svn commit foo/ bar/ baz/qux.c
@end example

The commit is atomic, and covers some but not necessarily all of the
subdirectories available here.  Therefore, it must be possible to
request a delta for any subset of the working tree.  Although some files
and directories outside that subset might also have been modified, the
delta will not include those changes.

@item delta wc_fill_skelta (skelta)

Turns @emph{skelta} into a delta by generating the appropriate vdiffs
and pdiffs, and placing them into the skelta.

(Note to self: probably okay for this to modify its argument.)

@item delta wc_make_delta (path1, ...)

Equivalent to 

@example
   wc_fill_skelta (make_skelta (path1, ...))
@end example

@item bool wc_apply_delta (delta)

Applies @emph{delta} to the working copy.

@item bool wc_add (path)

Add the file @emph{path} (i.e., tweak the administrative files
appropriately).

@item bool wc_delete (path)

Remove this file.

@item bool wc_rename (old_path, new_path)

Move/rename this file (within the working copy, of course).

@item str_t wc_get_node_prop (path, propname)

Return local value of @emph{propname} for the file or directory
@emph{path}.

@item str_t wc_get_dirent_prop (path, propname)

Return local value of @emph{propname} for the directory entry @emph{path}.

@item proplist_t wc_get_node_proplist (path)

Return all properties (names and values) of file or directory
@emph{path}, in a hash table.

@item proplist_t wc_get_dirent_proplist (path)

Return all properties (names and values) of directory entry @emph{path},
in a hash table.

@item str_t *wc_get_node_propnames (path)

Return all property names for file or directory @emph{path}.

@item str_t *wc_get_dirent_propnames (path)

Return all property names for a directory entry.

@end table

@c -----------------------------------------------------------------------
@node The repository access library
@section The repository access library

This library performs operations involving communication with the
repository.  The prefix @code{ra_} is used for everything in this
library.

@table @code

@item version ra_latest (repos, path)

Report the latest ra_version in the repository for @emph{path}.

@item token ra_submit_delta (repos, skelta)

Submit @emph{skelta} for approval (see @pxref{Locking}).
Either a skelta or a full delta can be passed.

@item ver ra_write_delta (repos, delta, token)

Write previously-approved @emph{delta} into the version history.
Must be a full delta, of course; a skelta would be insufficient.

@item skelta ra_get_status (repos, skelta)

Find out the status (up-to-date or not) for the files mentioned in
@emph{skelta}.

@item delta ra_get_update (repos, skelta)

Get changes for files mentioned in @emph{skelta}.

@item bool ra_abandon (repos, token)

Abandon the transaction identified by token (for example, a user might
interrupt the client between calls to submit_delta() and write_delta(),
and the server would want to know the commit has been abandoned so it
can clear out its pool of approved changes).

@item delta ra_get_delta (repos, ver1, path1, ver2, path2)

Return the delta between the two trees.

(Note: it's not yet clear that this function is strictly necessary.  It
is included for completeness' sake, but I think we can implement
everything without it.)

@item diff ra_get_diff (repos, ver1, path1, ver2, path2, 
                     [ver3, path3, ver4, path4, ...])

Return a text diff between versions in the repository.
(This must be done server side, the client doesn't have enough
information to make the diff.)

@item node ra_read (repos, ver, path)

Return a file or directory from the repository.
@c todo: explain lazy reading

@item str_t ra_get_node_prop (path, propname)

Return local value of @emph{propname} for the file or directory
@emph{path}.

@item str_t ra_get_dirent_prop (path, propname)

Return local value of @emph{propname} for the directory entry @emph{path}.

@item prop_t ra_get_ver_prop (ver, propname)

Return the value of @emph{propname} for a version (e.g., log message).

@item proplist_t ra_get_node_proplist (path)

Return all properties (names and values) of file or directory
@emph{path}, in a hash table.

@item proplist_t ra_get_dirent_proplist (path)

Return all properties (names and values) of directory entry @emph{path},
in a hash table.

@item prolist_t ra_get_ver_proplist (ver)

Return all properties (keys and values) of a version.

@item str_t *ra_get_node_propnames (path)

Return all property names for file or directory @emph{path}.

@item str_t *ra_get_dirent_propnames (path)

Return all property names for a directory entry.

@item str_t *ra_get_ver_propnames (ver)

Return all property keys for a version.

@end table

@c -----------------------------------------------------------------------
@node The client operation library
@subsection The client operation library

fooo working here:

   add
   annotate
   checkout
   commit
   diff
   import
   log
   rename
   remove
   branch
   tag
   status
   update


@c -----------------------------------------------------------------------
@node The layout of working copies
@subsection The layout of working copies

This section gives an overview of how working copies are arranged
physically.  It is not a full specification of working copy layout,
however; many details will be resolved only as the code takes shape.

As with CVS, Subversion working copies are simply directory trees with
special administrative subdirectories, in this case named "SVN" instead
of "CVS":

@example

                             myproj
                             / | \
               _____________/  |  \______________
              /                |                 \
            SVN               src                doc
        ___/ | \___           /|\             ___/ \___
       |     |     |         / | \           |         |
      base  ...   ...       /  |  \     myproj.texi   SVN
     / |                   /   |   \              ___/ | \___
    /  |              ____/    |    \____        |     |     |
  src doc            |         |         |      base  ...   ...
                    SVN      foo.c     bar.c     |
                ___/ | \___                      |
               |     |     |                     |
             base   ...   ...               myproj.texi
          ___/ \___
         |         |
       foo.c     bar.c

@end example

Each @file{dir/SVN/} directory records the files in @file{dir}, their
version numbers and property lists, pristine versions of all the files
for client-side delta generation, the repository from which @file{dir}
came, and any local changes (such as uncommitted adds, deletes, and
renames) that affect @file{dir}.

Although often it would often be possible to deduce certain information
(such as the origin repository) by examining parent directories, this is
avoided in favor of making each directory be as much a self-contained
unit as possible.

For example, immediately after a checkout the administrative information
for the entire working tree @emph{could} be stored in one top-level
file.  But subdirectories instead keep track of their own version
information.  This would be necessary anyway once the user starts
committing new versions for particular files, and it also makes it
easier for the user to prune a big, complete tree into a small subtree
and still have a valid working copy.

Specifically, the SVN subdir holds:

@itemize @bullet

@item
A @dfn{base} directory, containing the pristine repository versions of
the files here.

@item
A @file{versions} file, the first entry of which records the version
number of this directory (and, by implication, the version number of any
files not otherwise mentioned).  The remaining entries are for files at
other versions.

It may help to think of this file as the functional equivalent of the
CVS/Entries file.

@item
A @file{properties} file, recording properties for this directory and
all directory entries and files it contains.  Although this information
could be stored in the @file{versions} file, it is sufficiently
separable to warrant its own file; very often one wants to look up a
version without looking up a property, and vice-versa.

@item
A @file{changes} file, recording uncommitted changes to and from this
directory (adds, removes, renames).

@item
A @file{lock} file, whose presence implies that some client is currently
operating on the adminstrative area.

@item

@end itemize

The formats of these files are not specified yet.
