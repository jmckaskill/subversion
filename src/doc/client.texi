@node Client
@chapter Client

The Subversion client is built on two libraries: one handles local
working copy management, the other communicates with the server.  The
initial client is a Unix-style command-line tool (like standard CVS),
but there is no reason why that has to be the only client.  The
libraries are there to separate Subversion-specific functionality from
user-interface decisions; a GUI client can use the libraries as easily
as a command-line client can.

This chapter describes the two libraries, and the layout of working
copies.

@menu
* The working copy management library
* The repository access library
* How working copies are arranged
@end menu

@c -----------------------------------------------------------------------
@node The working copy management library
@subsection The working copy management library

This library performs "offline" operations on the working copy.

@table @code

@item empty_delta (path1, ...)

Returns a delta object describing the changes to PATHs, but without
including the actual content of file changes.  In other words, this is
how you get a list of all local modifications..

A PATH can be a directory or a file; if directory, then it's a root from
which to start looking for modifications.  

Why does it take a variable number arguments?  For the same reason the
@code{delta()} function below does, read on...

@item delta (path1, ...)

Like @code{empty_delta()}, but includes the content of file changes.

Takes multiple paths because you might want to do something like this:

@example
   $ svn commit foo/ bar/ baz/qux.c
@end example

The commit is atomic, and covers some but not necessarily all of the
subdirectories available here.  Therefore, it must be possible to
request a delta for any subset of the working tree.  Files and
directories not in that subset might also have been modified, but the
delta will not include those changes.

@item apply_delta (delta)

Applies a delta to a tree.

@item add (path)

Add this file (i.e., tweak the administrative files appropriately).

@item remove (path)

Remove this file.

@item rename (old_path, new_path)

Move/rename this file (within the working copy, of course).

@item read_prop (path, name)

Return the value of the property named NAME.

@item write_prop (path, name, value)

Set the value of the property NAME to VALUE.

@end table

@c -----------------------------------------------------------------------
@node The repository access library
@section The repository access library

This library performs operations involving communication with the
repository.

@table @code

@item latest (repository, path)

Report the latest version in the repository for PATH.

@item approve_delta (repository, delta)

@item commit_delta (repository, delta)

@item changes_between (repository, path1, version1, version2)

TODO: Unclear whether path relative to ver1 or ver2, and should we be
using an entity number instead?  No, that hasn't been standard
practice.  Think about the general question of client-visibility of
those numbers...

@item get_property (repository, version)

TODO: yes, but how does it know the repository?  Just using the current
working directory seems kind of lame... :-)

@item find_repository_modified (path1, ...)

@item PLACEHOLDER

TODO: go through the cvs ops now...

@item update (path1, ...)

TODO: update() is complex because not everything has the same base
revision; this interface is hiding a lot of complexity -- the client has
to get a delta from the server that's appropriate for the particular set
of versions the client has.  Look over server section, see what the
server's interface is...

@end table

TODO: mention the combo ops from the yellow sheet...

@c -----------------------------------------------------------------------
@node How working copies are arranged
@subsection How working copies are arranged

As with CVS, Subversion working copies are simply directory trees with
special administrative subdirectories, in this case named "SVN" instead
of "CVS":

@example

                             myproj
                             / | \
               _____________/  |  \______________
              /                |                 \
            SVN               src                doc
        ___/ | \___           /|\             ___/ \___
       |     |     |         / | \           |         |
      base  ...   ...       /  |  \     myproj.texi   SVN
     / |                   /   |   \              ___/ | \___
    /  |              ____/    |    \____        |     |     |
  src doc            |         |         |      base  ...   ...
                    SVN      foo.c     bar.c     |
                ___/ | \___                      |
               |     |     |                     |
             base   ...   ...               myproj.texi
          ___/ \___
         |         |
       foo.c     bar.c

@end example

Although often it would often be possible to deduce certain information
by examining parent directories, this is avoided in favor of making each
directory be as much a self-contained unit as possible (this will make
it easier to mix subtrees of different projects later on).

For example, immediately after a checkout the administrative information
for the entire working tree @emph{could} be stored in one top-level
file.  But the subdirectories also keep track of their own version and
repository information; this would be necessary anyway once the user
starts committing new versions of particular files, but Subversion does
it right from the beginning, for consistency.

The SVN subdir stores:

@itemize @bullet

@item
A @dfn{base tree}, containing the pristine repository versions of the
files and subdirectories there.  Note that subdirectories are stored
shallowly, solely to record permission information.  The actual base
versions of a subdir's files are stored in "SVN/base/" for that subdir.

@item
A @file{versions} file, the first entry of which records the version
number of this directory (and, by implication, the version number of any
files not otherwise mentioned in the file).  The remaining entries
record version information for files here which are at some version
other than the default.

It may help to think of this file as the functional equivalent of the
CVS/Entries file.  Like Entries, it also holds file metadata that can't
always be stored in the filesystem (properties).

@item
A @file{changes} file, recording uncommitted changes to and from this
directory (adds, removes, renames).

@item
A @file{lock} file, whose presence implies that a CVS client is
currently operating on the adminstrative area.

@item

@end itemize
