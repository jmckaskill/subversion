@node Server
@chapter Server

The term ``server'' is ambiguous, because it has at least two different
meanings: it can refer to a powerful computer which offers services to
users on a network, or it can refer to a CPU process designed to receive
network requests.

In Subversion, however, the @dfn{server} is just a set of libraries that
implement a set of @dfn{repositories} and make them available to other
programs.  No networking is required.

Of course, for the initial release of Subversion, the ``server'' process
will be Apache interacting with the Subversion server libraries.  The
``server'' computer will be any machine running this special Apache
process.  (@xref{Protocol}.)

There are two main libraries:  the @dfn{Subversion Filesystem} library,
and the @dfn{Main Subversion} library.

@menu
* Filesystem::                The Subversion Filesystem.
* Main Library::              The Subversion Server interface.
@end menu


@c ----------------------------------------------------------------

@node Filesystem
@section Filesystem

@subsection Overview

@itemize @bullet
@item
  @b{Requires:}
  @itemize
  @item
    a reasonable about of writable disk space
  @item
    an operating system that supports interprocess communication (IPC)
  @end itemize
@item
  @b{Provides:}
  @itemize
  @item
    a repository for storing files
  @item
    support for multiple concurrent accesses (via a lock manager)
  @item
    enforcement of user & group permissions (via ACLs)
  @end itemize
@end itemize

The @dfn{Subversion Filesystem} implements a hierarchical filesystem
which supports atomic changes to arbitrary groups of files, and records
the complete history of the tree -- including directory and file
contents.

Because Subversion avoids using the UNIX filesystem directly, it can
store @dfn{properties} (or ``meta-data'') with each file, directory,
directory entry, and version number.  For example, some useful
properties might be @{author, creation date, modification date, Access
Control List (ACL), file type (text, binary), file encoding, ...@}.
Similarly, a version in a repository's history can store the log message
as a property.

@subsection Schema

To begin, please be sure that you're already casually familiar with
Subversion's ideas of files, directories, and version histories.  If
not, @xref{Model}.  For completeness, we can now offer a precise,
technical description of these terms.

@c This is taken from jimb's very first Subversion spec!
@c Is there some standardized notation for describing schemas like this?
@c <jimb>
 
@quotation

A @dfn{text string} is a string of Unicode characters which is
canonically decomposed and ordered, according to the rules described in
the Unicode standard.

A @dfn{string of bytes} is what you'd expect.

A @dfn{property list} is an unordered list of properties.  A
@dfn{property} is a pair @code{(@var{name}, @var{value})}, where
@var{name} is a text string, and @var{value} is a string of bytes.
No two properties in a property list have the same name.

A @dfn{file} is a property list and a string of bytes.

A @dfn{node} is either a file or a directory.  (We define a directory
below.)  Nodes are distinguished unions --- you can always tell whether
a node is a file or a directory.

A @dfn{node table} is an array mapping some set of positive integers,
called @dfn{node numbers}, onto @dfn{nodes}.  If a node table maps some
number @var{i} to some node @var{n}, then @var{i} is a @dfn{valid node
number} in that table, and @dfn{node @var{i}} is @var{n}.  Otherwise,
@var{i} is an @dfn{invalid node number} in that table.

A @dfn{directory entry} is a triple @code{(@var{name}, @var{props},
@var{node})}, where @var{name} is a text string, @var{props} is a
property list, and @var{node} is a node number.

A @dfn{directory} is an unordered list of directory entries, and a
property list.

A @dfn{version} is a node number and a property list.

A @dfn{history} is an array of versions, indexed by a contiguous range
of non-negative integers containing 0.

A @dfn{repository} consists of node table and a history.

@end quotation

@c Some definitions: we say that a node @var{n} is a @dfn{direct child} 
@c of a directory @var{d} iff @var{d} contains a directory entry whose 
@c node number is @var{n}. A node @var{n} is a @dfn{child} of a 
@c directory @var{d} iff @var{n} is a direct child of @var{d}, or if 
@c there exists some directory @var{e} which is a direct child of 
@c @var{d}, and @var{n} is a child of @var{e}. Given this definition of 
@c ``direct child'' and ``child,'' the obvious definitions of ``direct 
@c parent'' and ``parent'' hold.

@c In these restrictions, let @var{r} be any repository.  When we refer,
@c implicitly or explicitly, to a node table without further clarification,
@c we mean @var{r}'s node table.  Thus, if we refer to ``a valid node
@c number'' without specifying the node table in which it is valid, we mean
@c ``a valid node number in @var{r}'s node table''.  Similarly for
@c @var{r}'s history.

Now that we've explained the form of the data, we make some restrictions
on that form.

@b{Every version has a root directory.}  Every version's node number is
a valid node number, and the node it refers to is always a directory.
We call this the version's @dfn{root directory}.

@b{Version 0 always contains an empty root directory.}  This baseline
makes it easy to check out whole projects from the repository.

@b{Directories contain only valid links.}
Every directory entry's @var{node} is a valid node number.

@b{Directory entries can be identified by name.}
For any directory @var{d}, every directory entry in @var{d} has a
distinct name.

@b{There are no cycles of directories.}  No node is its own child.

@b{Directories can have more than one parent.}  The UNIX file system
does not allow more than one hard link to a directory, but Subversion
does allow the analogous situation.  Thus, the directories in a
Subversion repository form a directed acyclic graph (@dfn{DAG}), not a
tree.  However, it would be distracting and unhelpful to replace the
familiar term ``directory tree'' with the unfamiliar term ``directory
DAG'', so we still call it a ``directory tree'' here.

@b{There are no dead nodes.}  Every node is a child of some version's
root directory.

@c  </jimb> ----------------------



@subsection API

@subsubsection Data Types

The filesystem API routines require and return a number of data types
specific to Subversion's model and schema.

@dfn{bool} is a simple Boolean value, used to indicate success or
failure.

A @dfn{user} is a username (presumed to be previously authenticated by
the network layer) which is attempting to perform a filesystem action.

A @dfn{path} refers to an absolute path in the Subversion filesystem,
e.g. @code{/trunk/gdb/i386.c}

A @dfn{proplist} is a list of properties (key/value pairs).

A @dfn{propname} is a particular property key.

A @dfn{propnamelist} is a list of all the keys in a proplist.

A @dfn{file} is a string of bytes that contains both a ``text stream''
and a ``property stream''.  The text stream contains the main contents
of the file, while the property stream decodes into a proplist.

A @dfn{directory entry} (@dfn{dirent}) points to a file or directory.

A @dfn{directory} (@dfn{dir}) is a list of directory entries.

A @dfn{filesystem object} (@dfn{fs_obj}) contains either a file or
a directory. 

A @dfn{version} (abbreviated @dfn{ver}) refers to a global version
number in a repository's history.

A @dfn{diff} is a standard GNU diff, a textual context diff.

A @dfn{delta} is a structure that describes a difference between two
file trees.  For a detailed discussion, @xref{Protocol}.

A @dfn{skelta} A @dfn{skelta} is the skeleton of a delta: while it does
indicate which files are changed, it does not describe the specific
changes to the files' text.  This datatype allows the filesystem to
detect conflicts between transactions before the client has computed or
transmitted the (possibly large) textual deltas.

A @dfn{token} is a token used to represent a write transaction in
progress.


@subsubsection Reading History

@table @code
@item ver latest (user)
 returns the latest global version of a repository's tree
@item proplist get_ver_proplist(user, ver)
  return all properties of a version
@item propnames get_ver_propnames(user, ver)
  return all property keys for a version
@item char *get_ver_prop(user, ver, propname)
  return the value of @emph{propname} for a version (such as the log message)
@end table


@subsubsection Reading Nodes

These are routines for retrieving information about the
properties of a file, dirent, or dir.

@table @code
@item fs_obj read (user, version, path)
 if path is a file, return full contents in fs_obj;@*
 if path is a directory, return list of directory entries in fs_obj
@item char *get_node_prop(user, ver, path, propname)
  return the value of @emph{propname} for a file or directory
@item char *get_dirent_prop(user, ver, path, propname)
  return the value of @emph{propname} for a directory entry
@item proplist get_node_proplist(user, ver, path)
  return all properties of a file or directory
@item proplist get_dirent_proplist(user, ver, path)
  return all properties of a directory entry
@item propnames get_node_propnames(user, ver, path)
  return all property keys for a file or directory
@item propnames get_node_propnames(user, ver, path)
  return all property keys for a file or directory
@item propnames get_dirent_propnames(user, ver, path)
  return all property keys for a directory entry
@end table


@subsubsection Difference Queries

@table @code
@item delta get_delta (user, versionX, pathX, versionY, pathY)
 return a delta object which converts subtree X into subtree Y
@item diff get_diff (user, versionX, pathX, versionY, pathY)
 return a diff between any two files in the repository
@item skelta status (user, skelta)
 walk the latest tree in the repository, compare to the skelta tree, and
 return any version differences in a new skelta
@item delta update (user, skelta)
 same as status, but returns a filled delta object
@end table


@subsubsection Writing

If a program needs to modify a repository's filesystem in any way (even
if just modifying properties), it must do three things:

@enumerate
@item
  Build a delta object, representing a group of changes against some
  base revision of a tree.
@item
  Request permission from the server to write the delta as a transaction.
@item
  If permission is granted, apply the delta.
@end enumerate

@table @code
@item token submit (user, skelta)
  ask filesystem's lock manager for approval of skelta; returns either a
  transaction token or failure.  A skelta is used so that the caller can
  check a transaction for conflicts without having to use text deltas.
@item ver write (user, delta, token)
  actually write the delta into the filesystem
@item bool abandon (user, token)
  tell lock manager that the delta will @emph{not} be written (despite
  previous approval)
@end table

A more detailed description of Subversion's write-locking mechanism is
explained in the next section.


@c -----------------
@subsection Locking

The Subversion Filesystem has a locking mechanism.

The locking mechanism deals with @dfn{readers} and @dfn{writers}.
Readers never have to wait for writers;  writer only have to wait for
other writers whose changes conflict with theirs.

@subsubsection Read Locks

Reading is easy; if a server process wants to execute a @code{read()}
call into the filesystem, it goes right through.  The design of the
versioning filesystem allows a reader to simply skip down the version
history, locate the correct "root" node, and then follow the particular
tree downwards to the file or directory it wishes to read.  Any number
of readers can follow this algorithm without interfering with another;
and because writers don't link to the version history until they're
finished writing everything, there's no way for a reader to accidentally
stumble upon an unfinished tree.

@subsubsection Write Locks

Each Subversion filesystem has a process called a @dfn{lock manager}.
The lock manager isn't always running; when a server process wishes to
execute a @code{write()} on the filesystem, it must first determine if a
lock manager is running.  If not, it creates one.

@example

                  D              /
                   \            /
                    \          /
                     |        /
                     v       /
       +--------------------|--------------+
       |                    v              |
       |             Approved?             |
       |                |                  |
       |                |                  |
       |                v                  |
       |          Concurrency Pool         |
       |       +--------------------+      |
       |       |     D            D |      |
       |       |  D        D   D    |      |
       |       +--------------------+      |
       +-----------------------------------+

@end example

After the lock manager is up, the server process first sends it a
@code{submit()} call containing the skelta it would like to write.

The lock manager contains a pool of "approved changes".  This pool is a
set of skeltas which have been okayed for concurrent application to the
filesystem.  After receiving a new skelta from @code{submit()}, the lock
manager determines if it is safe to apply it at the same time as the
other ones in progress.@footnote{This rule is actually quite simple: a
set of skeltas may be concurrently written @emph{if and only if} the
order in which they are applied does not matter!}

If the lock manager decides that the requested skelta conflicts it
returns a failure to the server, and the server must wait and try again
with another @code{submit()} request.

If the lock manager decides that the requested skelta does not conflict,
it returns a transaction token to the server.  The server then uses this
token to execute a @code{write()} on the filesystem.

After the @code{write()} is completed, the skelta is removed from the
lock manager's concurrency pool, and the server closes its connection.

When the lock manager has no more open server connections, it dies.

@subsection Implementation

For the initial release of Subversion,

@itemize @bullet
@item 
  The filesystem will be implemented as a library on UNIX.
@item
  The lock manager will communicate with other processes via UNIX domain 
  sockets.  
@item
  The filesystem's data will probably be stored in a collection of .db
  files, using the Berkeley Database library.@footnote{In the future, of
  course, contributors are free modify the Subversion filesystem to
  operate with more powerful SQL database.}  (For more information, see
  @uref{http://www.sleepycat.com, Sleepycat Software}.)
@end itemize


@c ----------------------------------------------------------------

@node Main Library
@section Main Library


@subsection Overview

@itemize @bullet
@item
  @b{Requires:}
  @itemize
  @item
    the Subversion Filesystem interface
  @end itemize
@item
  @b{Provides:}
  @itemize
  @item
    the ability to interact with any repository on a system
  @item
    the ability to enforce server-side ``policies'' (via a config file)
  @item
    the ability to load server-side ``plug-ins'' (via a config file)
  @end itemize
@end itemize


@subsection Multiplexing

The Main Subversion Library (@dfn{svn_main}), in its simplest sense,
acts a basic multiplexer for the repository API calls coming from the
Subversion client.  (@xref{The repository access library}.)

Specifically, note that all of the client's calls into the repository
begin with a @code{repos} argument.  The Main Subversion Library
provides the exact same API as the client repository library;  when it
receives the client's function call, it examines this argument, locates
a particular repository on disk, and then makes the filesystem
call.

@subsection Policy Enforcement


@subsection Plug-Ins

It's important that svn_main be extensible;  by allowing users to write
their own server-side libraries, the server's abilities can potentially
grow forever.

We define the term @dfn{plug-in} to refer to a library designed to be
loaded into svn_main's address space.  This term is used intentionally
(instead of "module") so as not to be confused with Apache modules.
Each plug-in can potentially implement a new set of server "methods"
(@xref{Methods}.)

When starting up, svn_main will read a configuration file @file{svn.conf}
(much like Apache's @file{httpd.conf}) which, among other things, will
specify a list of available plug-ins, the new methods they provide, and
their actual locations on disk.  If and when a client requests a
particular method, svn_main then knows which plug-in to "auto-load" as
necessary.

Here are some ideas for future plug-ins:

@itemize @bullet
@item
  @strong{annotate} : provides annotation of individual files (i.e. who
  wrote which line in which version).  This is a basic command in CVS,
  but is not critical for Subversion's first release.  By implementing
  it later as a plug-in, the command becomes much more customizable.
@item
  @strong{grep} : the ability to search the Subversion filesystem
  quickly for text or properties
@item
  @strong{guile} : a plug-in which provides glue between svn_main and
  libguile.so, thereby giving the Subversion server an extensible
  scripting language.  (This could also be done with @strong{perl} or
  @strong{python}.)
@end itemize

