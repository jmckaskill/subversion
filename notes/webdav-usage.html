<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Use of WebDAV in Subversion</title>
  </head>

  <body bgcolor=white>
    <h1>Use of WebDAV in Subversion</h1>

    <p>
      This document details how WebDAV is used within the
      <a href="http://subversion.tigris.org/">Subversion
      product</a>. Specifically, how the client side interfaces with
      <a href="http://www.webdav.org/neon/">Neon</a> to generate
      WebDAV requests over the wire, and what the
      server must do to map incoming WebDAV requests into operations
      against the Subversion repository. Note that the server side is
      implemented as an
      <a href="http://www.apache.org/httpd">Apache 2.0</a> module,
      operating as a back-end for its mod_dav functionality.
    </p>
    <p>
      This document heavily refers to the
      <a href="http://subversion.tigris.org/svn-design.html">Subversion
	design document</a> and the
      <a href="http://www.webdav.org/deltav/">latest Delta-V protocol
	draft</a>. Details of those documents will <em>not</em> be
      replicated here.
    </p>

    <h2>Basic Concepts</h2>
    <p>
      Subversion uses a tree-based format to describe a change set
      against the repository. This tree is constructed on the client
      side to describe the change. It is then marshalled to the
      server, reconstructed, and applied against the
      repository. However, WebDAV uses a sequence of changes. As a
      result, we must map from the tree form to a sequence of WebDAV
      requests, send them over the wire, then reconstruct the tree
      form on the server for application to the repository.
    </p>
    <p>
      In addition, Subversion applies a change set in two steps. It
      sends a "skeleton delta", or "skelta", to the server as a
      preflight test to check whether the change set can be
      applied. The server then returns a token to be passed back along
      with the final delta. The combination of a token and the
      complete delta completes the process, and the change set is
      applied to the repository.
    </p>
    <p>
      Subversion also provides properties on files, directories, and
      even the abstract concept of a version. Each of the operations
      involving properties will be mapped directly to WebDAV
      properties, which are manipulated with the <code>PROPFIND</code>
      and <code>PROPPATCH</code> HTTP methods. To enable properties on
      abstract versions, the Subversion Apache module will publish a
      URL namespace containing resources for each version. The
      per-version properties will be maintained on these resources.
    </p>
    <p>
      Subversion specifies that the server will compute deltas between
      two versions. Presumably, the server can create the delta much
      more efficiently than a client performing a sequence of
      <code>PROPFIND</code> requests. This feature will be implemented
      using the <code>DAV:compare-report</code> report option. If the
      client is performing an actual update, then a series of GET
      operations will be performed to fetch the files which have
      changed.
    </p>
    <p>
      Tags and branches are handled through the WebDAV
      <code>LABEL</code> and <code>COPY</code> methods as appropriate.
    </p>

    <h2>Subversion Projects as URLs</h2>
    <p>
      The very first concept to define is how a project is exposed to
      the client. Subversion will expose all projects as URLs on a
      server. The files and subdirectories under this project will be
      exposed through the URL namespace.
    </p>
    <p>
      For example, let us assume that we have a project named
      "example". And let us say that this project will be exposed at
      the URL: <code>http://subversion.tigris.org/example/</code>.
    </p>
    <p>
      This mapping will be set up through a set of configuration
      parameters for the Apache HTTPD server (which is hosting the
      Subversion code and the particular project in question). The
      configuration might look like:
    </p>
    <blockquote>
<pre>&lt;Location /example&gt;
    DAV subversion
    SVNPath /home/svn-projects/example
&lt;/Location&gt;</pre>
    </blockquote>
    <p>
      Files and directories within the project will be directly mapped
      to the URL namespace. For example, if the project contains a
      file "file.c" in a subdirectory "sub", then the URL for that
      file will be
      <code>http://subversion.tigris.org/example/sub/file.c</code>.
    </p>

    <h2>Committing a Change Set</h2>
    <p>
      Change sets are modelled using the "activity" concept from
      WebDAV. An activity can be viewed as a transaction for a set of
      resources.
    </p>
    <h3>Creating the activity</h3>
    <p>
      At the start of a commit, the client will issue a
      <code>REPORT</code> method for a
      <code>DAV:repository-report</code> to determine where the
      activity should be created. Next, the client will generate a
      UUID (a unique value) to use for the activity's
      location. Finally, the client will issue a
      <code>MKACTIVITY</code> method request, where the URL is
      composed from the URL returned by the
      <code>repository-report</code> and the UUID. The request will
      construct an activity to hold all of the changes for the commit.
    </p>
    <p>Abbreviated summary:</p>
    <dl>
      <dt>Request: REPORT, DAV:repository-report</dt>
      <dd>Response: http://www.example.com/$svn/act/</dd>
      <dt>Request: MKACTIVITY,
	http://www.example.com/$svn/act/01234567-89ab-cdef-0123-456789abcdef</dt>
      <dd>Response: 201, created</dd>
    </dl>
    <p>
      The (advanced) <code>CHECKOUT</code> method has a way to specify 
      an activity upon checkout. This feature will be used to
      associate all items with the newly-created activity.
    </p>
    
    <h3>Mapping changes to WebDAV</h3>
    <p>
      A change set in Subversion is specified with a "tree delta" (see
      the SVN design for more details on the changes that can be
      placed into a tree delta). The tree delta will be unravelled
      into a set of requests. These requests will be one of the
      following forms:
    </p>
    <dl>
      <dt>Delete file/directory</dt>
      <dd>
	This will be mapped to a <code>DELETE</code> operation. The
	target will be checked out using <code>CHECKOUT</code>, then
	the working resource will be deleted using
	<code>DELETE</code>.
	<p>
	  Note that the versioning protocol draft states the result of
	  deleting a working resource is undefined. Subversion will
	  define this as "the version selector corresponding to the
	  working resource will be deleted upon <code>CHECKIN</code>
	  (or <code>MERGE</code>)."
	</p>

	<p>
	  Note: this implicitly changes the directory containing the
	  deleted file/dir. These changes will be integrated at
	  <code>MERGE</code> time. Effectively, we are assuming the
	  directory has <code>DAV:auto-version</code> enabled on it,
	  allowing the change to the set of bindings within the
	  directory. It may turn out that we will need to perform a
	  <code>CHECKOUT</code> on the directory itself before doing
	  the <code>DELETE</code>.
	</p>
      </dd>

      <dt>New file</dt>
      <dd>
	This is modeled by performing a <code>CHECKOUT</code> on the
	target directory. The new file is created within the
	directory's working resource with a <code>PUT</code>, or a
	directory can be created there using a <code>MKCOL</code>
	request.

	<p></p>
      </dd>

      <dt>New file/directory, previous ancestory</dt>
      <dd>
	A tree delta can specify that a file/directory originates as a
	copy of another file/dir. Further, this copy may be modified
	by additional elements the tree delta.

	<p>
	  This change will be modeled by performing a
	  <code>CHECKOUT</code> on the directory containing the new
	  file/directory. A <code>COPY</code> of the version selector
	  (of the original file/dir) into the target directory will
	  establish the ancestry. The resource created by the
	  <code>COPY</code> will become a new working resource, thus
	  becoming a target for additional changes.
	</p>
      </dd>

      <dt>Replace file</dt>
      <dd>
	This is modeled with a <code>CHECKOUT</code> on the target
	file, followed by a <code>PUT</code> to the working resource.

	<p></p>
      </dd>

      <dt>Replace file with another file</dt>
      <dd>
	This operation is performed by using a <code>CHECKOUT</code>
	on the target, then using <code>COPY</code> to copy the source
	file (a version selector) over the working resource. The
	<code>COPY</code> establishes the proper ancestry for the
	file.
	<p>
	  Note that the source of the <code>COPY</code> is the version 
	  selector. This makes it possible to swap files arbitrarily
	  since the source (the version selectors) will not change
	  until <code>MERGE</code> time.
	</p>
      </dd>

      <dt>Replace directory</dt>
      <dd>
	In Subversion terms, "replace directory" means that additions, 
	deletions, and other changes will occur <em>within</em> the
	directory. Each of these changes are modeled individually, and 
	the change to the directory is performed
	implicitly. Therefore, this "change" has no particular mapping 
	into WebDAV.

	<p></p>
      </dd>

      <dt>Replace directory with another directory/file</dt>
      <dd>
	When a directory is <em>replaced</em>, rather than simply
	modified, we use the <code>COPY</code> method to copy a
	resource over the replaced directory. As usual, the directory
	to be replaced is checked out first, using
	<code>CHECKOUT</code>. The <code>COPY</code> will specify
	<code>Overwrite:&nbsp;T</code> header to overwrite the
	checked-out directory.

	<p></p>
      </dd>

      <dt>Property delta</dt>
      <dd>
	A property delta (against a file or directory) maps directly
	to a <code>PROPPATCH</code> in WebDAV terms. Before applying a 
	<code>PROPPATCH</code>, the target file/directory will be
	checked out using <code>CHECKOUT</code>
      </dd>
    </dl>

    <p>
      Note that file "moves" are modeled using <code>COPY</code> to
      establish the linkage between the new/old files/directories,
      followed by a <code>DELETE</code> to remove the old
      file/directory.
    </p>

    <h3>Skeleton Deltas</h3>
    <p>
      As mentioned above, Subversion uses a two-pass system during a
      commit. The first pass will create the activity, perform all the 
      necessary <code>CHECKOUT</code> operations, and then perform a
      number of <code>DELETE</code>, <code>COPY</code>, and
      <code>MKCOL</code> requests against the working resources. To
      keep the wire bandwidth small, <code>PROPPATCH</code> and
      <code>PUT</code> requests will be minimized:
    </p>
    <dl>
      <dt><code>PROPPATCH</code> skeleton</dt>
      <dd>
	To provide a quick test of whether a <code>PROPPATCH</code> is
	allowed against the target resource, the client will issue the
	<code>PROPPATCH</code> with a <code>DAV:remove</code> element
	for a custom, predefine Subversion property (which will never
	exist). This will "exercise" the access rights for property
	changes. At commit time, the property-delta will be mapped
	into a complete <code>PROPPATCH</code>.
	<p>
	  Note that DAV says it is okay to remove a property that
	  doesn't exist. Effectively, the removal of the property will 
	  always be a null operation.
	</p>
      </dd>

      <dt><code>PUT</code> skeleton</dt>
      <dd>
	The client will issue a zero-length <code>PUT</code> request
	against the working resource. When the final commit is
	performed, another <code>PUT</code> will be performed with the 
	entire file contents.
	<p></p>
      </dd>
    </dl>

    <h3>Final Commit</h3>
    <p>
      The final action of the commit process is to issue a
      <code>MERGE</code> request to the Subversion server, specifying
      that the activity (created earlier) be merged into the
      corresponding versioned resources.
    </p>

    <h3>Example</h3>
    <p>
      Consider the following set of operations and its corresponding
      tree delta (taken from the SVN design document):
    </p>
    <ol type=1 start=1>
      <li>rename <code>/dir1/dir2</code> to <code>/dir1/dir4</code>,</li>
      <li>rename <code>/dir1/dir3</code> to <code>/dir1/dir2</code>, and</li>
      <li>move <code>file3</code> from <var>/dir1/dir4</var> to <var>/dir1/dir2</var>.</li>
    </ol>
<pre>&lt;tree-delta&gt;
  &lt;replace name='dir1'&gt;
    &lt;directory&gt;
      &lt;tree-delta&gt;
        &lt;replace name='dir2'&gt;
          &lt;directory ancestor='/dir1/dir3'&gt;
            &lt;tree-delta&gt;
              &lt;new name='file3'&gt;
                &lt;file ancestor='/dir1/dir2/file3'/&gt;
              &lt;/new&gt;
            &lt;/tree-delta&gt;
          &lt;/directory&gt;
        &lt;/replace&gt;
        &lt;delete name='dir3'/&gt;
        &lt;new name='dir4'&gt;
          &lt;directory ancestor='/dir1/dir2'&gt;
            &lt;tree-delta&gt;
              &lt;delete name='file3'/&gt;
            &lt;/tree-delta&gt;
          &lt;/directory&gt;
        &lt;/new&gt;
      &lt;/tree-delta&gt;
    &lt;/directory&gt;
  &lt;/replace&gt;
&lt;/tree-delta&gt;
</pre>

    <p>
      Walking through this delta, we map out the following WebDAV
      requests:
    </p>
    <ul>
      <li>
	The <code>&lt;directory ancestor="/dir1/dir3"&gt;</code>
	specifies that we are overwriting <code>/dir1/dir2</code> with 
	<code>/dir1/dir3</code>.
	<p>
	  <code>CHECKOUT&nbsp;/dir1/dir2</code><br>
	  <i>(returns a working resource URL for the directory)</i>
	</p>
	<p>
	  <code>COPY&nbsp;/dir1/dir3</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/...</code><br>
	  <code>Overwrite:&nbsp;T</code>
	</p>
      </li>
      <li>
	<code>/dir1/dir2/file3</code> is new (since we just overwrote
	the original <code>dir2</code> directory), and originates from
	<code>/dir1/dir2/file3</code>. Thus, we simply
	<code>COPY</code> the file into the target directory's working 
	resource:
	<p>
	  <code>COPY&nbsp;/dir1/dir2/file3</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/.../file3</code>
	</p>
      </li>
      <li>
	<code>CHECKOUT&nbsp;/dir1/dir3</code><br>
	<i>(returns a working resource URL for the directory)</i>
	<p>
	  <code>DELETE&nbsp;/$svn/wr/...</code>
	</p>
      </li>
      <li>
	We are going to  creating a new subdirectory (<code>dir4</code>) in the
	<code>/dir1</code> directory. Since we don't have
	<code>/dir1</code> checked out yet, we do so:
	<p>
	  <code>CHECKOUT&nbsp;/dir1</code><br>
	  <i>(returns a working resource URL for the directory)</i>
	</p>
	<p>
	  And now we copy the right directory into the new working
	  resource:
	</p>
	<p>
	  <code>COPY&nbsp;/dir1/dir2</code><br>
	  <code>Destination:&nbsp;http://www.example.com/$svn/wr/.../dir4</code>
	</p>
      </li>
      <li>
	The <code>COPY</code> created a complete set of working
	resources on the server, so we simply delete the part that we
	don't want:
	<p>
	  <code>DELETE:&nbsp;/$svn/wr/.../dir4/file3</code>
	</p>
      </li>
    </ul>

    <h2>URL Layout</h2>
    <p>
      ...
      /$svn/act/  hold activity info
      /$svn/wr/   hold working resources
      /$svn/ver/  hold version resources
      /$svn/his/  hold history resources
    </p>

    <h2>Property Management (and History/Log Reporting)</h2>

    <h2>Fetching Status and Updates</h2>

    <h2>Tags and Branches</h2>

    <h2>Server Requirements</h2>
    <p>
      <code>DAV:repository-report</code>
      <br>
      Retain activity information. Activities have user-specified
      names, mapping to the server-side records. Advanced CHECKOUT to
      associate an activity with the working resource. COPY into a
      checked-out collection must create new working resources
      (recursively). Add SVN:test-proppatch (live) property.
    </p>
    <p>
      Discuss timeouts and auto-purge of activities (and the related
      working resources).
    </p>

    <hr>
    <address><a href="mailto:gstein@lyra.org">Greg Stein</a></address>
<!-- Created: Thu Aug 10 19:14:20 PDT 2000 -->
<!-- hhmts start -->
Last modified: Mon Aug 14 18:48:43 PDT 2000
<!-- hhmts end -->
  </body>
</html>
