
                    LIBSVN_WC : TRANSPARENT SUBSTITUTIONS


NEW USER-VISIBLE FEATURES:

  1.  keyword expansion

      A certain pattern in a file can be 'replaced' with dynamic
      content, such as an author or date.

  2.  newline conversion

      Text files in the working copy can (optionally) automatically
      have the client's 'native' line-endings.      


DESIGN GOAL

 * Purely client-side substitutions.

    The repository stores data, pure and simple.  It has no
    'preferred' format, and it's -not- going to change data moving in
    and out of the filesystem, period.  This is a libsvn_wc change
    only.

    - Ramification: this means that all working copy 'text-bases' are
      going to be exactly identical to one another: that is, it will
      be exactly equal to whatever is in the repository. The
      repository will continue to use binary-diffs over the wire.

       - Sub-Ramification: svn_wc_text_modified_p() is going to have
         to intelligently overlook these differences when comparing
         text-bases with working files that have been 'converted'.

       - Sub-Ramification: the conversions need to happen at the right
         times, so that our calls to 'diff' and 'patch' work correctly.



HOW TO KNOW WHEN A FILE IS TEXT

Working proposal, based on status quo:

 * a file is text iff it has a mime-type property of 'text/*', OR if it
   has no mime-type property at all.  (binary files are currently
   being detected and marked as type 'application/octet-stream'.)




I. NEWLINE CONVERSION

  A. HOW TO TOGGLE NEWLINE CONVERSION

     Newline conversions only happen on text files.

     Our experience is that most people want newline conversion.
     Therefore, this feature is "on" by default.  It can be turned off
     using a file property.

     (Later, if we need to, we can deactivate via directory
     properties, and maybe even inheritance rules.  But let's not go
     there yet.)


  B. HOW A CLIENT DOES NEWLINE CONVERSION
 
     [ History:  

      * Gstein and Pilchie proposed per-directory default line-ending styles.
      * Karl proposed something differerent.
      * Branko gave the 'newest' proposal...

       (Latest proposal by Branko, agreed to by Ben, Karl and Greg Hudson:) ]

    - all text files have a "line-ending-style".  Specifically, this
      property means: "the style that that file has in the
      repository."

       - a line-ending-style can be explicitly given via file property:

             'svn:line-ending-style : DOS', etc.

       - define a 'default' line-ending style to SOME convention that
         ALL clients agree upon.  *** If no line-ending-style property
         is set, this is the style that the text file is assumed to
         have. ***

    - When updating/checking out, the client looks at the file's
      line-ending-style.  If it doesn't match the client app's
      'native' style, it is silently converted when copying from
      text-base to the user-visible work area.

    - When committing, if working file's style doesn't match the
      file's official line-ending-style, then a converted copy will be
      sent to the repository.

    - See DESIGN section; svn_wc_text_modified_p, diff, and patch all
      need to be aware of this process.



II.  KEYWORD EXPANSION

  A. HOW TO TOGGLE KEYWORD EXPANSION

     Our experience is that most people do *not* want keyword
     expansion every day; most users are unaware of it, and tend to
     get bitten by it.  When it's wanted, it's usually only wanted on
     selected files.  Therefore, this feature is "off" by default.  It
     can be turned on using a file property.

     Also note: as Branko requestss, nothing prevents a user from
     activating keyword expansion on a 'binary' file.  A file's
     mime-type is irrelevant.

  B. HOW A CLIENT DOES KEYWORD EXPANSION
 
     - When updating/checking out, the client looks to see if the
       keyword-expansion property is 'on'.  If so, then the file has
       keywords substituted when copying from text-base to the
       user-visible work area.

     - When committing, if the property is 'on', then an
       un-substituted copy will be sent to the repository.

     - See DESIGN section; svn_wc_text_modified_p, diff, and patch all
       need to be aware of this process.

  C. KEYWORDS

       - $LastChangedRevision$

           expands to the revision in which this file last changed.
           (really, this is the 'created revision' in the node-rev-id)

       - $LastChangedDate$

           expands to the date when LastChangedRevision was created.

       - $LastChangedBy$

           expands to the author of the LastChangedRevision, i.e. the
           last person to have committed this file.

       - $HeadURL$

           expands to a public URL that points to the 'latest' version
           of this file.  (This is a nice side bonus of using DAV!)


-------------------------------

How Ben Will Implement Keyword Expansion


Phase 1:  gathering the values of the keywords.

  ** UPDATES:  This is when keywords get expanded.

  - Ontology:   there are THREE kinds of props that a working copy can
                receive during an update:

                  - user props.  these are visible and meant to be
                    tweaked by users.  (dav calls these 'dead' props).

                  - wcprops.  this is metadata that the working copy
                    secretly caches on behalf of particular ra layers,
                    or any program that uses the alternate API in
                    libsvn_wc to get/set them.  called 'wcprops'
                    because they never exist in the repository.

                  - entry props.  this is metadata that needs to be
                    stored, but is too specific to the update-use-case
                    to be included as general arguments to Editor
                    calls.  this metadata ends up in the entries file,
                    also invisible to users.  

     It's important to note that only the update-editor understands
     these three types of props (by examining svn: namespaces).  A
     typical 'generic' editor just assumes all properties that move
     through are typical user-props.  Our various commit editors are
     like this.

   - the update editor parses for these different types of props, and
     routes their storage appropriately.

   - the trace editor only asks the question:  is it a *user* prop?
     otherwise the prop is ignored.

   - the RA layer now needs to send 'entry' props when driving the
     update editor.  Specifically, each file and directory will
     receive three new entry attributes: lastchangedrevision,
     lastchangeddate, lastchangedauthor.  (bikeshed these names
     later.)

   - do the keyword substitution if turned 'on' for the file. (details omitted)

   - the entries file now has three new pieces of nifty information;
     'svn st -v' might want to use them someday!


  ** COMMITS:  expanded keywords need updating here too.

   - when the commit is finished, the RA layer uses a 'bump_func'
     callback to bump the committed targets with the newly created
     revision.  The 'bump_func' prototype is going to need to expand,
     so that can set a date and author as well.  Pretty simple.

   - if a committed target has a relevant keyword, it should be
     re-expanded in place (during the bumping)



--------------------------------

Greg's EOL system.

Assume the EOL-style property means "desired style of file in the
working copy".  (The former meaning was "style of file in the
repository.")  If this property is not present, then the application
assumes that the file's desired EOL-style is whatever is 'native' to
the application's OS.

The text-base still reflects exactly what is in the repository.

1.  When the user commits a file, the *exact* contents of the working
    file is sent to the repository.  (Yes, this means a lot of
    flip-flopping in the repository, and larger-than-necessary binary
    diffs both over the wire and in the repo.  But also means that
    data can never be corrupted, ever.)

2.  When user checks out a file, a 'translated' copy of text-base is
    provided as the working file.  (Note: the working copy doesn't
    know what style text-base has; instead, it just always attempts to
    convert text-base to the file's desired EOL-style.  This
    translation might be a no-op.)

3.  When the user updates a file and a merge is necessary, here's what
    happens.  The new text-base arrives.  Then both the old and new
    text-bases are blindly copied & translated into the desired
    EOL-style, and a context diff is produced.  (Either or both
    translations might be no-ops.)  The copies are then tossed, and
    the context diff is applied to the working file.  The new
    text-base replaces the old text-base.

4.  The same logic as in #3 applies to any situation where we ever
    want to examine the text-base:

     - To see if the user made a local mod, we compare a *translated*
       copy of text-base with the working file.

     - To compare two arbitrary revisions of a file, we must always
       compare translated copies of them.
 

----------------------

Bruce's system


Go back to first proposal. No more flip-flopping of repository line styles.

EOL-style property is one of:  'native' or 'none'.

For checkout/update, client automatically translates all working files
to client's "preferred" OS style.  

For commit, de-translate back to EOL-property IFF a translation was
done on checkout/update.  For *initial* add/commit of file, this is
never done;  file is literally committed.


--------------------------

dos->unix: tr -d '\015'
dos->mac:  tr -d '\012'
unix->dos: tr '\012' '\015\012'
unix->mac: tr '\012' '\015'
mac->unix: tr '\015' '\012'
mac->dos:  tr '\015' '\015\012'