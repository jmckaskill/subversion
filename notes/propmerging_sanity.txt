
When merging property lists together during 'svn up' and 'svn merge',
things can get tricky.  In the case of file texts, we have a nice
diff3 algorithm to do a 3-way merge for us.  But for properties,
libsvn_wc needs to do the 3-way merge itself.  This document explains
what's going on.


'svn update'
-------------

The old-baseprops live in .svn/.

During update, the server sends a bunch of 'propset' commands of the
form {name, val}.  (val == NULL implies a deletion.  If name doesn't
already exist, it implies an addition.)

The propsets are applied to old-baseprops, producing new-baseprops.

Meanwhile, the user may have made local edits to the workingprops.

So our ancestry diagram looks like:

                     old-baseprops
                    /             \
 (server-propsets) /               \ (local-edit-propsets)
                  /                 \
                 v                   v
          new-baseprops             workingprops


Because the old-baseprops are a common ancestor, the 3-way merge
algorithm is relatively simple.  All we need to do is compare two
lists of 'propsets':

    1. the propset list sent from the server (which transforms
       old-baseprops into new-baseprops)

    2. the propset list representing local edits (which transforms
       old-baseprops into workingprops)

If there are no local edits at all (i.e. the 2nd list is empty), then
we simply apply the first list to workingprops, and we're done.  No
conflicts can possibly happen; the common ancestor here guarantees
that workingprops and new-baseprops will be identical when we're done.

If there are local edits (i.e. the 2nd list is non-empty), then

       foreach propset in server-propsets:
          if propname exists in localedit-propsets:
             compare intentions of the 2 propsets, possibly mark conflict.
          else:
             apply propset to workingprops.

Note that because of the common ancestor here, the *only way* property
conflicts can happen is if local-mods are present.



'svn merge'
-----------

This is a harder problem, because we're not guaranteed a common
ancestor.

During the merge command, the server sends the complete list of
old-baseprops from the 'left' side of the merge, as well as a list of
propsets which can be applied to get the new-baseprops (which
represent the 'right' side of the merge):

                old-baseprops
                    |
                    |  (server-propsets)
                    |
                    v
                new-baseprops

But the target of the merge could be *anything*.  It has a completely
unrelated set of baseprops, no common ancestor.


     old-baseprops                    target-baseprops
          |                                 |         
          |  (server-propsets)              |  (localedit-propsets)
          |                                 |                      
          v                                 v
     new-baseprops                      workingprops


So for a correct 3-way merge, our algorithm needs to be different.  We
can't blindly apply the server propsets to the workingprops, we need
to carefully look at the server-propsets as *deltas*, noticing the
"from" and "to" values.

For example, a server-propset might "set foo=apple", where the
original value (in old-baseprops) was "banana".  The workingprops may
not contain any local mods at all, but nevertheless, if
target-baseprops already contains "foo=grape", then we should flag a
conflict!

So I guess the upshot here is that while 'svn update' can *only*
produce conflicts when local-mods are present, 'svn merge' can produce
conflicts anytime, even in the absence of local-mods.

The 'svn merge' 3-way property merging algorithm should look like:


      foreach propset in server-propsets:

         /* we have old-baseprops, so we can do this */
         convert into propdelta of the form (PROPNAME, FROM, TO).

         if FROM == NULL:  /* adding a new property */

            if PROPNAME doesn't exist in target-baseprops:
               apply change, unless existing local-mod conflicts.

            else:
               conflict: "property already exists"

         else: /* FROM != NULL -- changing or deleting a property */

            if PROPNAME doesn't exist in target-baseprops:
               conflict: "skipped property, it doesn't exist"

            else:  /* PROPNAME exists in target-baseprops */

               if (value of PROPNAME in target-baseprops) != FROM:
                  conflict:  "property has different base-value"
                  ### SEE FOOTNOTE!

               else:  /* same value */
                  apply change, unless existing local-mod conflicts.
           

### FOOTNOTE:

    Our 'svn merge' diagram really suggests using a diff4 algorithm,
    rather than diff3.  

    What should we do in the case of a server-propset attempting to
    change PROPNAME from A to B, while the user has locally changed
    the same PROPNAME from C to B?

    The algorithm above suggests that because the two starting values
    (A and C) are unequal, we should flag a conflict.  But our current
    diff3 algorithm on lines-of-text may actually not care about the
    target base; it might produce a smooth merge because the *results*
    are the same.

    Need to discuss this more.  What does our textual diff3 actually
    do?  And is it a good thing to imitate?
