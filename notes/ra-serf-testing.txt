For the 1.7 release, ra_serf grew a new internal feature to "pause"
the parsing of (large) XML response bodies. This file intends to
document the strategy for testing this new feature.

[ We've simply shipped more invasive and difficult code before.
  However, due to the current attempts to stabilize, and the near-ness
  of our 1.7.x branch... it seems warranted to apply a bit of
  testing.  ]


TESTING STRATEGY

It may be possible to arrange for writing a white box test, but I'll
leave that to somebody with a more masochistic bent. This section will
outline the different scenarios to test, and then how we can adjust
the various control parameters to make that happen.

There are seven states to the PENDING structure:

  1) pending == NULL

     No pause has (ever) occurred, OR no content has arrived since
     the parser was paused.

  2) pending->head == NULL && pending->spill == NULL

     This should only happen when some data has been placed into the
     pending membuf structure, then emptied.
     
     The parser may be paused and no content has arrived (yet), or
     the parser is not in a paused state.

  3) pending->head != NULL && pending->spill == NULL

     A pause occurred, and some content was placed into the
     membuf. Not enough to spill to a file, however.
     
     The parser may be paused, or not-paused.

  4) pending->head != NULL && pending->spill != NULL. content in file
  
     Enought content has orrived during a paused state that it was
     spilled into a file. Playback of the pending content *may*
     have occurred, but it has not (yet) emptied the memory buffer.
     
     The parser may be paused, or not-paused.

  5) pending->head != NULL && pending->spill != NULL. no content in file

     THEORETICAL.
     
     If a spill file gets created, then *some* content will be
     written into the file. The content will not be read/removed
     from the file until the memory buffer is exhausted. Thus, this
     state is not possible since the spill file could not be
     emptied since the membuf has not been emptied.
     
     Also, once the spill file has been created, we will never
     write into the memory buffer (for ordering reasons). Thus, we
     cannot empty both membuf and spill file, and place more
     content into the memory buffer.
     
     At some point in the future, we may decide to place arriving
     content back into the membuf after the spill file has been
     exhausted. The code does not do this today.
     
     The parser may be paused, or not-paused.

  6) pending->head == NULL && pending->spill != NULL. content in file

     At some point, enough content arrived to construct a spill
     file. Since that point, the memory buffer contents have been
     injected into the parser, emptying the membuf.
     
     The parser may be paused, or not-paused.

  7) pending->head == NULL && pending->spill != NULL. no content in file

     At some point, enough content arrived to construct a spill
     file. Since that point, all content (from memory and file) has
     been injected into the parser.
     
     The parser may be paused, or not-paused.

Note that all states are doubled, based on the PAUSED flag.

There are four operations that occur:

  1) network content is present
     a) If parser is paused, then append content to PENDING. All six(*)
        PAUSED states must be considered.
     b) If parser is NOT paused, then:
        i) If PENDING contains data, then append content to
           PENDING. Three of the NOT-PAUSED states must be
           considered: (3), (4), (6)
        ii) PENDING is empty, so inject content into the parser

  2) network content is not present [at this time]
     a) Exit network processing. The PENDING states are irrelevant.

  3) network content completed
     a) Exit network processing. The PENDING states are irrelevant.

  4) process content from the pending structures
     a) When parser is NOT paused, and PENDING contains data, then
        take content from the start of PENDING and inject it into the
        parser. Three of the NOT-PAUSED states must be considered:
        (3), (4), (6)


(*) we don't need to test state (5).



INDIVIDUAL TESTS

Normal operation will cover: 1(b)(ii), (2), and (3). Thus, we must
arrange to test:

  1) operation 1(a) with six states
  2) operation 1(b)(i) with three states
  3) operation 4(a) with three states


TEST 1.1

A simple pause with arriving data will test this.

Exits in state (3).


TEST 1.2

TEST 1.3

TEST 1.4

TEST 1.6

TEST 1.7

TEST 2.3

TEST 2.4

TEST 2.6

TEST 3.3

TEST 3.4

TEST 3.6


These combine into the following test scenarios to exercise the two
actions against each of the ten data states.

  #### redo this list


  1) REPORT completes with no pausing
  2) REPORT requires in-memory (only) buffering:
     a) buffer empties while network content arrives again
     b) network content completes while buffer has content
     c) buffer empties, then later needs buffering again
     d) partial in-mem consumption, new content lands into membuf
  3) REPORT requires on-disk buffering:
     a) diskbuf empties while network content arrives again
     b) network content completes while diskbuf has content
     c) diskbuf empties, then more buffering is needed again
        (note: due to the code, this will go onto the disk rather
         than back to the in-mem buffer)
     d) partial in-mem consumption, new content lands in diskbuf
     e) partial diskbuf consumption, new content lands in diskbuf
