
                               -*- text -*-

                          TREE CONFLICT DETECTION


Issue reference:  http://subversion.tigris.org/issues/show_bug.cgi?id=2282


This file describes how tree conflicts described in use-cases.txt
can be detected. It documents how detection currently works in the
actual code, and also explains the limits of tree conflict detection
imposed by Subversion's current design.

The current implementation has imperfect tree conflict detection,
but it is still better than not handling tree conflicts at all.
Once Subversion has been taught about true renames, tree conflict
detection can be changed to make use of this and become extremely
precise.  See below for further explanation.

==========
USE CASE 1
==========

Files:

If 'svn update' modifies a file that has been scheduled for deletion
in the working copy, the file is a tree conflict victim.

Directories:

If 'svn update' modifies any item (including adding or deleting a file
or directory) in a directory that has been scheduled for deletion in
the working copy, each item modified by the update is a tree conflict
victim.  

Our tree conflict detection will be part of the update's crawl of the
working copy.

The persistent conflict data will be stored in the metadata of the
parent of the directory scheduled for deletion.

==========
USE CASE 2
==========

Files:

If 'svn update' deletes a file that has local modifications, the file
is a tree conflict victim.

Directories:

If 'svn update' deletes a directory that has local modifications
(including items scheduled to be added or deleted), each locally
modified item is a tree conflict victim. 

The update crawls the to-be-deleted directory tree before actually
deleting it.  Subversion metadata and unmodified files are deleted,
and any locally-modified files are preserved.  We would like to
piggyback our tree conflict detection code onto this existing crawl.

The persistent conflict data will be stored in the metadata of the
parent of the directory deleted by the update.

==========
USE CASE 3
==========

Files:

If 'svn update' deletes a file that has been scheduled for deletion in
the working copy, the file is a tree conflict victim.

Directories:

If 'svn update' deletes a directory that has been scheduled for
deletion in the working copy, the directory is a tree conflict victim.

==========
USE CASE 4
==========

We skip tree conflict detection if the record_only field of the
merge-command baton is TRUE. A record-only merge operation updates
mergeinfo without touching files.

Files:

If 'svn merge' tries to modify a file that does not exist in the
target working copy, then the target file is a tree conflict victim.

Notes on Resolution
-------------------

Often, the target file has been renamed in the history of the working
copy's branch. It would be handy if the user could run 'svn merge'
again, specifying which file should receive the incoming diff. This is
the "ELSEWHERE" scenario discussed in
notes/tree-conflicts/resolution.txt.

A similar situation occurs if the source diff doesn't cover as many
revisions as it should. Either the range of the source diff should be
extended to include the revision that created the file, or the range
should be reduced to avoid including any revisions that modify the
file.

However, the current plan is to disallow merges into tree-conflicted
directories. This means that users will first have to mark the
tree-conflict around the missing victim as resolved before attempting
to merge the file again. This work flow may be awkward, but has the
benefit of ensuring that no missing files are overlooked while
merging.


Directories:

If 'svn merge' tries to modify a directory that does not exist in the
target working copy, then the target directory is a tree conflict victim.

==========
USE CASE 5
==========

We skip tree conflict detection if the record_only field of the
merge-command baton is TRUE. A record-only merge operation updates
mergeinfo without touching files.

Files:

If 'svn merge' deletes an existing file, the file is a tree conflict
victim if its text is different from the corresponding file on the
left side of the merge source. The merge-left source file will be
compared to the "WORKING revision", which includes uncommitted local
changes.

Rationale:

We don't want to flag every file deletion as a tree conflict.  We
want to warn the user if the file to be deleted locally is different
from the file deleted in the merge source.  The user then has a chance
to merge these unique changes.

Implementation:

Call svn_client_diff_summarize2() to compare the target file to the
file at the left side of the merge source.


Directories:

If 'svn merge' deletes an existing directory, the directory is a tree
conflict victim if its content is different from the corresponding
directory on the left side of the merge source.

See the "NOTES ON DIRECTORIES" section for details on what it means
for a directory to be "different".

==========
USE CASE 6
==========

We skip tree conflict detection if the record_only field of the
merge-command baton is TRUE. A record-only merge operation updates
mergeinfo without touching files.

Files:

If 'svn merge' tries to delete a file that does not exist in the
target working copy, then the target file is a tree conflict victim.

This is similar to UC4.

Rationale:

Semantically, a tree conflict occurs if 'svn merge' either tries to apply
the "delete" half of a "move" onto a file that was simply deleted in the
target branch's history, or tries to apply a simple "delete" onto a file
that has been moved in the target branch, or tries to move a file that
has already been moved to a different name in the target branch. 

Notes on Resolution
-------------------

Some users may want to skip the tree conflict and have the result automatically
resolved if two rename operations have the same destination, or if a file is
simply deleted on both branches. But we have to mark these as tree conflicts
due to the current lack of "true rename" support. It does not appear to be
feasible to detect more than the double-delete aspect of the move operation.

Directories:

If 'svn merge' tries to delete a directory that does not exist in the
target working copy, then the target directory is a tree conflict victim.

=========================
OBSTRUCTIONS DURING MERGE
=========================

Files:

If 'svn merge' fails to apply an operation to a file because the
file is obstructed (i.e. an unversioned item of the same name is
in the file's place), the obstructed file is a tree conflict victim.

Directories:

If 'svn merge' fails to apply an operation to a directory because the
directory is obstructed (i.e. an unversioned item of the same name is
in the directory's place), the obstructed directory is a tree conflict
victim.

Rationale for both files and directories:

We want to make sure that a merge either completes successfully
or any problems found during a merge are flagged as conflicts.
Skipping obstructed items during merge is no longer acceptable
behaviour, since users might not be aware of obstructions that were
skipped when they commit the result of a merge.

====================
NOTES ON DIRECTORIES
====================

===========================
Modification of directories
===========================

How do we define a modification of a directory?

A directory with no subdirectories has been modified if any changes
were made to files and properties inside the directory, or if any
files or directories were added or deleted inside it.

A directory with subdirectories has been modified if any changes
were made to files and properties inside the directory, or if any
files or directories were added or deleted inside it, of if any
subdirectories were modified.

=======================
Equality of directories
=======================

How do we define equality between directories?

Two directories with no subdirectories are equal if they
contain the same files with the same content, and the
same properties with the same content.

Two directories with subdirectories are equal if they
contain the same files with the same content, and the
same properties with the same content, and all their
subdirectories are equal.

How can this be implemented?

For each directory, it could retrieve the corresponding dir entry from
the repository as it existed in the merge-left source of the merge,
and compare the two for equality, i.e. check whether all fields in
the svn_dirent_t returned by the repo match their corresponding
attributes of the directory as found in the working copy.

The left-merge revision shall be a new additional parameter to
merge_dir_deleted(). The ra session needed to contact the repository
via the get_dir() method is already contained in the merge baton which
is passed to merge_dir_deleted().

The last two paragraphs were taken from:
http://subversion.tigris.org/servlets/ReadMsg?listName=dev&msgNo=136794

=======================================
Deep tree conflict example (use case 1)
=======================================

In a working copy, a directory named B is scheduled for deletion.
Running 'svn status' lists the entire tree rooted at B.

  D      A/B/E/alpha
  D      A/B/E/beta
  D      A/B/E
  D      A/B/F
  D      A/B

Running 'svn status -uq' warns that the repository contains changes to
the locally-deleted directory.

  D      *        1   A/B
  Status against revision:      2

Updating the working copy modifies one file, deletes another file,
deletes a directory, and adds a file and a directory.

  U    A/B/E/alpha
  D    A/B/E/beta
  A    A/B/E/gamma
  D    A/B/F
  A    A/B/G
  C    A

The 5 tree conflicts revealed by the update are recorded in the
metadata of directory A.  They are described by 'svn info'.

  The update attempted to edit 'A/B/E/alpha'.
  You have deleted or renamed 'A/B' locally.

  The update has deleted 'A/B/E/beta'
  (possibly as part of a rename operation).
  You have deleted or renamed 'A/B' locally.

  The update has added 'A/B/E/gamma'
  You have deleted or renamed 'A/B' locally.

  The update has deleted 'A/B/F'
  (possibly as part of a rename operation).
  You have deleted or renamed 'A/B' locally.

  The update has added 'A/B/G'
  You have deleted or renamed 'A/B' locally.

Note:  The wording of the warnings is not yet settled.

What is the current state of the working copy?

* F and beta are completely gone from the working copy because they
  don't exist in the target revision.

* B, E, and alpha are still scheduled for deletion.

* The update's edit to alpha was applied to the "pristine copy" hidden
  in A/B/E/.svn/text-base, for use by the diff and revert commands.

* The newly-added G and gamma are not scheduled for deletion, but will
  be deleted if the user commits the deletion of B.

* Any commit of A (including any commit in a parent directory or
  subdirectory of A) will be blocked by the tree conflicts.

Except for the blocked commit (and the output of update, status, and
info) the behavior is the same as Subversion 1.5.

Technical note: In a deep tree conflict, the action target is not the
tree conflict victim.  We'll have to populate the 'path' field in the
conflict struct, which we haven't done before.  The functions that
record tree conflict data must accept the extra path argument
for the action.  The functions that create readable tree conflict
descriptions must use the 'path' field when describing the action.

=========================================
TREE CONFLICT DETECTION WITH TRUE RENAMES
=========================================

To properly detect the situations described in the "diagram of current
behaviour" for use case 2 and 3, we need to have access to a list of
all files the update will add with history.

For use cases 1 and 3, we need a list of all files added locally with
history.

We need access to this list during the whole update editor drive.
Then we could do something like this in the editor callbacks:

      edit_file(file):

        if file is locally deleted:
          for each added_file in files_locally_added_with_history:
            if file has common ancestor with added_file:
              /* user ran "svn move file added_file" */
              use case 1 has happened!

      delete_file(file):

        if file is locally modified:
          for each added_file in files_added_with_history_by_update:
            if file has common ancestor with added_file:
              use case 2 has happened!

        else if file is locally deleted:
          for each added_file in files_added_with_history_by_update:
            if file has common ancestor with added_file:
              use case 3 has happened!

Since the update editor drive crawls through the working copy and the
callbacks consider only a single file, we need to generate the list
before checking for tree conflicts.  Two ideas for this are:

        1) Wrap the update editor with another editor that passes
           all calls through but takes note of which files the
           update adds with history. Once the wrapped editor is
           done run a second pass over the working copy to populate
           it with tree conflict info.

        2) Wrap the update editor with another editor that does
           not actually execute any edits but remembers them all.
           It only applies the edits once the wrapped editor has
           been fully driven. Tree conflicts could now be detected
           precisely because the list of files we need would be
           present before the actual edit is carried out.

Approach 1 has the problem that there is no reliable way of storing
the file list in face of an abort.

Approach 2 is obviously insane. ;-)

Keeping the list in RAM is dangerous, because the list would be lost
if the user aborts, leaving behind an inconsistent working copy that
potentially lacks tree conflict info for some conflicts.

The usual place to store persistent information inside the working
copy is the entries file in the administrative area. Loggy writes to
this file ensure consistency even if the update is aborted.  But
keeping the list in entries files also has problems: Which entries
file do we keep it in? Scattering the list across lots of entries
files isn't an option because the list needs to be global.  Crawling
the whole working copy at the start of an update to gather lost file
lists would be too much of a performance penalty.

Storing it in the entries file of the anchor of the update operation
(i.e. the current working directory of the "svn update" process) is a
bad idea as well because when the interrupted update is continued the
anchor might have changed. The user may change the working directory
before running "svn update" again.

Either way, interrupted updates would leave scattered partial lists of
files in entries throughout the working copy. And interrupted updates
may not correctly mark all tree conflicts.

So how can, for example, use case 3 be detected properly?

The answer could be "true renames". All the above is due to the fact
that we have to try to catch use case 3 from a "delete this file"
callback. We are in fact trying to reconstruct whether a deletion
of a file was due to the file being moved with "svn move" or not.

But if we had a callback in the update editor like:

        move_file(source, dest);

detecting use case 3 would be extremely simple. Simply check whether
the source of the move is locally deleted. If it is, use case 3 has
happened, and the source of the move is a tree conflict victim.

Use case 2 could be caught by checking whether the source of the move
has local modifications.

Use case 1 could be detected by checking whether the target for a file
modification by update matches the source of a rename operation in the
working copy. This would require storing rename information inside the
administrative areas of both the source and target directories of file
move operations to avoid having to maintain a global list of rename
operations in the working copy for reference by the update editor.

