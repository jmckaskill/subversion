Last updated: $Date: 2001-04-17 21:17:04 $

Please review, folks.  I'm planning to start on implementation of
section (a) right away, and then consider (b) and (c) more carefully
after (a) is done.

Three related things that need to happen in the filesystem before we
get to alpha:

   a) File contents need to be moved into a separate table.

   b) We need to operate on file contents without holding the entire
      contents in RAM.  Berkeley DB gives us tools to operate on
      regions within a value, we just need to use them.

   c) We need to do reverse-delta storage in the filesystem (with
      checksums).


a) File contents need to be moved into a separate table.
========================================================

There is a new table, `strings'.  The keys are numbers (or whatever --
the point is, they're not node rev IDs), and the values are, well,
strings.  A string may represent a skel, or it may simply be the
contents of a file.  Since Berkeley keeps track of length for us
anyway, there's no point using skels for straight file contents.

Before we go on, here's some background from `structure':

   ! NODE-REVISION and HEADER: how we represent a node revision
   ! 
   ! We represent a given revision of a file or directory node using a list
   ! skel (see skel.h for an explanation of skels).  A node revision skel
   ! has the form:
   ! 
   !     (HEADER KIND-SPECIFIC ...)
   ! 
   ! where HEADER is a header skel, whose structure is common to all nodes,
   ! and the KIND-SPECIFIC elements carry data dependent on what kind of
   ! node this is --- file, directory, etc.
   ! 
   ! HEADER has the form:
   ! 
   !     (KIND PROPLIST FLAG ...)
   !
   ! [...]
   !
   ! If a NODE-REVISION's header's KIND is "file", then the
   ! node-revision skel represents a file, and has the form:
   !
   !    (HEADER DATA)
   !
   ! where DATA is an atom giving the full contents of the file.  (In
   ! the future, DATA may have other alternate forms, indicating that
   ! the fulltext of the file is stored elsewhere in the database, or
   ! perhaps in an ordinary Unix file.)
   !
   ! [...]
   !
   ! If the header's KIND is "dir", then the node-revision skel
   ! represents a directory, and has the form:
   ! 
   !     (HEADER PROPLIST (ENTRY ...))

Great, thank you `structure'.  Take it away, Eric the Orchestra
Leader...

The goal is to separate property lists from file contents, and store
both separately from node revisions.  We break PROPLIST out of HEADER,
and put PROPLIST and DATA in the `strings' table:

   ! NODE-REVISION and HEADER: how we represent a node revision
   ! 
   ! We represent a given revision of a file or directory node using a list
   ! skel (see skel.h for an explanation of skels).  A node revision skel
   ! has the form:
   ! 
   !     (HEADER PROPLIST KIND-SPECIFIC ...)
   ! 
   ! where HEADER is a header skel, whose structure is common to all
   ! nodes, PROPLIST is a property list, whose structure is also
   ! common to all nodes, and the KIND-SPECIFIC elements carry data
   ! dependent on what kind of node this is --- file, directory, etc.
   ! 
   ! HEADER has the form:
   ! 
   !     (KIND FLAG ...)
   !
   ! [...]
   !
   ! If a NODE-REVISION's header's KIND is "file", then the
   ! node-revision skel represents a file, and has the form:
   !
   !    (HEADER PROP-KEY CONTENTS-KEY)
   !
   ! where PROP-KEY and CONTENTS-KEY are keys into the `strings'
   ! table, the values for which are the property list skel and node
   ! revision's contents, respectively.  For files, the content is a
   ! straight string, for directories, it is a skel:
   ! 
   !     (ENTRY ...)

Now,

   - Replace dag_node_t->node_revision with three fields:
     dag_node_t->node_rev_header, dag_node_t->node_rev_proplist, and
     dag_node_t->node_rev_contents.

   - Replace svn_fs__get_node_revision() with, you guessed it,
     svn_fs__get_node_rev_header(), svn_fs__get_node_rev_proplist(),
     and svn_fs__get_node_rev_contents().

   - Find all callers of svn_fs__get_node_revision(), change each of
     them to call whatever subset of the above three new functions is
     appropriate.

   - Split svn_fs__put_node_revision() similarly, etc, etc.


b) Operate on portions of files efficiently.
============================================

   [still pondering this section]

You're gonna love Berkeley DB even more after this, if that were
possible... The basic story is, you tell your DBT you're only
interested in a substring of the record, and then do everything else
in the usual way.  Here's how:

  dbt->flags |= DB_DBT_PARTIAL
  dbt->doff  = some_offset;
  dbt->dlen  = some_length;

If it's a read operation, Berkeley will read the specified range.  If
some of those bytes don't exist, the read will still succeed, and null
bytes will be returned for the absent ones.

If it's a write operation, and dbt->size != dbt->dlen, then that range
of the record will grow or shrink accordingly.  See
http://www.sleepycat.com/docs/ref/am/partial.html for details.

Here's how we take advantage of this:

   - dag_node_t gets two new fields: contents_offset and contents_len.
     They apply to the node's cache of the contents, not the header or
     proplist.

   - svn_fs__get_node_rev_contents() takes offset and len arguments,
     fetches only that data.  The dag_node_t will remember the offset
     and len.

   - svn_fs__put_node_rev_contents() takes offset and len args as
     well.

   - change set_node_revision() accordingly.

   - ... todo thinking here ...

So now, whenever you read or write a node revision, you are operating
on a range.  There will be some way to say "I mean the whole thing",
of course, so it won't be necessary to know the size in advance.

Thought: possibly we should stop storing data in the dag_node_t
itself, and just return the data in a void pointer passed to
svn_fs__get_node_rev_contents().  Still pondering.


c) Reverse-delta storage.
=========================

Here's how nodes are represented now:
   
    REPRESENTATION ::= ("fulltext" NODE-REVISION)
                     | ("younger" DELTA CHECKSUM) ;
             DELTA ::= ("svndiff" DATA) ;
          CHECKSUM ::= ("md5" BYTES) ;
       DATA, BYTES ::= atom ;

However, now that properties and contents live separately from the
node revision, we can't deltify across the entire node revision; we
have to treat the property list and file contents separately from each
other and from the node revision itself.  So the change will actually
affect more than what's mentioned above.  Here's the new grammar, with
changes for deltification and with copy nodes removed, since we don't
seem to be using them now:

   ! Table keys:
   !                   ID ::= node.revision-id ;
   !                  TXN ::= number ;
   !
   ! Filesystem revisions:
   !             REVISION ::= ("revision" ID PROPLIST) ;
   !             PROPLIST ::= (PROP ...) ;
   !                 PROP ::= atom atom ;
   !
   ! Transactions:
   !          TRANSACTION ::= ("transaction" ROOT-ID BASE-ROOT-ID) ;
   !              ROOT-ID ::= node.revision-id ;
   !         BASE-ROOT-ID ::= node.revision-id ;
   !
   ! Node revisions:
   !        NODE-REVISION ::= FILE | DIR ;
   !                 FILE ::= (HEADER PROPLIST CONTENTS) ;
   !                  DIR ::= (HEADER PROPLIST (ENTRY ...)) ;
   !                ENTRY ::= (NAME ID) ;
   !                 NAME ::= atom ;
   !
   !               HEADER ::= (KIND FLAG ...) ;
   !                 KIND ::= "file" | "dir" ;
   !                 FLAG ::= ("mutable" PARENT-ID) ;
   !            PARENT-ID ::= "" | node.revision-id ;
   !      SOURCE-REVISION ::= number ;
   !
   !   CONTENTS, PROPLIST ::= ("fulltext" STRING-KEY)
   !                        | ("shared" ID)
   !                        | ("svndiff" BASE-ID STRING-KEY CHECKSUM) ;
   !
   !           STRING-KEY ::= atom ;    /* a key into the `strings' table */
   !
   !             CHECKSUM ::= ("md5" BYTES) ;
   !                BYTES ::= atom ;

If CONTENTS is a fulltext, the `("string" STRING-KEY)' form is used.
If CONTENTS does not point to the fulltext string directly, then it is
either the same as some other node's contents, or a delta against some
other node's contents.  These situations are expressed as "shared" and
"svndiff", respectively.  In either case, we retrieve the contents via
the other node's ID, instead of referring directly to an entry in
`strings'.  That way, when we convert a node N's fulltext to a delta,
we know that only N refers directly to the old fulltext string.
Everyone else goes through N, or through a chain eventually leading
through N.

PROPLISTs work the same way.

REPRESENTATION skels go away.  Node revisions are always stored as
fulltext, now each one is just a header plus pointers to proplist and
contents.

--- todo ---

Okay, I think the above is accurate as far as it goes.  We still need
to talk about how reverse deltification actually happens, though,
including: avoiding holding a whole file in memory, and composing
svndiff deltas to avoid the naive chain of fulltext productions.
