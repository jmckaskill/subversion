    Oh Most Noble and Virile Emacs, please be in -*- outline -*- mode!

     Inversion: A Version Control System You Actually Want To Use
     ------------------------------------------------------------
              ($Revision: 1.15 $ of this document.)

* Introduction

This document describes Inversion, a replacement for CVS.  We may
sometimes call it "Ivn", to save space.  It will be described largely
in terms of how it differs, or doesn't differ, from CVS; if you don't
already know CVS, this document will be pretty unreadable.

Where you see the word "version", it means the same thing "revision"
does in the CVS documentation.  Everyone always ends up saying
"version" anyway, then correcting themselves, so let's just give up
already.  Besides, it's shorter to type.

"Project" and "Repository" also mean what you think they do -- a
repository is a place where multiple projects are stored.  Sometimes I
might slip and say "repository" where I should have said "project",
because CVS uses the r-word for both.  Bear with me.

* Requirements

** All CVS features are supported.

Everything CVS has, we want.  Versioning, folding of non-conflicting
changes, detection of conflicting changes, branching, merging,
historical diffs, log messages, line-by-line history ("cvs annotate"),
the works.

Generally, Inversion's conceptual interface to a particular feature
will be as similar to CVS's as possible, except when there's a
compelling reason to do otherwise.

** Version numbers are project-wide and atomic.

Unlike CVS, each Inversion commit results in a single new version
number, which applies to the project as a whole (i.e., it applies to
every object in the project, whether changed or not).  There are no
longer separate per-file version numbers, at least not user-visible
ones.

Commits are atomic -- either the entire commit succeeded, or the
entire commit failed.  No one can ever retrieve a project tree in an
inconsistent state.

Lock-time is kept to a minimum.  A commit may block on another commit,
but only briefly, and only when absolutely necessary -- that is, when
the same files would be affected.  Readers neither cause nor wait for
locks.

** Directories, renames, and file meta-data are versioned.

Naturally!

By the way, rename support means you can trace through ancestry by
name *or* by entity.  For example, if you say "Give me version 12
of foo.c", you might mean version 12 of the file whose name is
*now* foo.c (but perhaps it was named bar.c back at version 12),
or you might mean the file whose name was foo.c in version 12 (perhaps
that file no longer exists, or has a different name now).  Inversion
offers a way to specify which interpretation you want, while
defaulting to the most reasonable interpretation in context.  We
haven't decided what "reasonable" means yet, but we're working on
that.

** Binary files are handled just like anything else.

That's right, no more "-kb" flag. :-)

Whether Inversion is able to merge changes into a file gracefully, or
show diffs, depends on whether diffing and/or merging tools are
defined for that type of file.  Right now, we know that text files are
supported.  (How does Inversion know whether something's text file or
not?  Well, you can tell it the type explicitly, or ask it to deduce
on the fly.)

Also, for text files, Inversion can do platform-specific end-of-line
conversion (CRLF vs LF, etc), just like CVS.

Regarding keyword expansion: Inversion does support it, but only on
request.  By default, keyword expansion is off -- if you do not ask
for expansion for a given file or group of files, Inversion will not
modify content.

** I18N/Multilingual support: non-ASCII encodings can be treated as text.

*** User-visible messages

Inversion can be localized so that its messages print out in a
build-time-configured language.

*** Text vs non-text data

In situations where Inversion needs to make an educated guess as to
whether a file is text or not, its takes into account the possibility
of non-ASCII text.  Furthermore, any textual operations on file data
(such as diffing, annotation, and keyword expansion) obey the
conventions of whatever UTF-* encoding the file appears to be.

The user will have a way of signalling to Inversion that a file is to
be treated as a particular encoding, so that users are not dependent
on Inversion's guessing capability.

** Branching and tagging are constant-time operations in Inversion.

CVS makes an unnecessary distinction between branches and tags, and
then goes on to implement them in an inefficient way.

Inversion supports them both with one efficient operation: `copy'.  To
copy a project is to create another project exactly like it, except
that the new project "knows" that the old project is its ancestor.
Version numbers in the new project start at the ancestor's version
number.

Clearly, at the moment of creation, a copy requires only a tiny amount
of constant space -- the copy is like an "alias" for the old project.
And if you never commit anything on the copy, then it's just like a
CVS tag.

If you start committing on the copy, then it's a branch.  Voila!

By default, inversion uses per-project namespaces for copies, to avoid
cross-project name conflicts.

This should also get us CVS "vendor branching" (since we'll have real
rename and directory support).

[Thanks to Jim Blandy <jimb@red-bean.com> for pointing out that
`copy' is a clean way to get both tagging and branching.]

** Repeated merges are handled gracefully.

Inversion merges are the same, in principle, as CVS merges: merging
means taking the differences between version A and B, and applying
those differences as a patch to version X (which may simply be the
working copy, rather than a formal repository version).

BUT, Ivn remembers what has already been merged, and doesn't merge
anything twice unless forced to.  So if you merge the differences
between <Branch A, Version N> and <Branch A, Tip> into
<Branch B>, and then you do it again a month later, the second
merge will only get the changes from <Branch A, Previous Tip> to
<Branch A, Current Tip>, *not* from <Branch A, Version
N> to <Branch A, Current Tip>.

This will require a more complete specification, of course, but
above is the general idea.  Note that per-object merge records will
need to be maintained on the server side, since people often need to
merge project subsets.

** Inversion does not set log message policy.

A small matter, but one dear to our hearts...

Log messages are a matter of project policy, not VC software policy.
If you leave off a log message, then Inversion defaults to an empty
message -- unless the project admin sets the right bit, in which case
log messages will be required *for that project only*.

(CVS tries to require log messages, but fails: we've all seen
thousands of empty log messages in CVS, meaning the user committed
with deliberately empty quotes, so let's please stop the madness now.)

** Conflicts do not munge working files (unless requested).

CVS's conflict resolution mechanism folds repository changes into the
working files, even when they conflict with changes there.  This is
often winning, in text files, but it doesn't work for binary files and
sometimes it's not so great for text either.

Inversion only does it that way if asked to; otherwise, it puts the
repository version of the file somewhere nearby, and the user can use
whatever comparison tools she wants to resolve the conflict.  When
Inversion *does* munge the working file, it first preserves an
unmunged copy somewhere nearby, in case the user regrets the update.

Inversion can optionally make educated guesses about what's binary and
what's text, so the user gets the right conflict resolution mechanism
for the context.

** Support for plug-in client-side diff programs

There is no need for Inversion to have every possible diff mechanism
built in (or even any mechanism built in).  Instead, it invokes the
appropriate client-side diff'er on the two versions of the file(s)
locally.  For text files, the appropriate diff'er is the system `diff'
program, or maybe "emacs -f ediff".  For image files, it might be some
fancy visual comparison product.

Maybe if no good client-side program is available, Ivn can get
sophisticated and send the working file to the server, who will try to
do the diff and send it back.  But that's for the future.

* Design

** The basic repository structure

[This design is drawn from Jim Blandy's "Subversion" spec, with a few
optimizations from Ben and Karl.]

Suppose we have a new project, at version 1, looking like this (pardon
the CVS syntax):

   prompt$ inv checkout myproj
   U myproj/
   U myproj/B
   U myproj/A
   U myproj/A/subA
   U myproj/A/subA/fish
   U myproj/A/subA/fish/foo
   prompt$

(Only the file `foo' is a regular file, everything else in myproj is a
directory so far).

Let's see what this looks like as an abstract data structure in the
repository, and how that structure works in various operations (such
as update, commit, and branch).

In the diagrams that follow, lines with arrowheads represent time
(that is, the progression of versions), and any other lines represent
parent-to-child connections in a directory hierarchy.  Boxes are
"nodes".  A node is either a file or a directory -- a letter in the
upper left indicates which kind, and next to the letter is the node's
name.  The name is printed just as a reminder in these diagrams; in
actual implementation, a node's name would probably only be stored in
its parent, not in the node itself.

A file node has a byte-string for its content, whereas directory nodes
have a list of dir_entries, eaching pointing to another node.

At the top of the repository is an array of version numbers,
stretching off to infinity.  Since the project is at version 1, only
index 1 points to anything; it points to the root node of version 1 of
the project:


      Figure 1: The `myproj' repository at version 1.


                    (<--- myproj's version array ---> )
       ______________________________________________________
      |__ 1 _____ 2 ______ 3 ______ 4 ______ 5 _______ 6 ____---->
          |
          |
       ___|_____
      |D myproj |
      |         |
      |   A     |                 /* Two dir_entries, `A' and `B'. */
      |    \    |
      |   B \   | 
      |__/___\__|
        /     \
       |       \
       |        \
    ___|____     \ ________
   |D  B    |     |D  A    |
   |        |     |        |
   |  subB  |     | subA   |      /* One dir_entry, `subA'. */
   |________|     |___\____|
                       \
                        \
                      ___\____
                     |D subA  |
                     |        |
                     | fish   |   /* One dir_entry, `fish'. */
                     |___\____|
                          \
                           \
                         ___\____
                        |D fish  |
                        |        |
                        | foo    |  /* One dir_entry, `foo'. */
                        |___\____|
                             \
                              \
                            ___\____
                           |F foo   |
                           |        |
                           |        |   /* (Contents of foo not shown.) */
                           |________|


What happens when we modify `foo' and commit?  First, we make a new
`foo' node, containing the diff from version 2 of foo to version 1.
Let's use ":N" to express version relationships; so, this diff is the
result of:

   diff foo:2 foo:1

Note the the order there: this is a reverse diff.  The idea is that
foo:2 will hold the full text of this new version, and foo:1 will
become a diff.  This is done to save space, it does not affect the
semantics of the implementation.  (Also note that we're assuming a
diff program that can handle binary data!)

The new node is not connected to anything yet, it's just hanging out
there in space:

                         ________
                        |F       |
                        | foo    |
                        |        |
                        |________|

It doesn't even say what version it belongs to; we'll get to that in a
moment.

Next, link the new node into the tree, where the previous node was,
and create a "cross-link" (I forgot to tell you, nodes have a
cross-link field) from the new node to the old node.  Cross-links are
shown as parenthesized numbers with an arrow leading to the older
node:

      Figure 2: The `myproj' repository, in an intermediate state
                during the commit of version 2 (a modification to
                the file `foo').

       ______________________________________________________
      |__ 1 _____ 2 ______ 3 ______ 4 ______ 5 _______ 6 ____---->
          |
          |
       ___|_____
      |D myproj |
      |         |
      |   A     |
      |    \    |
      |   B \   | 
      |__/___\__|
        /     \
       |       \
       |        \
    ___|____     \ ________
   |D  B    |     |D  A    |
   |        |     |        |
   |  subB  |     | subA   |
   |________|     |___\____|
                       \
                        \
                      ___\____
                     |D subA  |
                     |        |
                     | fish   |
                     |___\____|
                          \
                           \
                         ___\____
                        |D fish  |
                        |        |
                        | foo    |
                        |___\____|
                             \
                              \
                            ___\____            ________
                           |F foo   |          |F foo   |
                           |        |          |        |
                           |  (1)------------->|        |
                           |        |          |        |
                           | full   |          | diffy  |
                           |contents|          |contents|
                           |________|          |________|


A cross-link is a version number attached to a pointer into the past.
The version number tells you the version of what the links points to,
not what it points from.  So if you're looking for FILE:N, and when
you get a node for that file you find a cross-link pointing to a
version >=N, then you know you must follow that link.

But I digress.  Right now, we're learning how to commit foo:2, and
there's one more step needed to complete that commit -- register the
new version at the top of the repository, thus making it externally
visible.  That's done by making entry 2 in the version array point to
something:


      Figure 3: The `myproj' repository, after commit of version 2. 

       ______________________________________________________
      |__ 1 _____ 2 ______ 3 ______ 4 ______ 5 _______ 6 ____---->
          |       |
          |      /
       ___|_____/
      |D myproj |
      |         |
      |   A     |
      |    \    |
      |   B \   | 
      |__/___\__|
        /     \
       |       \
       |        \
    ___|____     \ ________
   |D  B    |     |D  A    |
   |        |     |        |
   |  subB  |     | subA   |
   |________|     |___\____|
                       \
                        \
                      ___\____
                     |D subA  |
                     |        |
                     | fish   |
                     |___\____|
                          \
                           \
                         ___\____
                        |D fish  |
                        |        |
                        | foo    |
                        |___\____|
                             \
                              \
                            ___\____            ________
                           |F foo   |          |F foo   |
                           |        |          |        |
                           |  (1)------------->|        |
                           |        |          |        |
                           | full   |          | diffy  |
                           |contents|          |contents|
                           |________|          |________|


Version 2 points to exactly the same root node as version 1, because
that directory hasn't changed at all.  Nor has its child, nor has
anything until you get all the way down to foo.

That's why nodes don't store version numbers -- the exact same node
may appear in many different versions.

Here's how to retrieve foo:N, in general:

   1. Go to the version table, find version N.

   2. Walk down the tree in the obvious way, starting from the root
      node N points to.  As you walk, anytime you get to a node with a
      cross-link >=N, follow the link before continuing downward.
      (Follow this rule even when you get to a node for `foo'.)

   3. When you have nowhere else to go, this is the droid you're
      looking for.

Now watch what happens when we add a new file `bar' into `fish'
(i.e., bar will be a sibling of `foo').  Here's the new tree, the
intermediate steps not being shown:

      Figure 4: The `myproj' repository, after commit of version 3
                (the addition of a sibling to `fish/foo').

       ______________________________________________________
      |__ 1 _____ 2 ______ 3 ______ 4 ______ 5 _______ 6 ____---->
          |       |       /
          |      /       /
       ___|_____/       /
      |D myproj |______/
      |         |
      |   A     |
      |    \    |
      |   B \   | 
      |__/___\__|
        /     \
       |       \
       |        \
    ___|____     \ ________
   |D  B    |     |D  A    |
   |        |     |        |
   |  subB  |     | subA   |
   |________|     |___\____|
                       \
                        \
                      ___\____
                     |D subA  |
                     |        |
                     | fish   |
                     |___\____|
                          \
                           \
                         ___\____        ________
                        |D fish  |      |D fish  |
                        |        |      |        |
                        |  (2)--------->|        |
                        |        |      |  foo   |
                        |        |      |___/____|
                        |        |         /    ________
                        |        |        /    |F  bar  |
                        | bar -----------/-----|        |
                        |        |      /      |        |
                        | foo    |     /       |        |
                        |___\____|    /        |________|
                             \       /
                              \     /
                             __\___/_            ________
                            |F  foo  |          |F  foo  |
                            |        |          |        |
                            |  (1)------------->|        |
                            |        |          |        |
                            | full   |          | diffy  |
                            |contents|          |contents|
                            |________|          |________|


Trace various retrievals in the above structure, and you will see that

   + fish:2 and fish:1 are the same node, which they should be.

   + But fish:3 is different from them, which is also as it should be.

   + foo:3 and foo:2 are the same node, which they should be.

   + But foo:1 is different from them, which is also as it should be.

Thus, the traversal cost of retrieving version N of something is equal
to its depth in the tree plus the number of changes it or its
ancestors have undergone.  Unchanged entities cost nothing.

Whether fish:2 is stored as some sort of diff from fish:3 is an
implementation detail.  We could do it that way, but it may not be
necessary, since new directory nodes would only be created when a new
file or directory is added to the project, or a name is changed.  Most
commits tend to be edits to existing files.

Just to drive the point mercilessly home, and explore the theoretical
limits of ASCII diagrams, here is myproj:4 (a commit which added a
README to the project's top level directory):

      Figure 5: The `myproj' repository, with new top-level README:

       ______________________________________________________
      |__ 1 _____ 2 ______ 3 ______ 4 ______ 5 _______ 6 ____---->
          |      /       /         /
          |     /       /         /
      ____|____/       /         /               _________
     |D myproj |______/         /               |D myproj |
     |         |               /                |         |
     |   (3)------------------/---------------->|         |
     |         |             /             _____|__ B     |
     | README  |____________/             /     |         |
     |      |  |                         /      |   A     |
     |   B  |  |            ____________/       |___|_____|
     |  /   |__|_________  /                        |
     | /  A    |         \/       _________         |
     |_|___\___|         /\      |F README |        |
       |    \_______    /  \_____|         |        |
       |            |  /         |         |        |
       |            | /          |         |        |
       |            |/           |_________|        |
       |            /                               |
       |           /|                               |
       |   _______/ |                               |
       |  |         |                               |
       |  |         |                               |
    ___|__|_       _|______                         |
   |D  B    |     |D  A    |                        |
   |        |     |        |________________________|
   |  subB  |     | subA   |
   |________|     |___\____|
                       \
                        \
                      ___\____
                     |D subA  |
                     |        |
                     | fish   |
                     |___\____|
                          \
                           \
                         ___\____        ________
                        |D fish  |      |D fish  |
                        |        |      |        |
                        |  (2)--------->|        |
                        |        |      |  foo   |
                        |        |      |___/____|
                        |        |         /    ________
                        |        |        /    |F  bar  |
                        | bar -----------/-----|        |
                        |        |      /      |        |
                        | foo    |     /       |        |
                        |___\____|    /        |________|
                             \       /
                              \     /
                             __\___/_            ________
                            |F  foo  |          |F  foo  |
                            |        |          |        |
                            |  (1)------------->|        |
                            |        |          |        |
                            | full   |          | diffy  |
                            |contents|          |contents|
                            |________|          |________|


** How branches work in this design

  [Still writing this up, although we know how it works.  The basic
  thing to note is how tags are totally constant space, but once you
  start committing on a tag it becomes a branch and line-of-ancestry
  copying is forced.] 

** Other miscellaneous design goals

*** Natively client/server.

Even when accessing a local repository, the ivn client connects to a
ivn server and talks the ivn protocol.  This is for maintainability --
in CVS, it's easy to write a bug by implementing something correctly
for either the client/server or the standalone but not both (and more
often neither, but that's another story).

The protocol may be DAV, if DAV turns out to be suitable.  Still under
investigation.

*** The client/server protocol sends diffs in both directions

Inversion transmits diffs both ways (unlike CVS, which transmits diffs
from server to client, but full files going the other way, thus using
more bandwidth than necessary).  Ivn accomplishes this either by
keeping pristine copies locally, or using the rsync algorithm; which
way we do it is an implementation detail that hasn't been decided yet.

* Evaluating the Design

The design of Inversion is still in progress; there are known problems
with the above design, and potential solutions.  However, I'm
concentrating on other stuff until we the rest of the full-time
Inversion people are on board to bounce ideas with.  The design will
finalize within a couple of weeks of the core team being assembled.

** Concerns

There are certain properties which we would like any implementation to
have.  I'm listing them here instead of in the "Requirements" section,
because they aren't really features, they're more like principles.

*** Minimize network turnarounds

The CVS client/server protocol goes to great effort to make sure that
the client and server need only a minimum of exchanges per operationn.
I believe it is "theoretically" possible to never need more than 2
turnarounds (i.e., client asks server preliminary questions, server
responds, client then does the real request, server responds), and
most things can be done with just 1.

*** Minimize database turnarounds

We need to make sure that traversing tree structures does not require
N separate database accesses, where N is proportional to the depth or
breadth of the traversal.  For example, if retrieving an old version
requires chaining down from the present version, and each link on the
chain is another database access, that's bad.  Database accesses
should be thought of like network turnarounds -- one hopes to arrange
things so that any operation requires only a (small) constant number
of them, not N.

*** Times should be proportional to change size, not project size

The time to complete any operation should be proportional to the size
of the change that operation relates to, not the total amount of data
in the project or in the repository.  Committing three files should
take roughly the same amount of time in a project with ten files as in
a project with forty thousand.  Same with diffing three files, etc.

An exception is made for recency: retrieving an old version may take
longer than retrieving a recent one, because old versions will take
longer to construct.  This is a tradeoff of using diff-based storage,
and has worked out pretty well in practice.

** Scenarios 

Each scenario should be mentally played out for a given design,
analyzing for performance and scalability issues (particularly in
network traffic, storage, and db accesses).

If you spot a weakness in a design, add a scenario here that
highlights it: even if that particular design gets tossed, the
scenario will probably reveal similar weaknesses in other designs.

(On the other hand, if a scenario never reveals weaknesses in
anything, then remove it -- it's not helpful if it only demonstrates
the ease of implementing that operation well.  Currently this list is
a brain dump; there's no reason it can't be shortened.)

*** Commit from an up-to-date wcopy

*** Commit from non-up-to-date wcopy, with the modified files not-up-to-date

*** Commit from non-up-to-date wcopy, with the modified files up-to-date

*** Updating to most recent version(s), with no conflicts

*** Updating to most recent version(s), with conflicts

*** Party A commits while Party B's commit is in progress, but no conflicts

In this context, "conflicts" means the same entities were changed,
even if the changes are non-overlapping.

*** Party A commits while Party B's commit is in progress, with conflicts

In this context, "conflicts" means the same entities were changed,
even if the changes are non-overlapping.

Conflicts can mean changing the same file, or adding the same file, or
one person modifying it while the other wants to delete it, or
whatever.  (I don't think it will matter in the end, as the
implementation is mainly concerned with the idea that someone wants to
do something with a non-up-to-date file).

*** Add a new entity (directory or file)

*** Add a new entity (directory or file) from a non-up-to-date wcopy

Both with current directory up-to-date, and not.  (First determine
what desired behavior is!)

*** Rename an entity

*** Retrieve an old version of an entity that has been renamed

*** Remove an entity

*** Resurrect an entity

*** Move an entity to a new directory (may be different from rename)

*** Diff two particular versions of a file

*** Diff a working (uncommitted) version against an old version of a file

*** Retrieve version X of a file

*** Retrieve version X of a directory tree 

*** Show annotations of both modified and old versions of files.

(Golly, we need some word other than "annotations".  To me it implies
that one has added log messages to individual lines, or something like
that, not that CVS is showing you who did what and when.)

*** Show annotations of a directory, similarly.

Who created the file, and who last committed to it.

Should this be a wish-list item, though?  CVS doesn't do it, but then
again, CVS doesn't do directories either...

*** Make a branch

*** Make a tag (same as making a branch, in all proposed designs)

*** Merge a branch into trunk

Not talking about the user interface to branch merging, here, but
rather internal implementation: how the system discovers what is the
same vs what needs merging, what conflicts, etc.

*** Merge a branch into trunk again

*** Merge a branch into another branch

Is this fundamentally different from merging into trunk?  Is the trunk
"special" in any way, implementation-wise, or is it just the first
branch?

*** Change a previously committed log message

*** more to come...


* Meta-implementation

This section describes the process of implementing Inversion -- what
order we do things in, and how.

Once the design is ready, the parallizable parts of the software
should be determined, and tasks divvied up.  At this point or very
soon after, the client/server protocol needs to be designed too.  We
will evaluate WebDAV (using the same examination-under-common-ops
technique as with the data design); if WebDAV is suitable, it would be
a good choice, because it already has some political acceptability.

During the initial coding phase, everything that can be farmed out to
external programs will be.  For example, the diff routines will just
invoke xdelta and diff (or whatever), and the client side will invoke
an external patch.  In the long run, these things will very likely be
internalized for speed, but their semantics won't change when we do
that, and it's more important to get the stuff up and running as soon
as we can, and optimize afterwards.

There should be an automated test-suite.  It should not be written in
Bourne shell script (we can at least learn this lesson from CVS!).

Authentication questions will be put off until most of the software is
working, since they probably don't affect the rest of the design much.

* Jason's comments

I'll be responding to these here (or by adjusting parts of the
document above).  For now I'm just storing them here so we don't lose
them. :-)

--------------------8-<-------cut-here---------8-<-----------------------

>From: Jason Elliot Robbins <jrobbins@collab.net>
>Subject: Inversion feature outline (was: for meeting w/ Rational)
>To: kfogel@red-bean.com
>cc: jrobbins@collab.net, npm@collab.net, brian@collab.net, jon@collab.net
>Date: Thu, 02 Mar 2000 19:02:47 -0800
>
>Hi Karl,
>
>Here are some comments I came up with while reading your Inversion
>document on my last plane trip.  Overall this document looks like a
>good start, but there is a lot to work out.
>
>When would you like to put this document on the inversion.tigris.org
>web site?
>
>
>Here are my comments:
>
>I know this is long, the best comments are 1, 7, 12, 14, and 17.
>
>1. We should plan for web integration.  That could mean a lot of
>things.  One idea off the top of my head is to actually use a URL for
>the CVSROOT: I would make it an actual http:// scheme, rather than
>some new ivn: scheme, so that there is a clear place to host a web
>page with instructions about that repository.  Alternatively, we could
>use a new scheme like ivn:argouml.tigris.org, so long as the CVSROOT
>is very memorable to people who know the web address. Right now the
>maping between projects (e.g., www.webmacro.org, or java.tigris.org)
>and their CVSROOT varies a lot from site to site.  It would be nice to
>make this a no brainer.

Well, I'm not so sure... The reason this mapping (www<-->repository)
varies so much is political, not technical.

For example, it so happens that the hostname argouml.tigris.org hosts
one repository with one project in it, so there would be no ambiguity
in referencing that project by the hostname.  But there are many
servers that host multiple projects, and not all of those projects
have their own domains.  In many (most?) cases, the repository server
is on a different host from the Web server.  Or: sometimes people want
to deliberately associate their project with an organization, so they
don't want a strong link between the project's name and its Web
address.

Also, as far as I can tell, people don't really have trouble figuring
out a project's web site given a working copy, or vice-versa.  They
may have trouble *using* CVS to get the working copy, but that's a
different matter...

I think it's actually not our place to make assumptions about how
people want to present their project to the world.  It *is* our place
to make sure that our system provides no obstacles to whatever method
a user chooses to make her project web-visible, but "no obstacles"
doesn't mean special support for anything in particular.

If someone wants to keep their project's web pages in the project's
source tree, and point their web server at the right place, there's
nothing stopping them from doing that.  If they arrange it so the
names are the same, that's great -- and if they don't, there might be
a reason for that.

Hmmm, I can go into greater detail on this if you want; my hands are
tired of typing right now so I'll leave this question here.

>2. I would like to make the difficult things in CVS easier in Ivn.  I
>think you mention that you would like to make things like moving files
>and directories, etc. easier.  Actually, the second paragraph in
>Meta-implementation is definately the right idea.  Looking at all the
>multi-step proceedures outlined in your CVS book and making them one
>step in Ivn would be great.

Oh gosh you bet! :-)

>3. The concept of assigning a new version number to every file
>everytime there is a commit is rather foreign to me.  Is this used in
>other vc systems?  Are other people familiar with this practice?  Does
>that mean that it would be very awkward to verbally tell someone to
>check out a certain version (e.g., version 2378812, instead of 4.7)?
>Would it be possible to tell at a glance how many versions a file has
>gone through?

I don't know; I don't know; no I don't think so; and yes. :-)

Perhaps we could make a distinction between a file's commit count and
its project's commit count -- i.e., two kinds of version numbers,
treated equally; which one you use depends on circumstances.  Let's
mull on that.  I do worry about the potential for confusion, though...

How big do project version numbers get?  Well, to give you an idea,
the entire CVS tree (dating from 3 Dec 1994) has 4254 commits.  4254
isn't such a bad version number -- I wouldn't mind having to deal with
a few more digits than that, personally.

I don't think of it as assigning a new version number to every file on
every commit -- that's not what's happening inside anyway.  Instead, I
think of it as a single version number for every *commit*, and a
commit involves certain files.  As for files not involved in that
commit, if you ask for one of them at that version number, you'll just
get the most recent version not exceeding the one in question.

[My table description may seem not match what I'm saying here, but
that table desc is just a draft and will be updated.]

>4. Why make keyword expansion off by default.   If I want to do it I
>will have to search through the documentation to find the right
>option.  I realize that it might mess up binary files, is there
>another way to make that safe.

Well, right now, if you don't want to do it, you have to search
through the documentation to turn it off. :-)

Seriously, I'm by no means sure that off is better, I just lean that
way because I've been nailed several times in the past by not turning
it off when I should have (not talking about binary files, I mean text
files that happened to have text that matched keywords, but I didn't
want that text to be expanded).

[todo: more to say here, fingers falling off, will respond more
later.]

>7. How about the idea of "local branches" that are stored on a
>developer's working machine in addition to the local working copy of
>the checked out files.  This is basically a fraction of the total
>repository stored on each client.  The local reposiroty would be
>filled in on demand, e.g., if you do a diff against an old version,
>that version would be stored in your local repository.  Developers
>could also commit to the local branch several times before eventually
>merging into the central servers main branch.  If local branches are
>accessable via the internet then we could basically do away with
>patches.  If a developer does work that he wants to contribute back to
>an open source project, he could just email the URL of his local
>server.  Also, the concept of local branches could be generalized to
>build a higherachy of servers with the global project home server at
>the top and various mirrors in the middle, LAN servers near the
>bottom, and each developers' local server at the bottom.  This has the
>advantage that every developer can have commit access to some
>repository, we get a range of trust rather than a boolean permisssion
>to commit to the central server or not.

Sure!

I think what we have to do is design this in such a way that it
doesn't take any special support from us to create this concept.
That is, if one knows the client/server protocol, one can implement
local branches without us changing anything.

So, we should think about this as we go, but I don't think we should
actually make it part of the first release.  We should just try to
have a design that doesn't make this feature impossible.

[There are some "theoretical" problems that come up in schemes like
this, having to do with conflict resolution of course, which we have
to think through.  So we may have to back down from this idea to an
arbitrary degree... I hope not too much though, 'cause it's neat.]

>8. I would like to have some kind of plug-in permission system.  I am
>wary of yet another set of user account records and permissions.  We
>have found that half the tools we want to integrate into tigris has its
>own user account system, and that makes a lot of duplicate data that
>needs to be kept in synch.

Yeah, some way of saying "default to the system users and access
methods on this host", and then you can add inversion-only users as
necessary. (?)

>9. Some of the data in your tables is not as normalized as it cood
>be.  I know this may not be a priority, but here are some that I
>noticed.: the names of entities and their states could be in separate
>tables.  Line mods could be a table of line ranges rather than text, I
>guess it depends on what format you were thinking of for that text
>field, but it seems like you might do a lot of parsing.  The names of
>properties in key value pairs could be stored in a properties names
>table.

Yup, thanks.  Still a draft, we'll normalize.

>10.  I am a little concerned about storing the parent container
>referenace and a basename.  I would like to have permissions limited
>to a given scope that matches the complete path.  For example, I would
>like to grant a particular developer the ability to commit
>.*/dist/.*\.html but not any .java files or any file not in a
>subdirectory of some dir named named api.  You have some of this in
>your ACCESSES table.  For the sourcexchange.com web site we developed
>a much more general permission scheme that you can read about at
>http://joist.tigris.org. 

I'll look into this.

>11. I would like to see some audit mechanism.  I think in this version
>of the document you left off the basic ability to see who did each
>commit.   More generally, we should consider the repositiory
>administrator role in all its glory.  I dont want to require a lot of
>administration work, but whatever needs to be done should be put under
>the same "evaluation across operations" as we do for developer
>operations.

Oops... the problem referred to in your second sentence is due to an
error in transferring my tables from paper to disk.  Fixed now. :-)

In general, yes, I think I see what you mean about admin role.

>12.  It would be nice if the server could be installed without root
>access.  This would allow a lot more people to set up servers for
>their local work group etc.  As a student, I never had root access to
>a big machine, and a lto of people working on OS are students.  Some
>small local server is also important to the local branch idea.  Apache
>can be installed without having root access, and so can ezmlm mailing
>lists, I really like that power for everyone.  The security
>implications are good and it would surely simplify installation.

No reason why this can't happen.  Nothing in the design as it stands
right now requires root, AFAIK.

>13. We should consider the following levels of internet connectivity:
>high speed, low speed, disconnected (e.g., laptops and modems), flaky
>connection.  Low speed constant connections (e.g., in distant
>contries) might benefit from background filling in of their local
>repository history.  Flaky connections might benefit from a resume
>capability (I guess that comes for free in CVS, but we need to make
>sure there are never any remaining lock files left on either end).

Well, we will make sure that locking can handle connections broken at
any point, by doing things carefully ("carefully" in the same sense as
a filesystem that guarantees mv to be atomic even if the power goes
out).

>14. Would you consider implementing Inversion in Java.  The advantage
>is that it runs on all platforms, and JDBC connects to all database,
>and RMI would make the client-server implementation easier.  Web
>integration with java servles would certainly be easier.  Speed is
>somewhat of an issue, but java is pretty fast now and a lot of the
>speed will be determined by the database rather than our code.  I am
>not concerned about CPU-bound speed problems because processors are
>getting insanely fast and we can have fast machines in our racks.
>Speed could be a problem for small (student) projects that dont have
>good machines, but then again "small project" implies that they
>probably dont have that many concurrent accesses anyway.  I think
>selling inversion as "version control that you actually want to use"
>trumps speed claims anyway, we should make it easy in use and easy to
>enhance.  Java would also give us no-brainer internationalization
>support.  

In my experience (not nearly as great as yours) Java is the least
portable language: it is unusual in requiring *both* a compiler and a
run-time, and naturally I've had problems with both.  Maybe things are
different now...

I do think (as a political thing) that when people hear Java they
shudder in anticipation of the problems they're going to have getting
the thing running.  Even though they may be wrong, this reaction is
something to take into account.

I mean, I guess I can't say "No, I wouldn't even consider implementing
this in Java", but I certainly do lean against
it... Internationalization support would be nice, but is it that hard
in other languages, even C?

>15. Compression.  It would be great if the protocol batched up all the
>files that need to be transfered for a given transaction and then
>compressed the whole set of files using a standard zip algorithm or
>something.  Typically compressing many similar files can give better
>results than compressing each indepently.  This is assuming
>dictionary-based compression, I think.

Good idea!

>16. What is the import/export format for this?  Would I just do a
>mysqldump? Should there be an XML file format for versions and log
>entries and such?

Dunno. :)

>17. It would be nice to have scripts executed for any possible
>action.  CVS has scripts that run on many actions, e.g., commit and
>tagging.    Actually, if we use java it would be possible to define a
>sandbox to run these scripts safely.  That would allow developers to
>upload "inversion agents" that are .class files invoked whenever an
>action is taken on the server and do some kind of testing or
>notification on behalf of that particular developer.  This could be a
>good hook for integrating Inversion with a server-farm build system,
>implementing the hierarchy of servers described in suggestion #7.

Yeah; one of the things I want to do is go over the commit process
step-by-step and figure out every possible place where we can give
users a hook to run a script.  CVS offers a few good places; we can
offer more, I think.

>18.  You have specified that the contents of the source files should
>be in the database.  An alternative woulf be to just have the name of
>some file in the file system.  Could you explore/explain that tradeoff?

Yes -- we'll do whichever is better. :-)

Seriously, I don't know how various databases perform with big text
chunks.  Unless it's a serious hit, though, I think we should try to
stay in the database.  I mean, why use it unless we're going to use
it?  The only reason I can see to implement an extra level of
indirection here would be if it gave us some big performance boost.

* Wish List

put blue-sky requests here...