    Oh Most Noble and Virile Emacs, please be in -*- outline-*- mode!

     Inversion: A Version Control System You Actually Want To Use
     ------------------------------------------------------------
              ($Revision: 1.3 $ of this document.)

* Introduction

This document describes Inversion, a replacement for CVS.  We may
sometimes call it "Ivn", to save space.  It will be described largely
in terms of how it differs, or doesn't differ, from CVS; if you don't
already know CVS, this document will be pretty unreadable.

Where you see the word "version", it means the same thing "revision"
does in the CVS documentation.  Everyone always ends up saying
"version" anyway, then correcting themselves, so let's just give up
already.  Besides, it's shorter to type.

"Project" and "Repository" also mean what you think they do -- a
repository is a place where multiple projects are stored.  Sometimes I
might slip and say "repository" where I should have said "project",
because CVS uses the r-word for both.  Bear with me.

* Requirements

** All CVS features are supported.

Everything CVS has, we want.  Versioning, folding of non-conflicting
changes, detection of conflicting changes, branching, merging,
historical diffs, log messages, line-by-line history ("cvs annotate"),
the works.

Generally, Inversion's conceptual interface to a particular feature
will be as similar to CVS's as possible, except when there's a
compelling reason to do otherwise.

** Version numbers are project-wide and atomic.

Unlike CVS, each Inversion commit results in a single new version
number, which applies to the project as a whole (i.e., it applies to
every object in the project, whether changed or not).  There are no
longer separate per-file version numbers, at least not user-visible
ones.

Commits are atomic -- either the entire commit succeeded, or the
entire commit failed.  No one can ever retrieve a project tree in an
inconsistent state.

A commit may block on another commits (though only briefly, and only
when absolutely necessary -- that is, when the same files would be
affected).  But readers never cause locks nor wait for locks.  The
repository is always readable.

** Directories, renames, and file meta-data are versioned.

Naturally!

By the way, rename support means you can trace through ancestry by
name <i>or</i> by entity.  For example, if you say "Give me version 12
of foo.c", you might mean version 12 of the file whose name is
<i>now</i> foo.c (but perhaps it was named bar.c back at version 12),
or you might mean the file whose name was foo.c in version 12 (perhaps
that file no longer exists, or has a different name now).  Inversion
offers a way to specify which interpretation you want, while
defaulting to the most reasonable interpretation in context.  We
haven't decided what "reasonable" means yet, but we're working on
that.

** Binary files are handled just like anything else.

That's right, no more "-kb" flag. <tt>:-)</tt>

Whether Inversion is able to merge changes into a file gracefully, or
show diffs, depends on whether diffing and/or merging tools are
defined for that type of file.  Right now, we know that text files are
supported.  (How does Inversion know whether something's text file or
not?  Well, you can tell it the type explicitly, or ask it to deduce
on the fly.)

Also, for text files, Inversion can do platform-specific end-of-line
conversion (CRLF vs LF, etc), just like CVS.

Regarding keyword expansion: Inversion does support it, but only on
request.  By default, keyword expansion is off -- if you do not ask
for expansion for a given file or group of files, Inversion will not
modify content.

** I18N/Multilingual support: non-ASCII encodings can be treated as text.

Inversion does not assume that anything not 7-bit ASCII must therefore
be opaque binary -- it tries very hard to treat things as UTF-* text,
for purposes of diffing and annotation, whenever possible.

** Branching and tagging are constant-time operations in Inversion.

CVS makes an unnecessary distinction between branches and tags, and
then goes on to implement them in an inefficient way.

Inversion supports them both with one efficient operation: `copy'.  To
copy a project is to create another project exactly like it, except
that the new project "knows" that the old project is its ancestor.
Version numbers in the new project start at the ancestor's version
number.

Clearly, at the moment of creation, a copy requires only a tiny amount
of constant space -- the copy is like an "alias" for the old project.
And if you never commit anything on the copy, then it's just like a
CVS tag.

If you start committing on the copy, then it's a branch.  Voila!

By default, inversion uses per-project namespaces for copies, to avoid
cross-project name conflicts.

[Thanks to Jim Blandy &lt;jimb@red-bean.com&gt; for pointing out that
`copy' is a clean way to get both tagging and branching.]

** Repeated merges are handled gracefully.

Inversion merges are the same, in principle, as CVS merges: merging
means taking the differences between version A and B, and applying
those differences as a patch to version X (which may simply be the
working copy, rather than a formal repository version).

BUT, Ivn remembers what has already been merged, and doesn't merge
anything twice unless forced to.  So if you merge the differences
between &lt;Branch A, Version N&gt; and &lt;Branch A, Tip&gt; into
&lt;Branch B&gt;, and then you do it again a month later, the second
merge will only get the changes from &lt;Branch A, Previous Tip&gt; to
&lt;Branch A, Current Tip&gt;, <i>not</i> from &lt;Branch A, Version
N&gt; to &lt;Branch A, Current Tip&gt;.

<i>This will require a more complete specification, of course, but
above is the general idea.  Note that per-object merge records will
need to be maintained on the server side, since people often need to
merge project subsets.</i>

** Inversion does not set log message policy.

A small matter, but one dear to our hearts...

Log messages are a matter of project policy, not VC software policy.
If you leave off a log message, then Inversion defaults to an empty
message -- unless the project admin sets the right bit, in which case
log messages will be required <i>for that project only</i>.

(CVS tries to require log messages, but fails: we've all seen
thousands of empty log messages in CVS, where the user did
<tt>commit&nbsp;-m&nbsp;""</tt> or whatever, so let's please stop the
madness now.)

** Conflicts do not munge working files (unless requested).

CVS's conflict resolution mechanism folds repository changes into the
working files, even when they conflict with changes there.  This is
often winning, in text files, but it doesn't work for binary files and
sometimes it's not so great for text either.

Inversion only does it that way if asked to; otherwise, it puts the
repository version of the file somewhere nearby, and the user can use
whatever comparison tools she wants to resolve the conflict.  When
Inversion <i>does</i> munge the working file, it first preserves an
unmunged copy somewhere nearby, in case the user regrets the update.

Inversion can optionally make educated guesses about what's binary and
what's text, so the user gets the right conflict resolution mechanism
for the context.

** Support for plug-in client-side diff programs

There is no need for Inversion to have every possible diff mechanism
built in (or even any mechanism built in).  Instead, it invokes the
appropriate client-side diff'er on the two versions of the file(s)
locally.  For text files, the appropriate diff'er is the system `diff'
program, or maybe "emacs -f ediff".  For image files, it might be some
fancy visual comparison product.

Maybe if no good client-side program is available, Ivn can get
sophisticated and send the working file to the server, who will try to
do the diff and send it back.  But that's for the future.

* Implementation

** Repository uses diffy storage, of course.

The Ivn repository does diff storage like CVS, with the full-text of
most recent version of a file, and then reverse diffs going back in
time.  But Ivn does not use RCS format, and it uses a binary differ of
course (XDelta?), not a text differ.

In order to preserve the "cvs annotate" information, line-number
change information is stored along with the binary diff.  [Thanks
again to Jim Blandy for this trick.]

** Natively client/server.

Even when accessing a local repository, the ivn client connects to a
ivn server and talks the ivn protocol.  This is for maintainability --
in CVS, it's easy to write a bug by implementing something correctly
for either the client/server or the standalone but not both (and more
often neither, but that's another story).

The protocol may be DAV, if DAV turns out to be suitable.  Still under
investigation.

** The client/server protocol sends diffs in both directions

Inversion transmits diffs both ways (unlike CVS, which transmits diffs
from server to client, but full files going the other way, thus using
more bandwidth than necessary).  Ivn accomplishes this either by
keeping pristine copies locally, or using the rsync algorithm; which
way we do it is an implementation detail that hasn't been decided yet.

** The server stores projects in a database

It turns out that project history storage falls neatly into a
relational model; furthermore, using a real database gives us a lot of
the locking behavior we need for free, and allows us to speed up
crucial read operations by creating the right indexes.

In short, this is one wheel we don't want to reinvent.

A database makes it easy to have multiple repositories on one machine,
with different admins for each repository -- each repository is simply
a database (i.e., a namespace within which one can create tables) in
the system.  Ultimate admin permissions are obtained through the usual
database administration entry points.

** Data design

So what's the "thingum" in this database, the core object (i.e, table)
around which everything else revolves?  For lack of a better name,
we'll call it the "entity" table, where "entity" means a file or
directory that's under version control.

A look at its table description below will make things clearer...

*** The ENTITIES table

     PKEY         int           Internal unique identifier for this
                  (never null)  entity. Users never see the pkey,
                                only people trying to debug a problem
                                in Inversion.
     NAME         string        The name of this file or directory (a
                                basename). Of course, this is only
                                the name in this version. Names are
                                versioned like anything else.

                                If null, then this version's state
                                (see below) must be "dead" or
                                something similar.
     PROJECT      int [fkey]
                  (never null)  Foreign key into the projects table.
     VERSION      int           What version of the project this row
                  (never null)  is associated with.

                                Remember that every other entity in
                                this commit has the same version
                                number.
     NEXT_VERSION int           The next different version of this
                                entity.

                                Null means there is no different
                                future version. (?)
     PREV_VERSION int           The previous different version of
                                this entity (i.e., not necessarily
                                VERSION - 1). May cross projects (see
                                the `ancestor' column in the
                                `projects' table).

                                Null means this is the first version
                                of this entity.
     STATE        string        The state of this entity. This is
                  (never null)  primarily for death and resurrection
                                support, but may also be used to
                                record other states, if we can think
                                of any.
     CONTENTS     text          The contents of this version of the
                                entity.

                                If this row is at the most recent
                                version in the project, then this is
                                simply the full contents of the
                                object: in the case of a regular
                                file, then obviously it's the file's
                                contents; if a directory, then it's a
                                list (format to be determined) of the
                                entities in the directory; if a
                                symlink, the target of the symlink;
                                if device, the device parameters; and
                                so on.

                                If this is not the most recent
                                version, then the "contents" are
                                stored as a reverse binary diff from
                                the contents of the next version. For
                                directories, that diff is a list of
                                adds, deletes, and renames (again,
                                format details to be determined).

                                Null means this version does not
                                differ from the next version.
     LINE_MODS    text          For text files, change line-numbers
                                are recorded (as for text diffs), so
                                that deriving "cvs annotate"
                                information is cheap.

                                Null means this information is
                                unavailable or not applicable.
     TYPE         string        Regular file, or directory, or
                  (never null)  symlink, or hard link, or device,
                                etc.
     PROPERTIES   text          Meta-data, stored in a format to be
                                determined (probably key=value pairs,
                                like environment strings). This is
                                how permission information is
                                preserved, among other things.

                                Null means there are no properties,
                                though this is probably rare.
     PARENT_DIR   int [pkey]    The parent entity of this entity, in
                                this version (it had better be a
                                directory!).

                                Null means this is the root entity.

                                Note: this way of recording
                                tree-structure is questionable;
                                certain operations (tree-building!)
                                might be too expensive if we do
                                things this way. Another possibility
                                is that the `name' column is not a
                                basename, but a complete relative
                                path within the project. Still
                                thinking about this issue; see the
                                Meta-Implementation section farther
                                down.
     MERGE_METHOD string        The name of a merge method that
                                Inversion understands (right now
                                Inversion only knows how to do text
                                merges.) Normally, merging is only
                                possible between two versions which
                                are of the same TYPE.

                                Null means merges are not possible
                                with this entity.

*** The PROJECTS table

     PKEY            int               Internal unique identifier for
                                       this project. Users never see
                                       the pkey, only people trying
                                       to debug a problem in
                                       Inversion.

                                       This pkey may actually not be
                                       necessary; if not, then note
                                       that the `project' column in
                                       the `entities' table (see
                                       above) would reference
                                       projects by name (string)
                                       instead of fkey (int).
     NAME            string            The name of this project.
     DESCRIPTION     string            What's this project all about
                                       (for anon accessors).
     HIGHEST_VERSION int               Just what you think it is.
                     (never null)      Also known as the "tip".
     LOWEST_VERSION  int               Also what you think it is.
                     (never null)      Usually 1, but could be higher
                                       for projects with a non-null
                                       ancestor.
     ANCESTOR        int [fkey] or     If not null, then this project
                     string            is a "copy" (tag or branch) of
                                       some other project.

                                       One reason to use a string
                                       instead of an fkey would be to
                                       allow off-site ancestors. This
                                       would enable private,
                                       third-party branching -- way
                                       cool, although a few other
                                       things in this design would
                                       need to be tweaked to allow
                                       for that. We'll make sure that
                                       happens in the second design
                                       pass; this is still a rough
                                       draft.

                                       Also, debugging gets easier
                                       the fewer pkeys we use.
                                       Something to keep in mind...
     LOG_MSG_POLICY  bool              True iff log messages are
                                       required for this project.
     PUBLIC          bool              True iff this project allows
                                       anon access.

*** The COMMITS table

          This table is the last thing to get updated in a commit -- if you
          don't see it here, then the commit isn't done yet. (Actually, the
          timing issues may well be handled for free, if we use built-in
          database transaction support and the appropriately-named SQL
          "commit" command).

     PROJECT int [fkey] or string  Which project this commit belongs
             (never null)          to.
     VERSION int                   The version number of this commit.
             (never null)          Initial import gets 1.
     LOG_MSG text                  The log message for this commit.


*** The USERS table

     USERNAME           string  You know what this is.
     REALNAME           string  Same.
     EMAIL              string  Same.
     USE_SYSTEM         bool    Permit fall-back to system
                                authentication or not.
     PASSPHRASE or      ?       We're still figuring out how
     PUBLIC_KEY                 authentication works. We know that
                                repository users do not require
                                system accounts, at least.

*** The ACCESSES table

     USER        string        A username.
     PROJECT     int or        Projects this user is allowed to
                 string        access, and what kind of access is
                               allowed for each. Format to be
                               determined. (Referenced by fkey or
                               name? See similar discussions above.)
     ACCESS_TYPE ?             Format and meaning to be determined.
                               We can have anything from a simple
                               read-only vs read-write dichotomy, all
                               the way to listing the exact
                               operations that are permitted.

*** The INVERSION table

          Records a few server-specific things about this repository. Right
          now, we only know one column:

     IVN_RELEASE ? The release number (version, in the wider sense)
                   of the Inversion server that created or last
                   upgraded this repository. For compatibility: if we
                   add new columns, or new interpretations of old
                   columns, an upgraded server can tell what it needs
                   to do to upgrade the repository tables, for
                   example.


* Meta-implementation

This section describes the process of implementing Inversion -- what
order we do things in, and how.

The design needs to be evaluated across common operations, such as:
updating a project, updating <i>part</i> of a project, committing from
an up-to-date-working copy, committing from a non-up-to-date working
copy where the locally modified files are up-to-date, the same but
where the locally modified files are not up-to-date, the same but with
conflicts, tagging/branching, ... etc.  I am accumulating a list of
such operations; contributions welcome.

For each such operation, we need to step through what would happen in
the repository, so we'll discover bottlenecks in the design.

Once the design is ready, the parallizable parts of the software
should be determined, and tasks divvied up.  At this point or very
soon after, the client/server protocol needs to be designed too.  We
will evaluate WebDAV (using the same examination-under-common-ops
technique as with the data design); if WebDAV is suitable, it would be
a good choice, because it already has some political acceptability.

During the initial coding phase, everything that can be farmed out to
external programs will be.  For example, the diff routines will just
invoke xdelta and diff (or whatever), and the client side will invoke
an external patch.  In the long run, these things will very likely be
internalized for speed, but their semantics won't change when we do
that, and it's more important to get the stuff up and running as soon
as we can, and optimize afterwards.

There should be an automated test-suite.  It should not be written in
Bourne shell script (we can at least learn this lesson from CVS!).

Authentication questions will be put off until most of the software is
working, since they probably don't affect the rest of the design much.

* Jason's comments

I'll be responding to these here (or by adjusting parts of the
document above).  For now I'm just storing them here so we don't lose
them. :-)

--------------------8-<-------cut-here---------8-<-----------------------

From: Jason Elliot Robbins <jrobbins@collab.net>
Subject: Inversion feature outline (was: for meeting w/ Rational)
To: kfogel@red-bean.com
cc: jrobbins@collab.net, npm@collab.net, brian@collab.net, jon@collab.net
Date: Thu, 02 Mar 2000 19:02:47 -0800

Hi Karl,

Here are some comments I came up with while reading your Inversion
document on my last plane trip.  Overall this document looks like a
good start, but there is a lot to work out.

When would you like to put this document on the inversion.tigris.org
web site?


Here are my comments:

I know this is long, the best comments are 1, 7, 12, 14, and 17.

1. We should plan for web integration.  That could mean a lot of
things.  One idea off the top of my head is to actually use a URL for
the CVSROOT: I would make it an actual http:// scheme, rather than
some new ivn: scheme, so that there is a clear place to host a web
page with instructions about that repository.  Alternatively, we could
use a new scheme like ivn:argouml.tigris.org, so long as the CVSROOT
is very memorable to people who know the web address. Right now the
maping between projects (e.g., www.webmacro.org, or java.tigris.org)
and their CVSROOT varies a lot from site to site.  It would be nice to
make this a no brainer.

2. I would like to make the difficult things in CVS easier in Ivn.  I
think you mention that you would like to make things like moving files
and directories, etc. easier.  Actually, the second paragraph in
Meta-implementation is definately the right idea.  Looking at all the
multi-step proceedures outlined in your CVS book and making them one
step in Ivn would be great.

3. The concept of assigning a new version number to every file
everytime there is a commit is rather foreign to me.  Is this used in
other vc systems?  Are other people familiar with this practice?  Does
that mean that it would be very awkward to verbally tell someone to
check out a certain version (e.g., version 2378812, instead of 4.7)?
Would it be possible to tell at a glance how many versions a file has
gone through?

4. Why make keyword expansion off by default.   If I want to do it I
will have to search through the documentation to find the right
option.  I realize that it might mess up binary files, is there
another way to make that safe.

5. I really like the decision to make client/server the normal way of
doing things.  We need to concentrate on VC for open source projects
which are inheritently distributed.

6. I really like the concept of making a "copy" for every branch.
Actually, in object oriented design this concept is known as a
"virtual copy" and many operating systems (such as mach) support the
concept of "copy on write".  I think this concept leads very natually
to my next suggestion.

7. How about the idea of "local branches" that are stored on a
developer's working machine in addition to the local working copy of
the checked out files.  This is basically a fraction of the total
repository stored on each client.  The local reposiroty would be
filled in on demand, e.g., if you do a diff against an old version,
that version would be stored in your local repository.  Developers
could also commit to the local branch several times before eventually
merging into the central servers main branch.  If local branches are
accessable via the internet then we could basically do away with
patches.  If a developer does work that he wants to contribute back to
an open source project, he could just email the URL of his local
server.  Also, the concept of local branches could be generalized to
build a higherachy of servers with the global project home server at
the top and various mirrors in the middle, LAN servers near the
bottom, and each developers' local server at the bottom.  This has the
advantage that every developer can have commit access to some
repository, we get a range of trust rather than a boolean permisssion
to commit to the central server or not.

8. I would like to have some kind of plug-in permission system.  I am
wary of yet another set of user account records and permissions.  We
have found that half the tools we want to integrate into tigris has its
own user account system, and that makes a lot of duplicate data that
needs to be kept in synch.

9. Some of the data in your tables is not as normalized as it cood
be.  I know this may not be a priority, but here are some that I
noticed.: the names of entities and their states could be in separate
tables.  Line mods could be a table of line ranges rather than text, I
guess it depends on what format you were thinking of for that text
field, but it seems like you might do a lot of parsing.  The names of
properties in key value pairs could be stored in a properties names
table.

10.  I am a little concerned about storing the parent container
referenace and a basename.  I would like to have permissions limited
to a given scope that matches the complete path.  For example, I would
like to grant a particular developer the ability to commit
.*/dist/.*\.html but not any .java files or any file not in a
subdirectory of some dir named named api.  You have some of this in
your ACCESSES table.  For the sourcexchange.com web site we developed
a much more general permission scheme that you can read about at
http://joist.tigris.org. 

11. I would like to see some audit mechanism.  I think in this version
of the document you left off the basic ability to see who did each
commit.   More generally, we should consider the repositiory
administrator role in all its glory.  I dont want to require a lot of
administration work, but whatever needs to be done should be put under
the same "evaluation across operations" as we do for developer
operations.

12.  It would be nice if the server could be installed without root
access.  This would allow a lot more people to set up servers for
their local work group etc.  As a student, I never had root access to
a big machine, and a lto of people working on OS are students.  Some
small local server is also important to the local branch idea.  Apache
can be installed without having root access, and so can ezmlm mailing
lists, I really like that power for everyone.  The security
implications are good and it would surely simplify installation.

13. We should consider the following levels of internet connectivity:
high speed, low speed, disconnected (e.g., laptops and modems), flaky
connection.  Low speed constant connections (e.g., in distant
contries) might benefit from background filling in of their local
repository history.  Flaky connections might benefit from a resume
capability (I guess that comes for free in CVS, but we need to make
sure there are never any remaining lock files left on either end).

14. Would you consider implementing Inversion in Java.  The advantage
is that it runs on all platforms, and JDBC connects to all database,
and RMI would make the client-server implementation easier.  Web
integration with java servles would certainly be easier.  Speed is
somewhat of an issue, but java is pretty fast now and a lot of the
speed will be determined by the database rather than our code.  I am
not concerned about CPU-bound speed problems because processors are
getting insanely fast and we can have fast machines in our racks.
Speed could be a problem for small (student) projects that dont have
good machines, but then again "small project" implies that they
probably dont have that many concurrent accesses anyway.  I think
selling inversion as "version control that you actually want to use"
trumps speed claims anyway, we should make it easy in use and easy to
enhance.  Java would also give us no-brainer internationalization
support.  

15. Compression.  It would be great if the protocol batched up all the
files that need to be transfered for a given transaction and then
compressed the whole set of files using a standard zip algorithm or
something.  Typically compressing many similar files can give better
results than compressing each indepently.  This is assuming
dictionary-based compression, I think.

16. What is the import/export format for this?  Would I just do a
mysqldump? Should there be an XML file format for versions and log
entries and such?

17. It would be nice to have scripts executed for any possible
action.  CVS has scripts that run on many actions, e.g., commit and
tagging.    Actually, if we use java it would be possible to define a
sandbox to run these scripts safely.  That would allow developers to
upload "inversion agents" that are .class files invoked whenever an
action is taken on the server and do some kind of testing or
notification on behalf of that particular developer.  This could be a
good hook for integrating Inversion with a server-farm build system,
implementing the hierarchy of servers described in suggestion #7.

18.  You have specified that the contents of the source files should
be in the database.  An alternative woulf be to just have the name of
some file in the file system.  Could you explore/explain that tradeoff?




jason!

======================================================================
Jason Robbins, Ph.D.      Collab.Net is hiring open source developers!
Senior Software Engineer                    http://www.collab.net/jobs
======================================================================
