
A proposal for an svn filesystem dump/restore format.

Two problems we want to solve
=============================

 1.  When we change our node-id schema, we need to migrate all of our
     data (by dumping and restoring).

 2.  Serves as a backup format.  Could be read by other software tools
     someday.


Design Goals
============

 A.  Written as two new public functions in svn_fs.h.  To be invoked
     by new 'svnadmin' subcommands.

 B.  Format uses only timeless fs concepts.

     The dump format needs to reference concepts that we *know* are
     general enough to never change.  These concepts must exist
     independently of any internal node-id schema, or any DB storage
     backend.  In other words, we're talking about the basic ideas in
     our original "design spec" from May 2000.


Format Semantics
================

Here are the timeless semantics of our fs design -- the things that
would be stored in our dump format.

  - A filesystem is an array of trees.
    Each tree is called a "revision" and has unversioned properties attached.

  - A revision has a tree of "nodes" hanging off of it.
    Actually, the nodes in the filesystem form a DAG.  A revision
    always points to an initial node that represents the 'root' of some tree.
 
  - The majority of a tree's nodes are hard-links (references) to
    nodes that were created in earlier trees.

  - A node contains 

        - versioned text
        - versioned properties
        - predecessor history:  "which node am I a variant of?"
        - copy history:  "which node am I a copy of?"

    The history values can be non-existent (meaning the node is
    completely new), or can have a value of {revision, path}.

-----------------------------------------------------------------

# PROPOSAL NUMBER 1

# Okay, here's my first draft of a binary format for a filesystem
# dump.  As mentioned before, it contains nothing but the abstract
# structure of the filesystem -- independent of any node-id schema or
# database back-end.  All of the data in this file can be acquired by
# public function calls into svn_fs.h.  Similarly, one hopes that the
# parser of this file can *rebuild* the fs using only public svn_fs.h
# routines.

# As gstein suggested, we're using rfc822-style headers to label
# logical chunks of data.

# The thing that makes this format -Large- is the fact that we're
# storing bubble-up information.  Every bubbled-up directory is in
# here, complete with node-ids.

# Here is what a node looks like:

# Each node has a unique ID, an opaque svn_fs_id_t.  By using
# svn_fs_unparse_id, we can get a unique string_t blob to write out.
# Later on, when something parses this file, the blob is opaque and
# meaningless, but still acts as a unique identifier when rebuilding
# a filesystem.
Node-id-length:  13
[node-id follows]

# Where this node was created, and its kind.
Revision: 1422
Path:  foo/bar/baz/bop
Node-kind: file | dir

# This node was deleted in this revision, OR,
# This node was added in this revision -- possibly with copy history, OR
# This node was changed in this revision.
#
#   note1:  if added and Path already exists, infer a replacement.
#   note2:  'changed' field is *only* so we detect pure bubble-up nodes;
#           bubbled-up nodes won't have it at all.
Action:  deleted | added | changed

# Was this node copied from another revision and path?
Copied-from: [revision, path]

# For property lists, I'm reusing the same hashtable-on-disk format
# that we currently use to write propfiles.  It's a simple way of
# mapping const char * -> svn_string_t *.  It's human readable
# (assuming your values aren't binary data), and most importantly, we
# already have a parser for this format!
Node-properties:
K 12
svn:keywords
V 15
LastChangedDate
K 14
svn:executable
V 2
on
END

# If the node is a file, then we store its fulltext like so:
Text-checksum: [md5 checksum on fulltext]
Content-length:  N
[N bytes of data follow]

# If the node is a directory, then we give a list of dirents.  I
# realized that this is just another hashtable like our props, mapping
# (const char *) names to (svn_string_t *) node-ids.  So it makes
# sense to use the same hash-on-disk format here as well.
Directory-entries:
K 6
README
V 8
[some node id]
K 10
autogen.sh
V 9
[some node id]
END


# Here's what a revision looks like, pretty simple.
Revision-number:  1422
Revision-root-node:  ID
Revision-properties: 
...
...
...
END

----------------------------------------------------------------

# PROPOSAL NUMBER 2

# This format is much, much smaller in terms of disk space.  It
# doesn't mention node-ids at *all*, because it leaves out *all*
# bubble-up nodes.  Really, it's essentially what an editor would
# output during a commit: only changed nodes.  Directories don't list
# entries at all.

# The tradeoff here is that it's more work to reconstruct a particular
# revision from the middle of a dumpfile.  For example, if I have a
# dumpfile for revisions 1 to 500, and somebody wants to reconstruct
# (load) revision 300 into a repository, the *only* way to do this is
# by replaying commits 1-299 into some temporary repository.

# Where this node was created, and its kind.
Revision: 1422
Path:  foo/bar/baz/bop
Node-kind: file | dir

# No need for 'changed' verb:  that was only for distinguishing
# between bubble-up dirs and dirs with changed props.
Action:  deleted | added

# Was this node copied from another revision and path?
Copied-from: [revision, path]

# Property list.
Node-properties:
K 12
svn:keywords
V 15
LastChangedDate
K 14
svn:executable
V 2
on
END

# If the node is a file, then we store its fulltext like so:
Text-checksum: [md5 checksum on fulltext]
Content-length:  N
[N bytes of data follow]

# If the node is a directory, then we add nothing.  No need for dirents.


# Here's what a revision looks like.  No root-node-id needed.
Revision-number:  1422
Revision-properties: 
...
...
...
END
