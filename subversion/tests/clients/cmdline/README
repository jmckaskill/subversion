                      (-*- text -*-)

            Test suite for the command line client.
            =======================================

The cmdline client test suite doesn't use the C-level testing
framework, but is structured similarly.  Instead of testing library
APIs, it drives the client just like a user would, examining the
output and the on-disk results (i.e., the working copy) carefully as
it goes.  Python is the chosen scripting language.

*** For general information on Subversion's testing system, please read
    the README in subversion/tests/.  ***


Automated Test Verification
---------------------------

The point of this test system is that it's *automated*:  that is, each
test can algoritmically verify the results and indicate "PASS" or
"FAIL". 

We've identified two broad classes of verification:

  1.  Verifying svn subcommand output.

      Most important subcommands (co, up, ci, im, st) print results to
      stdout as a list of paths.  Even though the paths may be printed
      out in an unpredicable order, we still want to make sure this
      list is exactly the *set* of lines we expect to get.

  2.  Verifying the working copy itself.

      Every time a subcommand could potentially change something on
      disk, we need to inspect the disk.  Specifically, this means:

         * user-data:  we need to make sure the working copy has
           exactly the tree-structure we expect, and each file has
           exactly the contents we expect.  We also need to look at
           all user-specified properties.

         * metadata:  we need to examine all the 'entries' files.


The General Solution:  Trees
----------------------------

Sam TH <sam@uchicago.edu> proposed and began work on a solution
whereby all important, inspectable information is parsed into a
general, in-memory tree representation.

By comparing actual vs. expected tree structures, we get automated
verification.


Specific Tree Solutions
-----------------------

Each node in our generic trees have these fields:

  - name :  the name of the node  (the basename of the path)
  - children:  list of child nodes (if the node is a dir)
  - contents:  textual contents (if the node is a file)
  - properties:  a dictionary (hash) of attributes/metadata

  * subcommand output

    svntest.tree.* provides functions to parse commandline output into
    a tree.

         checkout/update:  a 'status' property is set to a two-character
                           value (from the set (A, D, G, U, C, _, ' '))

         status:           a 'status' property (as above), plus two props
                           to hold the WC and Repos revision numbers.

         commit/import:    a 'verb' attribute is set to one of
                           (Adding, Changing, Deleting)

   * disk verification

     svntest.tree.* also has routines that walk a regular working copy
     and returns a tree representing disk contents

   * `entries' files

       We need a function that can assemble all the 'entries' files
       into a tree.  The 'contents' field can be ignored;  xml
       attributes can be directly copied into our tree nodes'
       'properties'. 

       NOTE: Because directory entries are located in *two* places --
       as the "" entry in its own entries file, and by its own name as
       a 'subdir' entry in its parent -- we have to be careful to that
       this information is preserved.  This can be done by cleverly
       prefixing a directory's property keys with "THIS_DIR:" and
       "subdir:".



------------------------------------------------------------------

The files in this directory:



* local_tests.py:        tests: client operations using ra_local.

* svntest/               subversion test framework, as a python package.

    * main.py:               global vars, utility routines.
                             exports run_tests(), the main test routine.

    * svn_tree.py:           infrastructure for SVNTreeNode class.

                             * tree constructors, tree comparison routines.

                             * routines to parse subcommand output into
                               specific kinds of trees.

                             * routines to parse a working copy and
                               entries files into specific kinds of trees.

    * entry.py               parse an `entries' file (not used yet)



 * example_tests1.py:     template test script.
                          demonstrates how to write tests and then
