
                ================================
                 A Subversion Testing Framework
                ================================


The three goals of Subversion's automated test-suite:

      1.  It must be easy to run.
      2.  It must be easy to understand the results.
      3.  It must be easy to add new tests.


Makefile.am
-----------

Automake defines a TESTS variable which is a list of tests to run
whenever someone types `make check'.

However, we're not using this facility -- it's too inflexible.  It
doesn't give us good control of results reporting.  (Specifically, we
can't stop it from spamming the terminal.)

Instead, our Makefile.am's contain a SVN_TESTS variable (a list of
programs to run), and a home-made `check' target.

A `make check` will run each program in SVN_TESTS and only print a
description *if a test fails*.  All test results are logged to a file
called `tests.log'.


Definition of an SVN "test program"
---------------------------------------

A Subversion test program is any executable that contains a number of
sub-tests it can run.  It has a standard interface:

1.  If run with a numeric argument N, the program runs sub-test N.

2.  If run with no arguments, the program runs *all* sub-tests.

3.  The program returns either 0 (success) or 1 (if any sub-test failed).

4.  Upon finishing a test, the program reports the results in a format
    which is both machine-readable (for the benefit of automatic
    regression tracking scripts), and human-readable (for the sake of
    painstaking grovelling by hand in the dead of night):

      (PASS | FAIL): (argv[0]) (argv[1]): (description)

For example,

  [sussman@newton:~] ./frobtest 2
  PASS: frobtest 2: frobnicating fragile data
  [sussman@newton:~] 


How to write new tests
----------------------

All test programs use a standard `main' function.  You write .c files
that contain only test functions --- you should not define your own
`main' function.

Instead, your code should define an externally visible array
`test_funcs', like this:

    /* The test table.  */

    int (*test_funcs[]) (const char **msg) = {
      0,
      test_a,
      test_b,
      test_c,
      0
    };

In this example, `test_a', `test_b', and `test_c' are the names of
test functions.  The first and last elements of the array must be
zero.  The first zero is there to leave room for Buddha.  The standard
`main' function searches for the final zero to determine the size of
the array.

Each test function has the following type:

	int f (const char **NAME);

When called, a test function should set *NAME to its name, and perform
a test.  If the test passes, the function should return zero;
otherwise, it should return one.

Once you've got a .c file with a bunch of tests and a `test_funcs'
array, you should link it against the `libsvn_tests_main.la' libtool
library, in this directory, `subversion/tests'.  That library provides
a `main' function which will check the command-line arguments, pick
the appropriate tests to run from your `test_funcs' array, and print
the results in the standard way.


When to write new tests
-----------------------

In the world of CVS development, people have noticed that the same
bugs tend to recur over and over.  Thus the CVS community has adopted
a hard-and-fast rule that whenever somebody fixes a bug, a *new* test
is added to the suite to specifically check for it.  It's a common
case that in the process of fixing a bug, several old bugs are
accidentally resurrected... and then quickly revealed by the test
suite.

This same rule should apply to Subversion development: ** If you fix a
bug, write a test for it. **

(However, we should note that this rule is somewhat relaxed until
Subversion hits 1.0.  A majority of pre-1.0 bugs are due to the code
being in the "initial growth" stage.)


Conclusion
----------

Our test suite...


  1.  ...must be easy to run.

      * run `make check` at any level of the tree

  2.  ...must be easy to understand the results.

      * test programs output standardized messages
      * all messages are logged
      * `make check` only displays errors (not successes!)

  3.  ...must be easy to add new tests.

      * add your own routine to an existing test program, or
      * add a new test program to Makefile.am, using our template .c code



