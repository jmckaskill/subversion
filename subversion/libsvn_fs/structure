Subversion on Berkeley DB

There are many different ways to implement the Subversion filesystem
interface.  You could implement it directly using ordinary POSIX
filesystem operations; you could build it using an SQL server as a
back end; you could build it on RCS; and so on.

This implementation of the Subversion filesystem interface is built on
top of Berkeley DB (http://www.sleepycat.com).  Berkeley DB supports
transactions and recoverability, making it well-suited for Subversion.



Nodes and Node Revisions

In a Subversion filesystem, a `node' corresponds roughly to an
`inode' in a Unix filesystem:
- A node is either a file or a directory.
- A node's contents change over time.
- When you change a node's contents, it's still the same node; it's
  just been changed.  So a node's identity isn't bound to a specific
  set of contents.
- If you rename a node, it's still the same node, just under a
  different name.  So a node's identity isn't bound to a particular
  filename.

A `node revision' refers to a node's contents at a specific point in
time.  Changing a node's contents always creates a new revision of that
node.  Once created, a node revision's contents never change.

When we create a node, its initial contents are the initial revision of
the node.  As users make changes to the node over time, we create new
revisions of that same node.  When a user commits a change that deletes
a file from the filesystem, we don't delete the node, or any revision
of it --- those stick around to allow us to recreate prior revisions of
the filesystem.  Instead, we just remove the reference to the node
from the directory.



ID's

Within the database, we refer to nodes and node revisions using strings
of numbers separated by periods that look a lot like RCS revision
numbers.

  node_id ::= number | node_revision_id "." number
  node_revision_id ::= node_id "." numberh

So: 
- "100" is a node id.
- "100.10" is a node revision id, referring to revision 10 of node 100.
- "100.10.3" is a node id, referring to the third branch based on
  revision 10 of node 100.
- "100.10.3.4" is a node revision id, referring to revision 4 of
  of the third branch from revision 10 of node 100.
And so on.

Node revision numbers start with 1.  Thus, N.1 is the first revision
of node N.

Node / branch numbers start with 1.  Thus, N.M.1 is the first
branch off of N.M.

A directory entry identifies the file or subdirectory it refers to
using a node revision number --- not a node number.  This means that
a change to a file far down in a directory hierarchy requires the
parent directory of the changed node to be updated, to hold the new
node revision ID.  Now, since that parent directory has changed, its
parent needs to be updated.

If a particular subtree was unaffected by a given commit, the node
revision ID that appears in its parent will be unchanged.  When
doing an update, we can notice this, and ignore that entire
subtree.  This makes it efficient to find localized changes in
large trees.

Note that the number specifying a particular revision of a node is
unrelated to the global filesystem revision when that node revision
was created.  So 100.10 may have been created in filesystem revision
1218; 100.10.3.2 may have been created any time after 100.10; it
doesn't matter.

Since revision numbers increase by one each time a delta is added,
we can compute how many deltas separate two related node revisions
simply by comparing their ID's.  For example, the distance between
100.10.3.2 and 100.12 is the distance from 100.10.3.2 to their
common ancestor, 100.10 (two deltas), plus the distance from 100.10
to 100.12 (two deltas).

However, this is kind of a kludge, since the number of deltas is
not necessarily an accurate indicator of how different two files
are --- a single delta could be a minor change, or a complete
replacement.  Furthermore, the filesystem may decide arbitrary to
store a given node revision as a delta or as full text --- perhaps
depending on how recently the node was used --- so revision id
distance isn't necessarily an accurate predictor of retrieval time.

If you have insights about how this stuff could work better, let me
know.  I've read some of Josh MacDonald's stuff on this; his
discussion seems to be mostly about how to retrieve things quickly,
which is important, but only part of the issue.  I'd like to find
better ways to recognize renames, and find appropriate ancestors in
a source tree for changed files.

When we need to treat a node or node revision ID as a string of bytes,
we use the forms shown here --- a series of unsigned ASCII decimal
numbers, separated by dots.


NODE-REVISION and HEADER: how we represent a node revision

We represent a given revision of a file or directory node using a list
skel (see skel.h for an explanation of skels).  A node revision skel
has the form:

    (HEADER KIND-SPECIFIC ...)

where HEADER is a header skel, whose structure is common to all nodes,
and the KIND-SPECIFIC elements carry data dependent on what kind of
node this is --- file, directory, etc.

HEADER has the form:

    (KIND PROPLIST FLAG ...)

where:
- KIND indicates what sort of node this is,
- PROPLIST is the node's property list, and
- FLAG ... is a sequence of zero or more flags.

KIND must be one of the following:
- "file", indicating that the node is a file (see FILE below).
- "dir", indicating that the node is a directory (see DIR below).

There are no FLAGS defined at the moment.  But if had any, that's
where we'd put them.

Note that a node cannot change its kind from one revision to the next.
A directory node is always a directory; a file node is always a file;
etc.  The fact that the node's kind is stored in each node revision,
rather than in some revision-independent place, might suggest that it's
possible for a node change kinds from revision to revision --- 10.3
could be a directory, while 10.4 could be a file --- but Subversion
does not allow this.

We store the node kind in the node revision for simplicity.  This way,
we can store *everything* about a node in the node revisions --- we
don't need the complexity of a separate per-node structure, or the
overhead of looking in two places.


FILE: how files are represented.

If a NODE-REVISION's header's KIND is "file", then the node-revision
skel represents a file, and has the form:

    (HEADER DATA)

where DATA is an atom giving the full contents of the file.  (In the
future, DATA may have other alternate forms, indicating that the
fulltext of the file is stored elsewhere in the database, or perhaps
in an ordinary Unix file.)


DIR: how directories are represented.

If the header's KIND is "dir", then the node-revision skel
represents a directory, and has the form:

    (HEADER (ENTRY ...))

The list (ENTRY ...) gives the directory entries; each ENTRY has the form:

    (NAME ID [BASE-PATH])

where:
  - NAME is the name of the directory entry, in UTF-8,
  - ID is the ID of the node revision to which this entry refers, and
  - for clones in unfinished transactions, BASE-PATH is the name the
    node had in the transaction's base revision, if that is different from
    its path in the transaction.  BASE-PATH is explaned in more detail in
    `Cloning', below.


PROPLIST: property lists for nodes and directory entries

A property list is a list skel of the form:

    (NAME1 VALUE1 NAME2 VALUE2 ...)

where each NAMEi is the name of a property, and VALUEi is the value of
the property named NAMEi.  Every valid property list has an even
number of elements.



REPRESENTATION: how Subversion stores many similar node revisions efficiently

It would be correct, but not efficient, to store Subversion filesystem
nodes simply as a table mapping node revision ID's onto NODE-REVISION
skels, as described above.  However, in this application we know that
successive revisions of files and directories will often be very
similar to each other, so compression can be very effective.

Instead of storing straight NODE-REVISION skels, we store
REPRESENTATION skels, whose job is to provide enough information to
construct a complete NODE-REVISION skel.  At the moment, there are only
two forms of REPRESENTATION skels:

("fulltext" NODE-REVISION)
    We store the complete text of the node revision, NODE-REVISION.

("younger" DELTA CHECKSUM)
    We store a delta that transforms the next younger revision of the
    node into this revision.  To find the contents of this revision:

    - We find the unparsed form of the NODE-REVISION skel for the next
      younger revision.

    - We apply DELTA to that string, yielding the unparsed form of the
      NODE-REVISION skel for this revision.

    To be sure that we've reconstructed the node revision correctly, we
    store a checksum of the unparsed form of this revision's
    NODE-REVISION skel.  We compare this against the checksum of the
    result from applying the DELTA.

At present, Subversion stores the youngest revision of every node and
branch in "fulltext" form, and stores all other revisions in "younger"
form.  However, there's nothing magic about that particular
arrangement.  Other interesting alternatives:

- We could store the N most recently accessed node revisions as
  fulltext, letting access patterns determine the most appropriate
  representation for each revision.

- We could occasionally store deltas against the N'th younger revision,
  storing larger jumps with a frequency inverse to the distance
  covered, yielding a tree-structured history.

Since the filesystem interface doesn't expose these details, we can
change the representation pretty much as we please to optimize
whatever parameter we care about --- storage size, speed, robustness,
etc.


DELTA: how we represent text deltas

The job of a DELTA form is to describe how to turn one byte string
(the `source' string) into another (the `target' string).  The context
of the DELTA form needs specify exactly what the source and target
strings are.

At the moment, there is only one form of DELTA allowed:

("svndiff" DATA)
    DATA is an atom whose contents are a VCDIFF-form diff.


CHECKSUM: how we represent checksums

The job of a CHECKSUM form is to provide a constant-size distinctive
value, computed entirely from a given string.  If two strings have
different checksums, then we know those two strings must be different.
Assuming we use a good checksum algorithm, if two strings have the
same checksum, it is likely that the strings are equal.

There is only one form of CHECKSUM skel at the moment:

("md5" BYTES)
    BYTES is the 128-bit MD5 hash value of the string.



The Berkeley DB "nodes" table

The database contains a table called "nodes", which is a btree indexed
by node revision ID's, mapping them onto REPRESENTATION skels.  Node 0
is always the root directory, and node revision 0.0 is always the empty
directory.

Since the "nodes" table is a btree, it's efficent to walk over the
entries in order of increasing or decreasing node ID's.  In fact,
Berkeley DB lets us provide our own key ordering function, so we can
arrange the nodes for quick traversal, given our access patterns.

Here's the sort order we use:

- Nodes are sorted by their node number.
- All the revisions of a given node come together, in order of 
  increasing revision number.
- All branches off any revision of a node come immediately after that
  node, ordered by increasing revision number.

For example, the "nodes" table might have the following sequence of
keys:

13.1     ; the original node, with four revisions
13.2
13.3
13.4
13.2.1.1   ; a branch from the second revision of 13, with three revisions
13.2.1.2
13.2.1.3
13.2.2.1   ; another branch off the same revision of 13, with four revisions
13.2.2.2
13.2.2.3
13.2.2.4
13.4.1.1   ; another branch off a later revision of 13, with two revisions
13.4.1.2
14.1     ; another node
14.2
14.3

We can find the latest revision of node N by searching the `nodes'
table for the last entry before N.1.1.1, the first branch off the
node's first revision.  According to the sort order, this node
immediately follows the last revision of node N.

Similarly, we can find the last branch off a given node revision N.V by
searching the `nodes' table for the last entry before N.(V+1).1.1.
According to the sort order, this node immediately follows the last
descendant of of N.V.  This last descendent could be a branch off a
branch off a branch ..., but by truncating the node revision ID
appropriately, we can find the last branch off of N.V.

Assuming that we store the most recent revision on every branch as
fulltext, and all other revisions as deltas, we can retrieve any node
revision NODE.REVISION by searching for the last revision of NODE, and
then walking backwards to NODE.REVISION, applying deltas as we go.

Since we don't want to corrupt our btree, even if we accidentally
insert garbage keys into the table, we extend our ordering to handle
arbitrary byte strings: any mis-formed ID comes before any well-formed
ID, and two mis-formed IDs are compared byte-by-byte.


REVISION: filesystem revisions, and the Berkeley DB "revisions" table

We represent a filesystem revision using a skel of the form:
    ("revision" ID PROPLIST)
where:
- ID is the node revision ID of this revision's root directory, and
- PROPLIST is the revision's property list.

The database contains a table called "revisions", which is a
record-number table mapping revision numbers onto REVISION skels.
Since Berkeley DB record numbers start with 1, whereas Subversion
filesystem revision numbers start at zero, revision V is stored as
record number V+1 in the `revisions' table.  Filesystem reevision zero
always has node revision 0.0 as its root directory; that node revision
is guaranteed to be an empty directory.


Transactions

Every transaction ends when it is either successfully committed, or
aborted.  We call a transaction which has been either committed or
aborted "finished", and one which hasn't "unfinished".  

Transactions are identified by positive decimal numbers, called
transaction ID's.  To help clients detect when a transaction has been
finished, transaction ID's are never reused.  In the database, we
always represent a tranasction ID in its shortest ASCII decimal form.

The Berkeley DB `transactions' table records unfinished transactions.
Every key in this table is a transaction ID, and every value is a skel
of the form:

    (ROOT-ID BASE-ROOT-ID)

where ROOT-ID is the node revision ID of the transaction's root
directory, and BASE-ROOT-ID is the node revision ID of the root of the
transaction's base revision.

As the sole exception to the rule above, the `transactions' table
always has one entry whose key is `next-id', and whose value is the
lowest transaction ID that has never yet been used.  We use this entry
to allocate ID's for new transactions.

The `transactions' table is a btree, sorting keys in order of
increasing numerical value.  The `next-id' key comes after all
transaction ID's.


Cloning

As we make changes to an unfinished transaction, we clone each node
whose contents we need to change.  Since multiple processes may want
to work on a transaction at the same time, the database needs to
provide enough information for each process to observe the cloning
done by the other processes.

In particular, if process A holds a reference to an uncloned node, and
then process B clones that node, or some of its parents, process A
must be able to find the clones created by B in order to correctly
make its own changes to the node.

The Berkeley DB `clones' table provides enough information to do this
tracking.  Every key in `clones' is a skel of the form:

    (TXN BASE-PATH)

where TXN is the ID of a transaction, and BASE-PATH is the path of
some node revision in the revision tree on which TXN is based.  Each
value associated with one of these keys is a skel of one of the
following forms:

    (cloned CLONE)
        This means that the named node has been cloned in TXN; CLONE
	is the clone's node revision ID.
    (moved PARENT-CLONE ENTRY-NAME)
        This means that the named node has been moved (renamed) in the
        transaction, and the entry referring to it is now the
        directory entry named ENTRY-NAME in the directory whose node
        revision ID is PARENT-CLONE.  Note that PARENT-CLONE must be
        a clone in TXN, since its contents have been modified.

Thus, we can use the following algorithm to clone a node in TXN whose
name in the base revision is BASE-PATH:

If BASE-PATH is empty:
  We're trying to clone the root.  The transaction's record in
  `transactions' tells us whether its root has been cloned yet; that's
  where we record things.
Otherwise:
  Check the `clones' table for an entry for (TXN BASE-PATH).
  If there is an entry of the form (cloned CLONE):
    Our node has already been cloned, and CLONE is the clone's ID.
  If there is an entry of the form (moved PARENT-CLONE ENTRY),
    Create our own clone of BASE-PATH, CLONE.
    Change the entry in `clones' to (cloned CLONE).
    Change the entry named ENTRY-NAME in PARENT-CLONE to point to CLONE.
  If there is no entry in `clones':
    The directory path BASE-PATH contains at least one component;
    divide it into its rightmost component, LAST, and the path leading
    up to that, BASE-PARENT.
    Recurse on this process to create a clone of BASE-PARENT, whose ID
    is PARENT-CLONE.
    Create a clone of our node, CLONE.
    Add an entry in `clones' for (TXN BASE-PATH) whose value is (cloned CLONE).
    Change the entry named LAST in PARENT-CLONE to point to CLONE.

Since clone tracking is based on nodes' names in the base revision, we
must always be able to find a node's base name, even if we reached
that node through cloned nodes.  To this end, whenever we move an
uncloned node, we record its original base name in the new directory
entry referring to it.  This is the BASE-PATH element of the directory
entry, described above.


Merge rules

The Subversion filesystem must provide the following characteristics:

- clients can submit arbitrary rearrangements of the tree, to be
  performed as atomic changes to the filesystem tree
- multiple clients can submit non-overlapping changes at the same time,
  without blocking
- readers must never block other readers or writers
- writers must never block readers
- writers may block writers

Merging rules:

   The general principle: a series of changes can be merged iff the
   final outcome is independent of the order you apply them in.

Merging two nodes, A and B, with respect to a common ancestor
ANCESTOR:
- First, the merge fails unless A, B, and ANCESTOR are all the same kind
  of node.
- If A and B are text files:
  - If A is an ancestor of B, the B is the merged result.
  - If A is identical to B, then B (arbitrarily) is the merged result.
  - Otherwise, the merge fails.
- If A and B are both directories:
  - For every directory entry E in either A, B, or ANCESTOR, here are
    the cases:
      - E exists in neither ANCESTOR nor A.
      - E doesn't exist in ANCESTOR, and has been added to A.
      - E exists in ANCESTOR, but has been deleted from A.
      - E exists in both ANCESTOR and A ...
	- but refers to different nodes.
	- but refers to different revisions of the same node.
	- and refers to the same node revision.

    The same set of possible relationships with ANCESTOR holds for B,
    so there are thirty-six combinations.  The matrix is symmetrical
    with A and B reversed, so we only have to describe one triangular
    half, including the diagonal --- 21 combinations.

    - (6) E exists in neither ANCESTOR nor A:
      - (1) E exists in neither ANCESTOR nor B.  Can't occur, by assumption
	   that E exists in either A, B, or ancestor.
      - (1) E has been added to B.  Add E in the merged result. ***
      - (1) E has been deleted from B.  Can't occur, by assumption that E
	doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption that
        E doesn't exist in ancestor.
    - (5) E doesn't exist in ANCESTOR, and has been added to A.
      - (1) E doesn't exist in ANCESTOR, and has been added to B.  Conflict.
      - (1) E exists in ANCESTOR, but has been deleted from B.  Can't occur,
        by assumption that E doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption
        that E doesn't exist in ANCESTOR.
    - (4) E exists in ANCESTOR, but has been deleted from A.
      - (1) E exists in ANCESTOR, but has been deleted from B.  If
        neither delete was a result of a rename, then omit E from the
        merged tree.  *** Otherwise, conflict.
      - E exists in both ANCESTOR and B ...
        - (1) but refers to different nodes.  Conflict.
        - (1) but refers to different revisions of the same node.  Conflict.
        - (1) and refers to the same node revision.  Omit E from the merged
          tree. ***
    - (3) E exists in both ANCESTOR and A, but refers to different nodes.
      - (1) E exists in both ANCESTOR and B, but refers to different
        nodes.  Conflict.
      - (1) E exists in both ANCESTOR and B, but refers to different
        revisions of the same node.  Conflict.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node revision.  Replace E with A's node revision.  ***
    - (2) E exists in both ANCESTOR and A, but refers to different
      revisions of the same node.
      - (1) E exists in both ANCESTOR and B, but refers to different revisions
        of the same node.  Try to merge A/E and B/E, recursively.  ***
      - (1) E exists in both ANCESTOR and B, and refers to the same node
        revision.  Replace E with A's node revision.   ***
    - (1) E exists in both ANCESTOR and A, and refers to the same node
      revision.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node revision.  Nothing has happened to ANCESTOR/E, so no change
        is necessary.

*** == something actually happens


Non-Historical Properties

[[Yes, do tell.]]



Layers

I'm having trouble keeping track of exactly who has implemented which
promises, based on which other promises from whom.  I hope this will
help me keep the arrangement straight, and make the code more
reliable.  The files are arranged in order from low-level to
high-level: each file depends only on services provided by the files
before it.


skel.c, id.c, dbt.c, convert-size.c

		Low-level utility functions.

fs.c		Creating and destroying filesystem objects.

err.c		Error handling.

nodes-table.c, txn-table.c, clones-table.c, rev-table.c

		Create and open particular database tables.
		Responsible for intra-record consistency.

node-rev.c      Creating, reading, and writing node revisions.
		This will handle delta-based node revision storage,
		Responsible for consistency of 

dag.c		Operations on the DAG filesystem.  "DAG" because the
		interface exposes the filesystem's sharing structure.
		Enforce inter-record consistency.

tree.c		Operations on the tree filesystem.  This layer is
		built on top of dag.c, but transparently distinguishes
		virtual copies, making the underlying DAG look like a
		real tree.  This makes incomplete transactions behave
		like ordinary mutable filesystems.  Most of the

delta.c		Computing deltas.


Appendix: Filesystem structure summary
======================================

Berkeley DB tables
------------------

                "nodes" : btree(ID -> REPRESENTATION)
            "revisions" : recno(REVISION)
         "transactions" : btree(TXN -> TRANSACTION,
                                "next-id" -> TXN)
               "clones" : btree((TXN BASE-PATH) -> CLONE)


Syntactic elements
------------------

Table keys:

                     ID ::= node.id ;
                    TXN ::= number ;
##            BASE-PATH ::= [xbc todo: whatzis?]


Nodes:

         REPRESENTATION ::= ("fulltext" NODE-REVISION)
                          | ("younger" DELTA CHECKSUM) ;
                  DELTA ::= ("svndiff" DATA) ;
               CHECKSUM ::= ("md5" BYTES) ;
            DATA, BYTES ::= atom ;


Filesystem revisions:

               REVISION ::= ("revision" ID PROPLIST) ;
               PROPLIST ::= (PROP ...) ;
                   PROP ::= atom atom ;


Transactions:

            TRANSACTION ::= (ROOT-ID BASE-ROOT-ID) ;
                ROOT-ID ::= node.id ;
           BASE-ROOT-ID ::= node.id ;


Clones:

                  CLONE ::= ("cloned" CLONE-ID)
                          | ("moved" PARENT-CLONE-ID ENTRY-NAME);
               CLONE-ID ::= node.id ;
        PARENT-CLONE-ID ::= node.id ;
             ENTRY-NAME ::= atom ;


Node revisions:

          NODE-REVISION ::= FILE | DIR ;
                   FILE ::= (HEADER DATA) ;
                    DIR ::= (HEADER (ENTRY ...)) ;
                  ENTRY ::= (NAME ID) | (NAME ID BASE-PATH) ;
                   NAME ::= atom ;


                 HEADER ::= (KIND PROPLIST FLAG ...) ;
                   KIND ::= "file" | "dir" ;
                   FLAG ::= skel ;



Lexical elements
----------------

Node & revision IDs:

                node.id ::= number | node.revision-id '.' number ;
       node.revision-id ::= node.id '.' number ;
                 number ::= /{digit.class}+/ ;


(Note: the following are described in skel.h)
Skels:

                   skel ::= atom | list;
                   list ::= list.head list.body.opt list.tail ;
                   atom ::= atom.imp-len | atom.exp-len ;

              list.head ::= '(' spaces.opt ;
              list.tail ::= spaces.opt ')' ;
          list.body.opt ::=  | list.body ;
              list.body ::= skel | list.body spaces.opt skel ;

           atom.imp-len ::= /{name.class}[^{ws.class}]*{ws.class}/ ;
           atom.exp-len ::= /({digit.class}+){ws.class}.{\1}/ ;

             spaces.opt ::= /{ws.class}*/ ;


Character classes:

               ws.cpass ::= [\t\n\f\r\ ] ;
            digit.class ::= [0-9] ;
            name.class  ::= [A-Za-z] ;
