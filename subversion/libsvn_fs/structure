Subversion on Berkeley DB

There are many different ways to implement the Subversion filesystem
interface.  You could implement it directly using ordinary POSIX
filesystem operations; you could build it using an SQL server as a
back end; you could build it on RCS; and so on.

This implementation of the Subversion filesystem interface is built on
top of Berkeley DB (http://www.sleepycat.com).  Berkeley DB supports
transactions and recoverability, making it well-suited for Subversion.



Nodes and Node Versions

In a Subversion filesystem, a `node' corresponds roughly to an
`inode' in a Unix filesystem:
- A node is either a file or a directory.
- A node's contents change over time.
- When you change a node's contents, it's still the same node; it's
  just been changed.  So a node's identity isn't bound to a specific
  set of contents.
- If you rename a node, it's still the same node, just under a
  different name.  So a node's identity isn't bound to a particular
  filename.

A `node version' refers to a node's contents at a specific point in
time.  Changing a node's contents always creates a new version of that
node.  Once created, a node version's contents never change.

When we create a node, its initial contents are the initial version of
the node.  As users make changes to the node over time, we create new
versions of that same node.  When a user commits a change that deletes
a file from the filesystem, we don't delete the node, or any version
of it --- those stick around to allow us to recreate prior versions of
the filesystem.  Instead, we just remove the reference to the node
from the directory.



ID's

Within the database, we refer to nodes and node versions using strings
of numbers separated by periods that look a lot like RCS revision
numbers.

  node_id ::= number | node_version_id "." number
  node_version_id ::= node_id "." number

So: 
- "100" is a node id.
- "100.10" is a node version id, referring to version 10 of node 100.
- "100.10.3" is a node id, referring to the third branch based on
  version 10 of node 100.
- "100.10.3.13" is a node version id, referring to version 13 of
  of the third branch from version 10 of node 100.
And so on.

A directory entry identifies the file or subdirectory it refers to
using a node version number.  Changes far down in a filesystem
hierarchy requires all their parents to be updated to hold the new
node version ID.  This makes it easy to find changes in large trees.

Note that the numbers specifying a particular version of a node is the
number of the global filesystem version when that node version was
created.  So 100.13 was created in filesystem version 13.  This means
that 100.13.10.2 is meaningless --- the last number implies that it
was created in filesystem version 2, but the root implies that it's a
branch of the version of node 10 created in filesystem verison 13.
The version numbers in node ID's and node version ID's must increase
from left to right.

Identifying nodes and node versions this way makes it easy to discover
whether and how two nodes are related.  Simply by looking at the node
version id's, we can tell that the difference from 100.10.3.11 to
100.12 is the difference from 100.10.3.11 to 100.10, plus the
difference from 100.10 to 100.12.

When we need to treat a node or node version ID as a string of bytes,
we use the forms shown here --- a series of unsigned ASCII decimal
numbers, separated by dots.


NODE-VERSION: how we represent a node version

We represent a given version of a file or directory node using a list
skel (see skel.h for an explanation of skels).  The first element of a
node version skel is always an atom indicating what kind of node this
is.  The second element is always the node's property list.  Any
remaining elements carry the contents of the node, in a form
that depends on the node's kind.

A node version skel has one of the following forms:

("file" PROPLIST DATA)
    This node version is a file.  DATA is an atom giving the full
    contents of the file.  (In the future, DATA may be a list,
    indicating that the fulltext of the file is stored elsewhere in
    the database, or perhaps in an ordinary Unix file.)

("directory" PROPLIST (ENTRY ...))
    This node version is a directory.  The list (ENTRY ...) gives the
    directory entries.  Each ENTRY has the form:

        (NAME ID)

    where:
    - NAME is the name of the directory entry, in UTF-8
    - ID is the ID of the nv to which this entry refers, and

Note that a node cannot change its kind from one version to the next.
A directory node is always a directory; a file node is always a file;
etc.  The fact that the node's kind is stored in each node version,
rather than in some version-independent place, might suggest that it's
possible for a node change kinds from version to version --- 10.3
could be a directory, while 10.4 could be a file --- but Subversion
does not allow this.

We store the node kind in the node version for simplicity.  This way,
we can store *everything* about a node in the node versions --- we
don't need the complexity of a separate per-node structure, or the
overhead of looking in two places.


PROPLIST: property lists for nodes and directory entries

A property list is a list skel of the form:

    (NAME1 VALUE1 NAME2 VALUE2 ...)

where each NAMEi is the name of a property, and VALUEi is the value of
the property named NAMEi.  Every valid property list has an even
number of elements.



REPRESENTATION: how Subversion stores many similar node versions efficiently

It would be correct, but not efficient, to store Subversion filesystem
nodes simply as a table mapping node version ID's onto NODE-VERSION
skels, as described above.  However, in this application we know that
successive versions of files and directories will often be very
similar to each other, so compression can be very effective.

Instead of storing straight NODE-VERSION skels, we store
REPRESENTATION skels, whose job is to provide enough information to
construct a complete NODE-VERSION skel.  At the moment, there are only
two forms of REPRESENTATION skels:

("fulltext" NODE-VERSION)
    We store the complete text of the node version, NODE-VERSION.

("younger" DELTA CHECKSUM)
    We store a delta that transforms the next younger version of the
    node into this version.  To find the contents of this version:

    - We find the unparsed form of the NODE-VERSION skel for the next
      younger version.

    - We apply DELTA to that string, yielding the unparsed form of the
      NODE-VERSION skel for this version.

    To be sure that we've reconstructed the node version correctly, we
    store a checksum of the unparsed form of this version's
    NODE-VERSION skel.  We compare this against the checksum of the
    result from applying the DELTA.

At present, Subversion stores the youngest version of every node and
branch in "fulltext" form, and stores all other versions in "younger"
form.  However, there's nothing magic about that particular
arrangement.  Other interesting alternatives:

- We could store the N most recently accessed node versions as
  fulltext, letting access patterns determine the most appropriate
  representation for each version.

- We could occasionally store deltas against the N'th younger version,
  storing larger jumps with a frequency inverse to the distance
  covered, yielding a tree-structured history.

Since the filesystem interface doesn't expose these details, we can
change the representation pretty much as we please to optimize
whatever parameter we care about --- storage size, speed, robustness,
etc.


DELTA: how we represent text deltas

The job of a DELTA form is to describe how to turn one byte string
(the `source' string) into another (the `target' string).  The context
of the DELTA form needs specify exactly what the source and target
strings are.

At the moment, there is only one form of DELTA allowed:

("vcdiff" DATA)
    DATA is an atom whose contents are a VCDIFF-form diff.


CHECKSUM: how we represent checksums

The job of a CHECKSUM form is to provide a constant-size distinctive
value, computed entirely from a given string.  If two strings have
different checksums, then we know those two strings must be different.
Assuming we use a good checksum algorithm, if two strings have the
same checksum, it is likely that the strings are equal.

There is only one form of CHECKSUM skel at the moment:

("md5" BYTES)
    BYTES is the 128-bit MD5 hash value of the string.



The Berkeley DB "nodes" table

The database contains a table called "nodes", which is a btree indexed
by node version ID's, mapping them onto REPRESENTATION skels.  Node 0
is always the root directory, and node version 0.0 is always the empty
directory.

Since the "nodes" table is a btree, it's efficent to walk over the
entries in order of increasing or decreasing node ID's.  In fact,
Berkeley DB lets us provide our own key ordering function, so we can
arrange the nodes for quick traversal, given our access patterns.

Here's the sort order we use:

- Nodes are sorted by their node number.
- All the versions of a given node come together, in order of 
  increasing version number.
- Each node's versions are followed by a record whose key is
  "NODENUM.head".  This lets us quickly find the head of any given
  chain of node versions by looking for "NODENUM.head", and then going
  back one record.
- All branches off any version of a node come immediately after that
  node, ordered by increasing version number.

For example, the "nodes" table might have the following sequence of
keys:

13.1     ; the original node, with four versions
13.2
13.3
13.4
13.head
13.2.1.1   ; a branch from the second version of 13, with three versions
13.2.1.2
13.2.1.3
13.2.1.head
13.2.2.1   ; another branch off the same version of 13, with four versions
13.2.2.2
13.2.2.3
13.2.2.4
13.2.2.head
13.4.1.1   ; another branch off a later version of 13, with two versions
13.4.1.2
13.4.1.head
14.1     ; another node
14.2
14.3
14.head

Assuming that we store the most recent version on every branch as
fulltext, and all other versions as deltas, we can retrieve any node
version NODE.VERSION by searching for NODE.head, and then walking
backwards to NODE.VERSION, applying deltas as we go.

Since we don't want to corrupt our btree, even if we accidentally
insert garbage keys into the table, we extend our ordering to handle
arbitrary byte strings: any mis-formed ID comes before any well-formed
ID, and two mis-formed IDs are compared byte-by-byte.


VERSION: filesystem versions, and the Berkeley DB "versions" table

We represent a filesystem version using a skel of the form:
    ("version" ID PROPLIST)
where:
- ID is the node version ID of this version's root directory, and
- PROPLIST is the version's property list.

The database contains a table called "versions", which is a btree
mapping version numbers (as ASCII decimal numbers) onto VERSION skels.
Version zero always has node version 0.0 as its root directory; that
node version is guaranteed to be an empty directory.


Transactions

The Subversion filesystem must provide the following characteristics:

- clients can submit arbitrary rearrangements of the tree, to be
  performed as atomic changes to the filesystem tree
- multiple clients can submit non-overlapping changes at the same time,
  without blocking
- readers must never block other readers or writers
- writers must never block readers
- writers may block writers

Merging rules:

   The general principle: a series of changes can be merged iff the
   final outcome is independent of the order you apply them in.

Merging two nodes, A and B, with respect to a common ancestor
ANCESTOR:
- First, the merge fails unless A, B, and ANCESTOR are all the same kind
  of node.
- If A and B are text files:
  - If A is an ancestor of B, the B is the merged result.
  - If A is identical to B, then B (arbitrarily) is the merged result.
  - Otherwise, the merge fails.
- If A and B are both directories:
  - For every directory entry E in either A, B, or ANCESTOR, here are
    the cases:
      - E exists in neither ANCESTOR nor A.
      - E doesn't exist in ANCESTOR, and has been added to A.
      - E exists in ANCESTOR, but has been deleted from A.
      - E exists in both ANCESTOR and A ...
	- but refers to different nodes.
	- but refers to different versions of the same node.
	- and refers to the same node version.

    The same set of possible relationships with ANCESTOR holds for B,
    so there are thirty-six combinations.  The matrix is symmetrical
    with A and B reversed, so we only have to describe one triangular
    half, including the diagonal --- 21 combinations.

    - (6) E exists in neither ANCESTOR nor A:
      - (1) E exists in neither ANCESTOR nor B.  Can't occur, by assumption
	   that E exists in either A, B, or ancestor.
      - (1) E has been added to B.  Add B in the merged result. ***
      - (1) E has been deleted from B.  Can't occur, by assumption that E
	doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption that
        E doesn't exist in ancestor.
    - (5) E doesn't exist in ANCESTOR, and has been added to A.
      - (1) E doesn't exist in ANCESTOR, and has been added to B.  Conflict.
      - (1) E exists in ANCESTOR, but has been deleted from B.  Can't occur,
        by assumption that E doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption
        that E doesn't exist in ANCESTOR.
    - (4) E exists in ANCESTOR, but has been deleted from A.
      - (1) E exists in ANCESTOR, but has been deleted from B.  If
        neither delete was a result of a rename, then omit E from the
        merged tree.  *** Otherwise, conflict.
      - E exists in both ANCESTOR and B ...
        - (1) but refers to different nodes.  Conflict.
        - (1) but refers to different versions of the same node.  Conflict.
        - (1) and refers to the same node version.  Omit E from the merged
          tree. ***
    - (3) E exists in both ANCESTOR and A, but refers to different nodes.
      - (1) E exists in both ANCESTOR and B, but refers to different
        nodes.  Conflict.
      - (1) E exists in both ANCESTOR and B, but refers to different
        versions of the same node.  Conflict.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node version.  Replace E with A's node version.  ***
    - (2) E exists in both ANCESTOR and A, but refers to different
      versions of the same node.
      - (1) E exists in both ANCESTOR and B, but refers to different versions
        of the same node.  Try to merge A/E and B/E, recursively.  ***
      - (1) E exists in both ANCESTOR and B, and refers to the same node
        version.  Replace E with A's node version.   ***
    - (1) E exists in both ANCESTOR and A, and refers to the same node
      version.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node version.  Nothing has happened to ANCESTOR/E, so no change
        is necessary.


Non-Historical Properties

[[Yes, do tell.]]

