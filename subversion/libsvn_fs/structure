Subversion on Berkeley DB

There are many different ways to implement the Subversion filesystem
interface.  You could implement it directly using ordinary POSIX
filesystem operations; you could build it using an SQL server as a
back end; you could build it on RCS; and so on.

This implementation of the Subversion filesystem interface is built on
top of Berkeley DB (http://www.sleepycat.com).  Berkeley DB supports
transactions and recoverability, making it well-suited for Subversion.



ID's

Within the database, we refer to nodes and node versions using strings
of numbers separated by periods that look a lot like RCS revision
numbers.

  node_id ::= number | node_version_id "." number
  node_version_id ::= node_id "." number

So: 
- "100" is a node id.
- "100.10" is a node version id, referring to version 10 of node 100.
- "100.10.3" is a node id, referring to the third branch based on
  version 10 of node 100.
- "100.10.3.13" is a node version id, referring to version 13 of
  of the third branch from version 10 of node 100.
And so on.

A directory entry identifies the file or subdirectory it refers to
using a node version number.  Changes far down in a filesystem
hierarchy requires all their parents to be updated to hold the new
node version ID.  This makes it easy to find changes in large trees.

Note that the numbers specifying a particular version of a node is the
number of the global filesystem version when that node version was
created.  So 100.13 was created in filesystem version 13.  This means
that 100.13.10.2 is meaningless --- the last number implies that it
was created in filesystem version 2, but the root implies that it's a
branch of the version of node 10 created in filesystem verison 13.
The version numbers in node ID's and node version ID's must increase
from left to right.

Identifying nodes and node versions this way makes it easy to discover
whether and how two nodes are related.  Simply by looking at the node
version id's, we can tell that the difference from 100.10.3.11 to
100.12 is the difference from 100.10.3.11 to 100.10, plus the
difference from 100.10 to 100.12.


How nodes are represented in the database.

The database contains a table called "nodes", which is a btree indexed
by node version ID's, mapping them onto a description of their
contents.  Each node specifies whether it's a directory or a file, and
whether it's full-text or a delta vs. the next node version.





Since the "nodes" table is a btree, it's efficent to walk over the
entries in order of increasing or decreasing node ID's.  In fact,
Berkeley DB lets us provide our own key ordering function, so we can
arrange the nodes for quick traversal, given our access patterns.

Here's the sort order we use:

- Nodes are sorted by their node number.
- All the versions of a given node come together, in order of 
  increasing version number.
- Each node's versions node are followed by a record whose key is
  "NODENUM.head".  This lets us quickly find the head of any given
  chain of node versions by looking for "NODENUM.head", and then going
  back one record.
- All branches off any version of a node come immediately after that
  node, ordered by increasing version number.









Transactions

The Subversion filesystem must provide the following characteristics:

- clients can submit arbitrary rearrangements of the tree, to be
  performed as atomic changes to the filesystem tree

- multiple clients can submit non-overlapping changes at the same time,
  without blocking

- readers must never block other readers or writers
- writers must never block readers
- writers may block writers
