There are many different ways to implement the Subversion filesystem
interface.  You could implement it directly using ordinary POSIX
filesystem operations; you could build it using an SQL server as a
back end; you could build it on RCS; and so on.

This implementation of the Subversion filesystem interface is built on
top of Berkeley DB (http://www.sleepycat.com).  Berkeley DB supports
transactions and recoverability, making it well-suited for Subversion.

In a Subversion filesystem, a `node' corresponds roughly to an
`inode' in a Unix filesystem:
- A node is either a file or a directory.
- A node's contents change over time.
- When you change a node's contents, it's still the same node; it's
  just been changed.  So a node's identity isn't bound to a specific
  set of contents.
- If you rename a node, it's still the same node, just under a
  different name.  So a node's identity isn't bound to a particular
  filename.

A `node version' refers to a node's contents at a specific point in
time.  Changing a node's contents always creates a new version of that
node.  Once created, a node version's contents never change.

When we create a node, its initial contents are the initial version of
the node.  As users make changes to the node over time, we create new
versions of that same node.  When a user commits a change that deletes
a file from the filesystem, we don't delete the node, or any version
of it --- those stick around to allow us to recreate prior versions of
the filesystem.  Instead, we just remove the reference to the node
from the directory.

Within the database, we refer to nodes and node versions using strings
of numbers separated by periods that look a lot like RCS revision
numbers.

  node_id ::= number | node_version_id "." number
  node_version_id ::= node_id "." number

So: 
- "100" is a node id.
- "100.10" is a node version id, referring to version 10 of node 100.
- "100.10.3" is a node id, referring to the third branch based on
  version 10 of node 100.
- "100.10.3.13" is a node version id, referring to version 13 of
  of the third branch from version 10 of node 100.
And so on.

A directory entry identifies the file or subdirectory it refers to
using a node version number.  Changes far down in a filesystem
hierarchy requires all their parents to be updated to hold the new
node version ID.  This makes it easy to find changes in large trees.

Note that the numbers specifying a particular version of a node is the
number of the global filesystem version when that node version was
created.  So 100.13 was created in filesystem version 13.  This means
that 100.13.10.2 is meaningless --- the last number implies that it
was created in filesystem version 2, but the root implies that it's a
branch of the version of node 10 created in filesystem verison 13.
The version numbers in node ID's and node version ID's must increase
from left to right.

Identifying nodes and node versions this way makes it easy to discover
whether and how two nodes are related.  Simply by looking at the node
version id's, we can tell that the difference from 100.10.3.11 to
100.12 is the difference from 100.10.3.11 to 100.10, plus the
difference from 100.10 to 100.12.


Transactions

The Subversion filesystem must provide the following characteristics:

- clients can submit arbitrary rearrangements of the tree, to be
  performed as atomic changes to the filesystem tree

- multiple clients can submit non-overlapping changes at the same time,
  without blocking

- readers must never block other readers or writers
- writers must never block readers
- writers may block writers
