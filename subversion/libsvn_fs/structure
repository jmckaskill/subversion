Subversion on Berkeley DB

There are many different ways to implement the Subversion filesystem
interface.  You could implement it directly using ordinary POSIX
filesystem operations; you could build it using an SQL server as a
back end; you could build it on RCS; and so on.

This implementation of the Subversion filesystem interface is built on
top of Berkeley DB (http://www.sleepycat.com).  Berkeley DB supports
transactions and recoverability, making it well-suited for Subversion.



Nodes and Node Revisions

In a Subversion filesystem, a `node' corresponds roughly to an
`inode' in a Unix filesystem:
- A node is either a file or a directory.
- A node's contents change over time.
- When you change a node's contents, it's still the same node; it's
  just been changed.  So a node's identity isn't bound to a specific
  set of contents.
- If you rename a node, it's still the same node, just under a
  different name.  So a node's identity isn't bound to a particular
  filename.

A `node revision' refers to a node's contents at a specific point in
time.  Changing a node's contents always creates a new revision of that
node.  Once created, a node revision's contents never change.

When we create a node, its initial contents are the initial revision of
the node.  As users make changes to the node over time, we create new
revisions of that same node.  When a user commits a change that deletes
a file from the filesystem, we don't delete the node, or any revision
of it --- those stick around to allow us to recreate prior revisions of
the filesystem.  Instead, we just remove the reference to the node
from the directory.



ID's

Within the database, we refer to nodes and node revisions using strings
of numbers separated by periods that look a lot like RCS revision
numbers.

  node_id ::= number | node_revision_id "." number
  node_revision_id ::= node_id "." numberh

So: 
- "100" is a node id.
- "100.10" is a node revision id, referring to revision 10 of node 100.
- "100.10.3" is a node id, referring to the third branch based on
  revision 10 of node 100.
- "100.10.3.4" is a node revision id, referring to revision 4 of
  of the third branch from revision 10 of node 100.
And so on.

Node revision numbers start with 1.  Thus, N.1 is the first revision
of node N.

Node / branch numbers start with 1.  Thus, N.M.1 is the first
branch off of N.M.

A directory entry identifies the file or subdirectory it refers to
using a node revision number --- not a node number.  This means that
a change to a file far down in a directory hierarchy requires the
parent directory of the changed node to be updated, to hold the new
node revision ID.  Now, since that parent directory has changed, its
parent needs to be updated.

If a particular subtree was unaffected by a given commit, the node
revision ID that appears in its parent will be unchanged.  When
doing an update, we can notice this, and ignore that entire
subtree.  This makes it efficient to find localized changes in
large trees.

Note that the number specifying a particular revision of a node is
unrelated to the global filesystem revision when that node revision
was created.  So 100.10 may have been created in filesystem revision
1218; 100.10.3.2 may have been created any time after 100.10; it
doesn't matter.

Since revision numbers increase by one each time a delta is added,
we can compute how many deltas separate two related node revisions
simply by comparing their ID's.  For example, the distance between
100.10.3.2 and 100.12 is the distance from 100.10.3.2 to their
common ancestor, 100.10 (two deltas), plus the distance from 100.10
to 100.12 (two deltas).

However, this is kind of a kludge, since the number of deltas is
not necessarily an accurate indicator of how different two files
are --- a single delta could be a minor change, or a complete
replacement.  Furthermore, the filesystem may decide arbitrary to
store a given node revision as a delta or as full text --- perhaps
depending on how recently the node was used --- so revision id
distance isn't necessarily an accurate predictor of retrieval time.

If you have insights about how this stuff could work better, let me
know.  I've read some of Josh MacDonald's stuff on this; his
discussion seems to be mostly about how to retrieve things quickly,
which is important, but only part of the issue.  I'd like to find
better ways to recognize renames, and find appropriate ancestors in
a source tree for changed files.

When we need to treat a node or node revision ID as a string of bytes,
we use the forms shown here --- a series of unsigned ASCII decimal
numbers, separated by dots.


NODE-REVISION and HEADER: how we represent a node revision

We represent a given revision of a file or directory node using a list
skel (see skel.h for an explanation of skels).  A node revision skel
has the form:

    (HEADER KIND-SPECIFIC ...)

where HEADER is a header skel, whose structure is common to all nodes,
and the KIND-SPECIFIC elements carry data dependent on what kind of
node this is --- file, directory, etc.

HEADER has the form:

    (KIND PROPLIST FLAG ...)

where:
- KIND indicates what sort of node this is,
- PROPLIST is the node's property list, and
- FLAG ... is a sequence of zero or more flags.

KIND must be one of the following:
- "file", indicating that the node is a file (see FILE below).
- "dir", indicating that the node is a directory (see DIR below).

Each FLAG has one of the following forms:

("mutable" TXN)
    This is a mutable node, part of the transaction whose ID is TXN.
    The "mutable" flag may occur only once in the FLAG ... list.

Note that a node cannot change its kind from one revision to the next.
A directory node is always a directory; a file node is always a file;
etc.  The fact that the node's kind is stored in each node revision,
rather than in some revision-independent place, might suggest that it's
possible for a node change kinds from revision to revision --- 10.3
could be a directory, while 10.4 could be a file --- but Subversion
does not allow this.

We store the node kind in the node revision for simplicity.  This way,
we can store *everything* about a node in the node revisions --- we
don't need the complexity of a separate per-node structure, or the
overhead of looking in two places.


FILE: how files are represented.

If a NODE-REVISION's header's KIND is "file", then the node-revision
skel represents a file, and has the form:

    (HEADER DATA)

where DATA is an atom giving the full contents of the file.  (In the
future, DATA may have other alternate forms, indicating that the
fulltext of the file is stored elsewhere in the database, or perhaps
in an ordinary Unix file.)


DIR: how directories are represented.

If the header's KIND is "dir", then the node-revision skel
represents a directory, and has the form:

    (HEADER (ENTRY ...))

The list (ENTRY ...) gives the directory entries; each ENTRY has the form:

    (NAME ID)

where:
  - NAME is the name of the directory entry, in UTF-8, and
  - ID is the ID of the node revision to which this entry refers.


PROPLIST: property lists for nodes and directory entries

A property list is a list skel of the form:

    (NAME1 VALUE1 NAME2 VALUE2 ...)

where each NAMEi is the name of a property, and VALUEi is the value of
the property named NAMEi.  Every valid property list has an even
number of elements.



REPRESENTATION: how Subversion stores many similar node revisions efficiently

It would be correct, but not efficient, to store Subversion filesystem
nodes simply as a table mapping node revision ID's onto NODE-REVISION
skels, as described above.  However, in this application we know that
successive revisions of files and directories will often be very
similar to each other, so compression can be very effective.

Instead of storing straight NODE-REVISION skels, we store
REPRESENTATION skels, whose job is to provide enough information to
construct a complete NODE-REVISION skel.  At the moment, there are only
two forms of REPRESENTATION skels:

("fulltext" NODE-REVISION)
    We store the complete text of the node revision, NODE-REVISION.

("younger" DELTA CHECKSUM)
    We store a delta that transforms the next younger revision of the
    node into this revision.  To find the contents of this revision:

    - We find the unparsed form of the NODE-REVISION skel for the next
      younger revision.

    - We apply DELTA to that string, yielding the unparsed form of the
      NODE-REVISION skel for this revision.

    To be sure that we've reconstructed the node revision correctly, we
    store a checksum of the unparsed form of this revision's
    NODE-REVISION skel.  We compare this against the checksum of the
    result from applying the DELTA.

At present, Subversion stores the youngest revision of every node and
branch in "fulltext" form, and stores all other revisions in "younger"
form.  However, there's nothing magic about that particular
arrangement.  Other interesting alternatives:

- We could store the N most recently accessed node revisions as
  fulltext, letting access patterns determine the most appropriate
  representation for each revision.

- We could occasionally store deltas against the N'th younger revision,
  storing larger jumps with a frequency inverse to the distance
  covered, yielding a tree-structured history.

Since the filesystem interface doesn't expose these details, we can
change the representation pretty much as we please to optimize
whatever parameter we care about --- storage size, speed, robustness,
etc.


DELTA: how we represent text deltas

The job of a DELTA form is to describe how to turn one byte string
(the `source' string) into another (the `target' string).  The context
of the DELTA form needs specify exactly what the source and target
strings are.

At the moment, there is only one form of DELTA allowed:

("vcdiff" DATA)
    DATA is an atom whose contents are a VCDIFF-form diff.


CHECKSUM: how we represent checksums

The job of a CHECKSUM form is to provide a constant-size distinctive
value, computed entirely from a given string.  If two strings have
different checksums, then we know those two strings must be different.
Assuming we use a good checksum algorithm, if two strings have the
same checksum, it is likely that the strings are equal.

There is only one form of CHECKSUM skel at the moment:

("md5" BYTES)
    BYTES is the 128-bit MD5 hash value of the string.



The Berkeley DB "nodes" table

The database contains a table called "nodes", which is a btree indexed
by node revision ID's, mapping them onto REPRESENTATION skels.  Node 0
is always the root directory, and node revision 0.0 is always the empty
directory.

Since the "nodes" table is a btree, it's efficent to walk over the
entries in order of increasing or decreasing node ID's.  In fact,
Berkeley DB lets us provide our own key ordering function, so we can
arrange the nodes for quick traversal, given our access patterns.

Here's the sort order we use:

- Nodes are sorted by their node number.
- All the revisions of a given node come together, in order of 
  increasing revision number.
- All branches off any revision of a node come immediately after that
  node, ordered by increasing revision number.

For example, the "nodes" table might have the following sequence of
keys:

13.1     ; the original node, with four revisions
13.2
13.3
13.4
13.2.1.1   ; a branch from the second revision of 13, with three revisions
13.2.1.2
13.2.1.3
13.2.2.1   ; another branch off the same revision of 13, with four revisions
13.2.2.2
13.2.2.3
13.2.2.4
13.4.1.1   ; another branch off a later revision of 13, with two revisions
13.4.1.2
14.1     ; another node
14.2
14.3

We can find the latest revision of node N by searching the `nodes'
table for the last entry before N.1.1.1, the first branch off the
node's first revision.  According to the sort order, this node
immediately follows the last revision of node N.

Similarly, we can find the last branch off a given node revision N.V by
searching the `nodes' table for the last entry before N.(V+1).1.1.
According to the sort order, this node immediately follows the last
descendant of of N.V.  This last descendent could be a branch off a
branch off a branch ..., but by truncating the node revision ID
appropriately, we can find the last branch off of N.V.

Assuming that we store the most recent revision on every branch as
fulltext, and all other revisions as deltas, we can retrieve any node
revision NODE.REVISION by searching for the last revision of NODE, and
then walking backwards to NODE.REVISION, applying deltas as we go.

Since we don't want to corrupt our btree, even if we accidentally
insert garbage keys into the table, we extend our ordering to handle
arbitrary byte strings: any mis-formed ID comes before any well-formed
ID, and two mis-formed IDs are compared byte-by-byte.


REVISION: filesystem revisions, and the Berkeley DB "revisions" table

We represent a filesystem revision using a skel of the form:
    ("revision" ID PROPLIST)
where:
- ID is the node revision ID of this revision's root directory, and
- PROPLIST is the revision's property list.

The database contains a table called "revisions", which is a
record-number table mapping revision numbers onto REVISION skels.  Since
Berkeley DB record numbers start with 1, whereas Subversion revision
numbers start at zero, revision V is stored as record number V-1 in the
`revisions' table.  Revision zero always has node revision 0.0 as its
root directory; that node revision is guaranteed to be an empty
directory.


Transactions: merge rules

The Subversion filesystem must provide the following characteristics:

- clients can submit arbitrary rearrangements of the tree, to be
  performed as atomic changes to the filesystem tree
- multiple clients can submit non-overlapping changes at the same time,
  without blocking
- readers must never block other readers or writers
- writers must never block readers
- writers may block writers

Merging rules:

   The general principle: a series of changes can be merged iff the
   final outcome is independent of the order you apply them in.

Merging two nodes, A and B, with respect to a common ancestor
ANCESTOR:
- First, the merge fails unless A, B, and ANCESTOR are all the same kind
  of node.
- If A and B are text files:
  - If A is an ancestor of B, the B is the merged result.
  - If A is identical to B, then B (arbitrarily) is the merged result.
  - Otherwise, the merge fails.
- If A and B are both directories:
  - For every directory entry E in either A, B, or ANCESTOR, here are
    the cases:
      - E exists in neither ANCESTOR nor A.
      - E doesn't exist in ANCESTOR, and has been added to A.
      - E exists in ANCESTOR, but has been deleted from A.
      - E exists in both ANCESTOR and A ...
	- but refers to different nodes.
	- but refers to different revisions of the same node.
	- and refers to the same node revision.

    The same set of possible relationships with ANCESTOR holds for B,
    so there are thirty-six combinations.  The matrix is symmetrical
    with A and B reversed, so we only have to describe one triangular
    half, including the diagonal --- 21 combinations.

    - (6) E exists in neither ANCESTOR nor A:
      - (1) E exists in neither ANCESTOR nor B.  Can't occur, by assumption
	   that E exists in either A, B, or ancestor.
      - (1) E has been added to B.  Add B in the merged result. ***
      - (1) E has been deleted from B.  Can't occur, by assumption that E
	doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption that
        E doesn't exist in ancestor.
    - (5) E doesn't exist in ANCESTOR, and has been added to A.
      - (1) E doesn't exist in ANCESTOR, and has been added to B.  Conflict.
      - (1) E exists in ANCESTOR, but has been deleted from B.  Can't occur,
        by assumption that E doesn't exist in ANCESTOR.
      - (3) E exists in both ANCESTOR and B.  Can't occur, by assumption
        that E doesn't exist in ANCESTOR.
    - (4) E exists in ANCESTOR, but has been deleted from A.
      - (1) E exists in ANCESTOR, but has been deleted from B.  If
        neither delete was a result of a rename, then omit E from the
        merged tree.  *** Otherwise, conflict.
      - E exists in both ANCESTOR and B ...
        - (1) but refers to different nodes.  Conflict.
        - (1) but refers to different revisions of the same node.  Conflict.
        - (1) and refers to the same node revision.  Omit E from the merged
          tree. ***
    - (3) E exists in both ANCESTOR and A, but refers to different nodes.
      - (1) E exists in both ANCESTOR and B, but refers to different
        nodes.  Conflict.
      - (1) E exists in both ANCESTOR and B, but refers to different
        revisions of the same node.  Conflict.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node revision.  Replace E with A's node revision.  ***
    - (2) E exists in both ANCESTOR and A, but refers to different
      revisions of the same node.
      - (1) E exists in both ANCESTOR and B, but refers to different revisions
        of the same node.  Try to merge A/E and B/E, recursively.  ***
      - (1) E exists in both ANCESTOR and B, and refers to the same node
        revision.  Replace E with A's node revision.   ***
    - (1) E exists in both ANCESTOR and A, and refers to the same node
      revision.
      - (1) E exists in both ANCESTOR and B, and refers to the same
        node revision.  Nothing has happened to ANCESTOR/E, so no change
        is necessary.

*** == something actually happens


How transactions work

A committed filesystem revision behaves like a read-only directory
tree: we can traverse it, and read file and directory contents, but we
can't change anything.  We can't edit history.

When we open a transaction against some base revision R, the
transaction behaves like a writeable directory tree, initially
identical to R.  We can traverse it and read node contents, and also
create, delete, rename, and change nodes.  Once we've made the changes
we want, we can commit the transaction, creating a new, read-only
filesystem revision.

To implement this behavior efficiently, we treat a fresh transaction
as a "copy-on-write" duplicate of its base revision.  Each transaction
begins life sharing its entire node structure with its base revision,
directories and files alike; a new transaction is effectively a single
pointer to its base revision's root directory.  Then, to make changes
within the transaction, we create a copy of each node revision we
change, leaving the base revision's tree undisturbed.  In the tree of
node revisions, this copy is a direct descendent of the original node
revision.  We call each copied node revision a "clone".

The Subversion filesystem's `bubble up' rule says that 1) any change
committed to a node creates a separate node revision, and 2) directory
entries refer to specific node revisions, not nodes.  The immediate
consequence of this rule is that, if a transaction changes a node,
creating a clone of that node, it must clone all of that node's parent
directories as well.  Since any given node need be cloned only once
per transaction, this is not an onerous requirement.

As we make changes within a transaction, the cumulative effect of
cloning and the `bubble up' rule is that the transaction always
consists of a tree of cloned nodes, pointing back into the base
revision's tree for unmodified files and directories.  An unmodified
transaction is simply the border case, where the "tree" of cloned
nodes is empty, and the root itself is shared with the base revision.

[[Here would be a good place for some diagrams.]]

Note that, within a given transaction, once we have cloned some node
revision, it is not shared with the base revision's tree, so we can
make further changes to that node revision freely.  We need never
create a clone of a clone.  This is the usual behavior for
"copy-on-write" structures: once a node revision has been cloned, it
is writable thereafter.  If a node revision is a clone in an
uncommitted transaction, we call it "mutable".

There's an important wrinkle here, responsible for the complexity of
the filesystem's data structures.  The node revisions in a committed
filesystem revision actually form a DAG, not a tree.  Multiple
entries, possibly in different directories, may point to the same node
revision, each one acting as a virtual copy of the full tree.

For example, consider the following node revisions, as they might
appear in a filesystem revision:

10.1: directory (("a" 11.1) ("b" 11.1))
11.1: directory (("c" 12.1) ("d" 12.1))
12.1: file "Good morning."

This `tree' contains three directories --- the top directory, `a', and
`b' --- and four distinct files, named `a/c', `a/d', `b/c', and `b/d',
all of whose contents are the string "Good morning."  The fact that
`a/c' and `b/d' are the same node, 12.1, doesn't matter; they are
virtual copies.

When a transaction refers to a structure like the above, it must treat
node revision 12.1 as four distinct files, depending on what path the
user finds it under.  The directories `a' and `b' happen to share
their structure completely, as do all four files.  If the transaction
changes all four files, `a/c', `a/d', `b/c' and `b/d', then node
revision 12.1 will be cloned four times, yielding four distinct new
node revisions.

If you hold a reference to some node in an uncommitted transaction,
and decide to modify the node, the `bubble up' rule requires you to
make sure all its parent directories are cloned in that transaction.
However, the structure sharing described above makes it complex to
decide whether a given node has already been cloned, and if so, which
clone is the appropriate one to use.

For example, supposed 10.1 is the root of some revision R, and we
begin a new transaction X based on R.  If we change a/c in X, that
creates the following structure, where 10.2 is the root of the
transaction:

10.1: directory (("a" 11.1) ("b" 11.1))
11.1: directory (("c" 12.1) ("d" 12.1))
12.1: file "Good morning."

10.2: directory (("a" 11.2) ("b" 11.1))
11.2: directory (("c" 12.2) ("d" 12.1))
12.2: file "Good afternoon."

Note that X's `b' directory still shares all its nodes with R's `b'
directory, but that the root, `a' and `a/c' have been cloned.

Now, if we decide to modify X's `b/c', we should get the following
structure:

10.1: directory (("a" 11.1) ("b" 11.1))
11.1: directory (("c" 12.1) ("d" 12.1))
12.1: file "Good morning."

10.2: directory (("a" 11.2) ("b" 11.1.1.1))
11.2: directory (("c" 12.2) ("d" 12.1))
12.2: file "Good afternoon."

11.1.1.1: directory (("c" 12.1.1.1) ("d" 12.1))
12.1.1.1: file "Good night."

We cloned 12.1, here representing the file `b/c', yielding 12.1.1.1.
Then, we cloned the directory 11.1 again, representing the directory
`b', yielding 11.1.1.1.  However, we did not clone 10.1 again, since
we have already cloned the root directory.  Instead, we modify the
node revision 10.2 in place, making the entry `b' refer to the new
clone 11.1.1.1.

The filesystem uses the `clones' table to record, for each active
transaction, which of the base revision's node revisions have been
cloned so far, and which directory entry should be updated should a
new node be cloned.  Each key in the `clones' table has the form:

   (TXN PATH)

where TXN is the ID of the transaction, and PATH is the path *in the
base revision* of a node that has been cloned.  Each value in the
`clones' table has one of the following forms:

   (cloned ID)
       The node identified by the given path has been cloned in TXN,
       yielding node revision ID.

   (renamed ID NAME)
       The node identified by the given path has not yet been cloned,
       but the only reference to it has been moved in TXN.  The node
       is now referred to by the directory entry named NAME in the
       clone node revision ID.

A reference to a transaction's node must have one of two forms:
- the ID of a clone in the transaction, or 
- the full path, in the transaction's base revision, of the node.

If a reference has the first form, you know the node has already been
cloned; you can make changes directly to the clone.

If a reference has the second form, the node may or may not have been
cloned yet.  To modify the node, follow this procedure:

Set PATH to the node's full path, and set PATHID to the node's ID.
while PATH is non-empty:
  if `clones' has an entry for (TXN PATH):
    if the value is (cloned ID):
      then ID specifies the clone you should modify.  You're done.
    if the value is (renamed PARENTID NAME):
      then clone PATHID, adding an appropriate `cloned' entry.
      adjust the entry named NAME in PARENTID to point to the clone.
      You're done.
  if `clones' has no entry for (TXN PATH):
    clone PATHID, yielding CLONE, adding an appropriate `cloned' entry.
    remove the last element, NAME, from PATH
    set PATHID to the node ID the new PATH refers to in the base revision
      (this needn't require a lookup; you could record the node numbers
       along with PATH.)
    Adjust the entry named NAME in PATHID to refer to CLONE.
    go around the loop again, to clone the parent.

This procedure:
- clones all the directories as required by the `bubble up' rule.
- clones each virtual copy at most once.












TRANSACTION: How we represent transactions in the database

Building a transaction creates ordinary node revisions in the
filesystem: either new revisions of existing nodes, or new revisions on
branches, or new nodes altogether.  The transaction's tree has its own
revision of the root directory; this is the root of a tree of the
changed nodes, with pointers into the existing, committed tree for
unchanged files and directory trees.  If the transaction succeeds, the
transaction's root directory becomes the root of the new revision,
after any necessary merges.

Nodes which are part of an uncommitted transaction may only be pointed
to by other nodes in the same transaction; there are no pointers into
a transaction's tree from without.  This assures that:
- the transaction's tree, and thus the changes it contains, are
  completely invisible to everyone outside that transaction, and
- if the transaction fails, all its nodes can be deleted from the
  `nodes' table, without creating any dangling references.

How do transactions relate to the `bubble up' rule?

The Subversion filesystem's `bubble up' rule says that 1) any change
to a node creates a new node revision, and 2) directory entries refer
to specific node revisions.  The immediate consequence of this rule is
that, if a transaction changes any node, and thus creates a new
revision of that node, it must create new revisions of all its parent
nodes as well.

However, it's important to note that the `bubbling up' need happen
only once per *complete transaction*, not once per change within the
transaction.  Once we have created a new revision of a directory for a
given transaction, we can make as many changes as we like within that
new directory revision.  In other words, once the transaction contains
the new node revisions required by the `bubble up' rule, further
changes to the same nodes needn't create any new revisions --- they can
proceed much like writes to an ordinary filesystem.

Thus, node revisions which are part of an uncommitted transaction are
called "mutable" node revisions, since they may be changed in place
until the transaction is committed.  Once a transaction is committed,
the nodes it contains become "immutable" nodes, whose contents must
never change.

For each active transaction, we store a transaction header skel of the
form:

   ("transaction" ROOT)

where ROOT is the node revision ID of the transaction's root directory.
If you start traversing directories from this node revision, you see
the tree as modified by this transaction.  If we haven't yet created a
root directory for this transaction, ROOT is the empty string.

The database contains a table called "transactions", which is a btree
table indexed by transaction ID, mapping each one onto a TRANSACTION
header.  The "transactions" table also maps the string "next" to the
ID to be assigned to the next transaction.

Transaction ID's are decimal numbers.  No transaction ID is ever
reused, within a given repository.  The keys of the "transactions"
table are the shortest ASCII decimal representation of the transaction
ID.  The entries of the "transactions" table are sorted by the ID's
numeric value.

If the transaction succeeds, the transaction's root directory becomes
the new revision's root directory, after any necessary merging.  If the
transaction fails, we delete all of its nodes from the filesystem.  In
either case, once the transaction is finished, we delete all trace of
it from the "transactions" table.


The "changes" table

If the user has an svn_fs_node_t object referring to a particular node
in a transaction, it's reasonable to assume that, if the node's parent
directories are cloned (to satisfy the bubble-up property) or renamed,
the svn_fs_node_t object will continue to refer to the same node.

However, this property is challenging to implement.  The unchanged
portions of a transaction's tree are represented by immutable nodes;
to allow virtual copies, a given immutable node may appear more than
once in a given tree.  Each appearance of the node, however,
represents a distinct file.  Consider the following tree:

root of revision R: node 10.1

node 10.1: a:11.1, b:11.1
node 11.1: c:12.1, d:12.2
node 12.1: a file

In this tree, the paths /a/c, /a/d, /b/c, and /b/d all refer to node
12, which is a file.  From Subversion's point of view, this is a
directory tree with three directories --- /, /a, and /b, and four
files.  That is, the four paths above refer to four distinct files:
changing one does not affect the others.

This means that an svn_fs_node_t object cannot keep track of which
node it refers to simply by recording a node version ID




As the user constructs a transaction, immutable nodes from committed
revisions are cloned, yielding mutable nodes to hold the transaction's
changes.  If an application wants to treat a transaction as a
directory tree, it is useful to be able refer a specific nodes in a
transaction's tree, without regard for whether that node has been
cloned yet.

This means that the implementation needs some way to map from an
immutable node to its clone.  Since subtrees can be shared in
revisions, an immutable node revision could have more than one
distinct clones in the transaction.  This means that the ID of an
immutable node revision alone is not enough to find the appropriate
clone --- we need to know the path by which we reached the node, and
the cloned revisions of each node on that path.

To this end, the database contains a table called "clones", which is a
btree with KEY -> VALUE pairs of the form:

	(TXN-ID PARENT-ID ENTRY-NAME) -> CHILD-ID

meaning: "In the transaction TXN-ID, the directory entry named
ENTRY-NAME in the mutable directory node PARENT-ID was cloned,
yielding node CHILD-ID."  In other words, it's a record of all the
cloning that went on.  CHILD-ID can also be "deleted", indicating that
the directory entry was deleted.

These entries 


If a node object refers to a mutable node, it can simply keep track of
its node revision ID.  If a node object refers to an immutable node,
it must record the path from the root of the transaction to the node.




 directory entry name and node revision ID of 


recording the clone made for each immutable node modified in
each transaction.  Each key has the form "TXN-ID PARENT-ID NAME",
where TXN-ID is a transaction ID, PARENT-ID is a node revision ID, and
NAME is a directory entry name.  Each value has the form "CHILD-ID",
where CHILD-ID is a node revision ID.  An entry mapping "PARENT-ID
NAME" to "CHILD-ID" indicates that, when the entry named NAME in the
already mutable directory PARENT-ID was first cloned, CHILD-ID was the
clone's node revision ID.

Using the "clones" table, we can always find the new mutable node
corresponding to an old immutable node in a transaction by starting
from the transaction's root and 




Non-Historical Properties

[[Yes, do tell.]]
