     Oh Most High and Fragrant Emacs, please be in -*- text -*- mode!

This is the library described in the section "The working copy
management library" of svn-design.texi.

It performs local operations in the working copy, tweaking
administrative files and versioned data, generally in response to a
received delta.  It communicates with the server through libsvn_cl.


The Problem We're Solving.
==========================

The working copy is arranged as a directory tree, which, at checkout,
mirrors a tree rooted at some node in the repository.  Over time, the
working copy accumulates uncommitted changes, some of which may affect
its tree layout.  By commit time, the working copy's layout could be
arbitrarily different from the repository tree on which it was based.

Furthermore, updates/commits do not always involve the entire tree, so
it is possible for the working copy to go a very long time without
being a perfect mirror of some tree in the repository.


One Way We're Not Solving It.
=============================

Updates and commits are about merging two trees that share a common
ancestor, but have diverged since that ancestor.  In real life, one of
the trees comes from the working copy, the other from the repository.
But when thinking about how to merge two such trees, we can ignore the
question of which is the working copy and which is the repository,
because the principles involved are symmetrical.

Why do we say symmetrical?

It's tempting to think of a change as being either "from" the working
copy or "in" the repository.  But the true source of a change is some
committer -- each change represents some developer's intention toward
a file or a tree, and a conflict is what happens when two intentions
are incompatible (or their compatibility cannot be automatically
determined).

It doesn't matter in what order the intentions were discovered --
which has already made it into the repository versus which exists only
in someone's working copy.  Incompatibility is incompatibility,
independent of timing.

In fact, a working copy can be viewed as a "branch" off the
repository, and the changes committed in the repository *since* then
represent another, divergent branch.  Thus, every update or commit is
a general branch-merge problem:

   - An update is an attempt to merge the repository's branch into the
     working copy's branch, and the attempt may fail wholly or
     partially depending on the number of conflicts.

   - A commit is an attempt to merge the working copy's branch into
     the repository.  The exact same algorithm is used as with
     updates, the only difference being that a commit must succeed
     completely or not at all.  That last condition is merely a
     useability decision: the repository tree is shared by many
     people, so folding both sides of a conflict into it to aid
     resolution would actually make it less useable, not more.  On the
     other hand, representing both sides of a conflict in a working
     copy is often helpful to the person who owns that copy.

So below we consider the general problem of how to merge two trees
that have a common ancestor.  The concrete tree layout discussed will
be that of the working copy, because this library needs to know
exactly how to massage a working copy from one state to another.


Structure of the Working Copy
=============================

     [Note: this obsoletes parts of client.texi.  We'll sync them up
     after implementation.] 

Working copy meta-information is stored in SVN/ subdirectories,
analogous to CVS/ sudirs:

   SVN/README                   /* No, it's not this file.  Details below. */
       format                   /* Contains wc adm format version. */
       repository               /* Where this stuff came from. */
       versions                 /* Version numbers for this directory */
       properties               /* Properties for this directory */
       delta-here               /* Uncommitted changes logged here */
       lock                     /* Optional, tells others this dir is busy */
       unwind                   /* Actions to unwind here (for rollback) */
       tmp                      /* Local tmp space is preferable to /tmp */
       text-base/               /* Pristine repos versions of the files... */
            foo.c
            qux/                    /* Subdirs are empty, though */
            bar.c
            baz.c
       prop-base/               /* Pristine repos hashdumps of these files
            foo.c
            bar.c                   /* Stores bar.c's file properties */
            baz.c
       dprop-base/              /* Tentative dirent entry property storage */
            foo.c
            bar.c                   /* Would store bar.c's dirent props */

`README'

   If someone doesn't know what a Subversion working copy is, this
   will tell them how to find out more about Subversion.

   Also, the presence of this file means that the entire process of
   creating the adm area was completed, because this is always the
   last file created.  Of course, that's no guarantee that someone
   didn't muck things up afterwards, but it's good enough for
   existence-checking.

`format'

   Says what version of the working copy adm format this is (so future
   clients can be backwards compatible easily).

`repository'

   Where this dir came from (syntax TBD).

`versions':

   This file holds the version number of this directory and its
   children -- that is to say, the version number for the root of the
   repository tree from which this directory/file is derived.  It
   contains a single XML expression:

      <wc-versions xmlns="http://subversion.tigris.org/xmlns/blah">
        <entry name="" version="5"/>     <!-- empty name means current dir -->
        <entry name="foo.c" version="5"/>
        <entry name="bar.c" version="5"/>
        <entry name="baz.c" version="6"/>
      </wc-versions>

   The directory's own VersionNumber is implicit for every child of
   the directory, so only the exceptions need to be recorded.  If an
   entry does not appear in the versions file, but is present in the
   text-base/ tree, then it is assumed to have the same version as the
   parent directory.

   Child directories do not get entries, because they will have their
   own `SVN/versions' files, and recording the same information in two
   places is the first step on the road to madness.

   The `versions' file discusses only things that exist in the
   repository.  For example, if the user does

      svn rename foo.c qux.c

   the versions file will still claim that foo.c is at version 17 (the
   local rename is recorded in the `delta-here' file, described
   later).  Only *after* the rename is committed does the `versions'
   entry for foo.c change to something like:

      <entry name="qux.c" version="21"/>

`properties'

   Properties for this directory.  

   For now, this file is in svn hashdump format, because it's
   convenient and its performance is good enough for now.  May move to
   Berkeley DB if properties ever get that demanding.  XML is another
   possibility -- it's less efficient, disk-wise, but on the other
   hand its easy to parse it streamily, unlike hashdump format, which
   generally results in a complete data structure in memory before you
   can do anything at all.

`delta-here'

   Records adds, renames, and deletes involving this directory's
   immediate children, using tree-delta syntax:

      <new name="qux.c">
        <file ancestor="/full/path/to/foo.c" version="17"/>
      </new>
      <delete name="foo.c"/>

   (The "<tree-delta>" and "</tree-delta>" tags themselves are
   omitted, for reasons that will become clear later.) 

   When new changes are recorded, they have to be checked against
   existing ones for consistency.  For example, imagine the following
   sequence of operations:

      svn rename foo.c qux.c
      svn rename bar.c qux.c

   After the first command, the tree-edits file might look like this:

      <new name="qux.c">
        <file ancestor="/full/path/to/foo.c" version="17"/>
      </new>
      <delete name="foo.c"/>

   But after the second command, it should *not* look like this:
   
      <new name="qux.c">
        <file ancestor="/full/path/to/foo.c" version="17"/>
      </new>
      <new name="qux.c">
        <file ancestor="/full/path/to/bar.c" version="12"/>
      </new>
      <delete name="foo.c"/>
      <delete name="bar.c"/>

   because that would leave two entries for qux.c, with conflicting
   ancestries.  Instead, the old qux.c entry should be *replaced* with
   a new one, leaving:

      <new name="qux.c">
        <file ancestor="/full/path/to/bar.c" version="12"/>
      </new>
      <delete name="foo.c"/>
      <delete name="bar.c"/>

   (And remember that the parent directory, bar.c, and foo.c might all
   have different versions.)

   kff todo: explain the internal walk interface here, & how it
   connects with the xml outputter.

`lock'

   Present iff some client is using this SVN/ subdir for anything.
   kff todo: I think we don't need read vs write types, nor
   race-condition protection, due to the way locking is called.  We'll
   see, though.

`unwind'

   This file (XML format) holds a "stack" of adm actions that are
   about to be done.  After each action is done, its entry on the
   stack is removed.

   In the event of a crash, the recovery routines simply read over the
   file and do the actions; the original code makes sure the file gets
   set up in a way such that this interpretation leads to the right
   result.  (Since the crash could have occurred between the doing of
   the action and the removal of its entry from the stack, it is not
   an error for the first item on the recovery stack to be undoable
   due to a missing file or whatever -- in that case, it is presumed
   to have been completed and just removed.  This means, however, that
   one can *never* add an entry to the stack until all files on whose
   existence it depends have been successfully created).

   Soon there will be a general explanation/algorithm for using the
   unwind stack; for now, this example gives the flavor:

   To do a fresh checkout of `iota' in directory `.'

      1. add_file() produces the new ./SVN/tmp/SVN/versions, which
         probably is the same as the original `versions' file since
         `iota' is likely to be the same version as its parent
         directory.  (But not necessarily...)

      2. apply_textdelta() hands window_handler() to its caller.

      3. window_handler() is invoked N times, constructing
         ./SVN/tmp/text-base/iota

      4. finish_file() is called.  First, it atomically pushes these
         items onto the ./SVN/tmp/unwind stack:

            <mv src="SVN/tmp/iota" dst="SVN/text-base/iota">
            <mv src="SVN/tmp/SVN/versions" dst="SVN/versions">
            <merge src="SVN/text-base/iota" dst="iota">

         Then it does the operations in the `unwind' file (probably
         by simply reading the unwind file with the same routine
         that would be used in a recovery!), removing each entry
         immediately on finishing that task (i.e., before moving on to
         the next entry).  Yes, it does this in a tmpy way. :-)

         When all done, remove the `unwind' file.

         (kff todo: seems better to use "SVN/tmp/iota" in the first
         unwind line than "SVN/tmp/SVN/text-base/iota", but...
         thoughts?)

   To recover from a crash:

      1. Look for an `unwind' file.  

           A. If none, just "rm -r tmp/*".

           B. Else if `unwind' is present, loop over it doing each
              operation.  It is permissible for the `src' file of the
              first entry to not exist, since that means a crash
              occurred between doing the operation and writing out the
              tmp file.  Just toss that entry, then.

              When done, remove the `unwind' file.

   The recovery algorithm above is pretty general, actually.  The
   algorithm for creating the unwind file is also going to be pretty
   simple; each code path as it goes keeps a growing stack of the
   unwind operations, and then at the end it dumps that stack to the
   unwind file, and then runs the common execute_unwind_file()
   routine.  Viola!  (Er, pardon my French.)


`tmp'

   A shallow mirror of the working directory (i.e., the parent of the
   SVN/ subdirectory), giving us reproducible tmp names.

   When you need a tmp file for something in the main dir, use
   tmp/NAME, for example tmp/iota.  When you need a tmp file for
   something in SVN/, use tmp/SVN/thing.  And when you need a *very*
   temporary file for something in SVN (because you're reconstructing
   it), use tmp/SVN/thing.$PID -- notice that no SVN/ file ever has a
   .blah extension.  If it ends in .*, then it must be a tmp file.

   See discussion of the `unwind' file for more details.

`text-base/'

   Each file in text-base/ is a pristine repository version of that
   file, corresponding to the version indicated in `versions'.  These
   files are used for sending diffs back to the server, etc.

   Child directories of the current directory appear here, but are
   empty -- this is enough to make their existence known to the
   current directory; all other information about the child directory
   is of course stored in its own SVN/ subdir.

`prop-base/'

   Pristine repos properties for those files, in hashdump format.
   todo: may also store dirent props here, lots of good formats for
   mixing those two, would pick one when we implement the dirent
   props.  Or may store them some other way; think this will be best
   answered after having the rest of the library working.

`dprop-base/'

   Same, but for dirent properties.  [maybe not implemented initially]



------------------------
todo: some loose ends

   1. filename escaping in SVN/versions
   2. 



How the client applies an update delta.
---------------------------------------

Updating is more than just bringing changes down from the repository;
it's also folding those changes into the working copy.  Getting the
right changes is the easy part -- folding them in is hard.

Before we examine how Subversion handles this, let's look at what CVS
does:

   1. Unmodified portions of the working copy are simply brought
      up-to-date.  The server sends a forward diff, the client applies
      it.

   2. Locally modified portions are "merged", where possible.  That
      is, the changes from the repository are incorporated into the
      local changes in an intelligent way (if the diff application
      succeeds, then no conflict, else go to 3...)

   3. Where merging is not possible, a conflict is flagged, and *both*
      sides of the conflict are folded into the local file in such a
      way that it's easy for the developer to figure out what
      happened.  (And the old locally-modified file is saved under a
      temp name, just in case.)

It would be nice for Subversion to do things this way too;
unfortunately, that's not possible in every case.

CVS has a wonderfully simplifying limitation: it doesn't version
directories, so never has tree-structure conflicts.  Given that only
textual conflicts are possible, there is usually a natural way to
express both sides of a conflict -- just include the opposing texts
inside the file, delimited with conflict markers.  (Or for binary
files, make both versions available under temporary names.)

While Subversion can behave the same way for textual conflicts, the
situation is more complex for trees.  There is sometimes no way for a
working copy to reflect both sides of a tree conflict without being
more confusing than helpful.  How does one put "conflict markers" into
a directory, especially when what was a directory might now be a file,
or vice-versa?

Therefore, while Subversion does everything it can to fold conflicts
intelligently (doing at least as well as CVS does), in extreme cases
it is acceptable for the Subversion client to punt, saying in effect
"Your working copy is too out of whack; please move it aside, check
out a fresh one, redo your changes in the fresh copy, and commit from
that."  (This response may also apply to subtrees of the working copy,
of course).

Usually it offers more detail than that, too.  In addition to the
overall out-of-whackness message, it can say "Directory foo was
renamed to bar, conflicting with your new file bar; file blah was
deleted, conflicting with your local change to file blah, ..." and so
on.  The important thing is that these are informational only -- they
tell the user what's wrong, but they don't try to fix it
automatically.

All this is purely a matter of *client-side* intelligence.  Nothing in
the repository logic or protocol affects the client's ability to fold
conflicts.  So as we get smarter, and/or as there is demand for more
informative conflicting updates, the client's behavior can improve and
punting can become a rare event.  We should start out with a _simple_
conflict-folding algorithm initially, though.


