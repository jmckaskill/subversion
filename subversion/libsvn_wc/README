     Oh Most High and Fragrant Emacs, please be in -*- text -*- mode!

This is the library described in the section "The working copy
management library" of svn-design.texi.

It performs local operations in the working copy, tweaking
administrative files and versioned data, generally in response to a
received delta.  It communicates with the server through libsvn_cl.

The Problem We're Solving.
==========================

The working copy is arranged as a directory tree, which, at checkout,
mirrors a tree rooted at some node in the repository.  Over time, the
working copy accumulates uncommitted changes, some of which may affect
its tree layout.  By commit time, the working copy's layout could be
arbitrarily different from the repository tree on which it was based.

Furthermore, updates/commits do not always involve the entire tree, so
it is possible for the working copy to go a very long time without
being a perfect mirror of some tree in the repository.

To resolve all situations safely, we define exactly what a "change" is
and what a "conflict" is, and how conflicts are resolved.

Kinds of Changes.
=================

As their trees change over time, the working copy and repository each
track changes to files and directories.  There are two kinds of
changes, "direct" and "indirect":

               Direct Change        Indirect Change
          ._____________________._____________________.
          | Change to file's    |                     |
   file   | contents; OR, file  |                     |
          | was added, removed, |  [No such thing]    |
          | or renamed          |                     |
          |_____________________|_____________________|
          |                     |  An immediate child |
   dir    | This dir was added, |  of this dir was    |
          | removed, or renamed |  added, removed, or |
          |                     |  renamed            |
          |_____________________|_____________________|

In other words, a change that directly affects an entity's textual
contents, its name, or its existence is a "direct" change.  A change
that affects the name or existence of an directory's immediate child
is an "indirect" change to the directory (although it's a direct
change to the child, of course).  Only directories can have indirect
changes.


Comparing Changes.
==================

In both commits and updates, the client and server must compare
changes in the working copy against changes in the repository.  For
commits, the comparison is part of the pre-commit up-to-date check;
for updates, the comparison determines what changes will be sent from
server to client.

Since commits do not change the working copy, pre-commit checks need
not do intelligent conflict checking and merging.  They are only
concerned with whether entities in question are "up-to-date" -- that
is, for the entities in question, have there been divergent changes
between working copy and repository?  If so, then the working copy is
out-of-date.

Updates, on the other hand, can affect the working copy.  Updates
merge changes into the working copy where possible (not only textual
changes, but even tree-structure changes), and describe conflicts as
usefully as possible when merging is not an option.

To understand how the above happens, you need to know

  * How the working copy describes its state to the server.

  * In the case of a commit,
       a) how the server uses this state to perform a pre-commit check.
       b) how the client completes the commit.

  * In the case of an update,
       a) how the server uses this state to generate an update delta.
       b) how the client applies an update delta.


How the working copy describes its state to the server.
=======================================================

The problem of describing the working copy's state to the server is
the same whether for pre-commit check or for update.  In both
scenarios, the working copy describes its state to the server by
sending over a "snapshot".  The server uses the snapshot to determine
how to respond to the client.  (The state includes only those entities
involved in the transaction -- the working copy is certainly not
required to describe its *entire* state for every operation.)

For the moment, let's treat the snapshot as a black box (in practice,
it's probably a skelta).  It contains one entry per entity, and each
entry consists of:

   Original Name      (a full path, of course)
   Original Version   (i.e., "base" version)
   Action             (content change, add, remove, rename...)
   New Name           (if any)
   New Version        (only if other than repository latest)


How the server uses the snapshot to perform a pre-commit check.
===============================================================

First, the server checks the snapshot for internal consistency -- if
the snapshot claims that two files have been renamed to the same name,
or something equally ridiculous, it is rejected out of hand.

Assuming the snapshot is consistent, the server checks whether each
entity in it has changed in the repository since the given base
version.  A direct change would make the pre-commit check fail
definitely; indirect changes cause failure iff they mention the same
child name as some change mentioned in the snapshot.

The same check is looped across all commits in the pending pool.

The server *never* accepts a commit based on a working copy state that
conflicts with the repository.  The client is always responsible for
sending non-conflicting deltas.  Therefore, the client may need to
update and resolve any conflicts before committing.

(See the section "Conflict/Merge Tables" farther down for a formal
accounting of these rules.)

Of course, when a pre-commit check fails, the server doesn't just send
back a terse denial.  It tells the client exactly which entities are
out of date, so the client can update efficiently.

If the check succeeds, the server sends back a token (unique among all
other pending commits), which the client will use to complete the
commit.


How the client completes the commit.
------------------------------------

The client sends back the success token it received from the server,
along with a full delta describing the changes.  (In practice,
probably a filled-in version of the skelta it sent previously.)  The
server applies these changes, creating a new version, and sends a
success ACK back to the client.  The client-side entities involved in
the commit are, for that instant at least, up-to-date.


How the server uses the snapshot to generate an update delta.
=============================================================

This question is interesting if you're implementing the repository
filesystem, but it's too complex to go into here and it's not part of
libsvn_wc. :-) Suffice it to say that the server sends back a tree
delta describing what the working copy must do to become up-to-date,
according to the base revisions in the snapshot the working copy sent.

How the working copy *uses* that tree delta is much more relevant to
libsvn_wc, and is the subject of the next section...

[JimB: hopefully the first section, "How the server uses the snapshot
to perform a pre-commit check", resolves the issues about filesystem
implementation.  Basically, if there's any doubt about the
commitability of a delta, then reject it and tell the client to
update.  See also "Conflict/Merge Tables" below.]


How the client applies an update delta.
---------------------------------------

Updating is more than bringing changes down from the repository; it's
also about folding those changes into the working copy.  Bringing the
right changes down is the easy part -- folding them in is hard.

Before we examine how Subversion handles this, let's look at what CVS
does:

   1. Unmodified portions of the working copy are simply brought
      up-to-date.

   2. Locally modified portions are "merged", where possible.  That
      is, the changes from the repository are incorporated into the
      local changes in an intelligent way.

   3. Where merging is not possible, a conflict is flagged, and *both*
      sides of the conflict are folded into the local file in such a
      way that it's easy for the developer to figure out what
      happened.  (And the un-updated locally-modified file is saved
      under a tmp name, just in case.)

It would be nice for Subversion to do things this way too;
unfortunately, that's not possible in every case.

CVS has a wonderfully simplifying limitation: because it doesn't
version directories, it never has tree-structure conflicts.  Since
only textual conflicts are possible, there is always a natural way to
express both sides of a conflict -- just include the opposing texts
inside the file, delimited with conflict markers.  (Or for binary
files, make both versions available under temporary names.)

While Subversion can do the same thing for file conflicts, the
situation is more complex for trees.  There is often no way to reflect
both sides of a tree conflict in the working copy without being more
confusing than helpful.  How does one put "conflict markers" into a
directory, especially when what was a directory might now be a file,
or vice-versa?

Therefore, while Subversion does everything it can to fold conflicts
intelligently (at least as well as CVS does), it is acceptable for the
Subversion client to punt, saying in effect "Your working copy is too
out of whack; please move it aside, check out a fresh one, redo your
changes in the fresh copy as much as you can, and commit from that."
(This response may apply to subtrees of the working copy, of course).

Usually it includes more detail than that, of course.  In addition to
the overall out-of-whackness message, it can say "Directory foo was
renamed to bar, conflicting with your new file bar; file blah was
deleted, conflicting with your local change to file blah, ..." and so
on.  The important thing is that these are informational only -- they
tell the user what's wrong, but they don't try to fix it
automatically.

Note that this is purely a matter of *client-side* intelligence.
Nothing in the repository logic or protocol affects the client's
ability to fold conflicts.  So as we get smarter, and/or as there is
demand for more informative conflicting updates, the client's behavior
can improve and punting can become a rare event.  We should start out
with a _simple_ conflict-folding algorithm initially, though.


Conflict/Merge Tables.
======================

The tables below describe how client and server behave in various
potential conflict scenarios.  Each intersection describes what
happens when one change meets another on the same entity.

   Table 1:   Direct changes   <==>   Indirect changes
   Table 2:   Indirect changes  <==>  Indirect changes
   Table 3:   Direct changes   <==>   Direct changes

In each cell

   C   means    "Conflict, unfoldable"
   M   means    "Mergable"
   F   means    "Conflict for server, possibly a conflict for client
                 but might be foldable (either via straight merge, or
                 folding conflict)" 

Fortunately the principles involved are symmetrical, so it doesn't
matter which side is the working copy and which is the
repository.  

For example, Table 1 says that an entity-rename (a direct change) and
a child-rename (an indirect change) conflict in a commit, and a
mergeable in an update.  Let's see how that plays out in real life:

   Scenario 1: Working copy renames foo/bar.c to foo/baz.c.
   Meanwhile, in the repository, someone has renamed foo to qux.  If
   the working copy tries to commit, the server treats this as a
   conflict and tells the working copy to update.  If update, then
   it's fine: baz.c remains where it is, and foo is renamed to qux
   (assuming the update included foo).

   Scenario 2: Working copy renames foo to qux.  Meanwhile, in the
   repository, someone has renamed foo/bar.c to foo/baz.c.  If the
   working copy tries to commit, the server treats this as a conflict
   and tells the working copy to update.  If update, then qux/bar.c is
   renamed to qux/baz.c.


todo: run through a couple of cells from both sides, to show how these
scenarios play out in real-life.

   [todo: what if you are at version 3, trying to commit an add of
   foo/bar.c.  Meanwhile, in 5, someone changed name of foo to baz,
   then in 6 someone added baz/bar.c.  Will this be detected?

   Yes, not because of the add, but because of the direct change
   against indirect 
    


          Table 1: Direct changes against indirect changes
          ************************************************

  [changes    |         d i r e c t     c h a n g e s
   on direc-  |
   tories]    |    self add         self remove        self rename
  ------------|------------------.---------------.-------------------.
  i           | C                .               .                   .
  n     child | (Must be really  .       C       .     commit: C     .
  d      add  | out-of-date for  .               .     update: M     .
  i           | this to happen!) .               .                   .
  r           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e           |                  .               .                   .
  c     child |  C               .               .                   .
  t    remove |                  .       C       .     commit: C     .
              | (Same as above.) .               .     update: M     .
              |                  .               .                   .
  c           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  h           |                  .               .                   .
  a     child |  C               .               .                   .
  n    rename |                  .       C       .     commit: C     .
  g           | (Same as above.) .               .     update: M     .
  e           |                  .               .                   .
  s           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .



         Table 2: Indirect changes against indirect changes
         **************************************************

  [changes    |         i n d i r e c t     c h a n g e s
   on direc-  |
   tories]    |    child add        child remove      child rename
  ------------|----------------.-------------------.-----------------.
  i           |                .                   .                 .
  n     child |    C if name   .    C if name      .  C if name      .
  d      add  |    conflicts,  .    conflicts,     .  conflicts,     .
  i           |    else M      .    else M         .  else M         .
  r           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e           |                . commit: C if name .                 .
  c     child |    C if name   .         conflicts,.  C if name      .
  t    remove |    conflicts,  .         else M    .  conflicts,     .
              |    else M      . update: M         .  else M         .
  c           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  h           |                .                   .                 .
  a     child |    C if name   .    C if name      .  C if name      .
  n    rename |    conflicts,  .    conflicts,     .  conflicts,     .
  g           |    else M      .    else M         .  else M         .
  e           |                .                   .                 .
  s           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .


fooo

           Table 3: Direct changes against direct changes
           **********************************************

  [changes to |            d i r e c t     c h a n g e s
   any kind   |
   of entity] |   add          remove         rename         text change
  ------------|------------.-------------.---------------.-----------------.
              | commit: C  .             .               .  commit: C      .
      add     |            .             .               .                 .
  d           | update: M  .     C       .     C         .  update: M      .
  i           |   or C     .             .               .    or C         .
  r           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e           |            . commit: C   .               .                 .
  c   remove  |            .             .               .                 .
  t           |    C       . update: M   .     C         .    C            .
              |            .             .               .                 .
  c           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  h           |            .             .  commit: C    .  commit: C      .
  a   rename  |            .             .               .                 .
  n           |    C       .     C       .  update: M    .  update: M      .
  g           |            .             .    or C       .                 .
  e           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  s           | commit: C  .             .  commit: C    .  commit: C      .
      text    |            .             .               .                 .
      change  | update: M  .     C       .  update: M    .  update: M or C .
              |   or C     .             .               .                 .
              |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .



[Not clear if `rename' shoud be a separate operation...]






 (i.e., what gets merged vs what is
     flagged as a conflict, and especially what the verb "flag as a
     conflict" *means* in different kinds of conflicts).

WC State
R State
conflict

Def: Modifying a file's contents is a "direct change" to that file.

Def: A rename, add, or delete is considered a direct change to the
      target(s), and an "indirect change" to the parent(s).

Def: A working copy's "WC state" is a snapshot (maybe a skelta?) that
      shows the base versions, and any changes, for all entities in

Def: given a WC state, the repository could
      theoretically reconstruct the entire working copy, except for
      the actual content of uncomitted local changes.)
      [Define the black box way drawn on the board?]

Def: A "R state" is a list of all entities that have changed in the
      repository *relative* to a given WC state.  The repository can
      calculate the R state for a given a WC state.

Def: A WC state and a R state "conflict" iff they have any
      conflicting changes -- defined in (F) below.

Def: Changes conflict according to the following rules:

         - Two direct changes to the same entity always conflict.

         - An indirect and a direct change to the same entity conflict
           iff the direct change affects the entity's type (e.g., wc
           modifies foo/bar.c, but in the repository foo has been
           changed to a regular file).

         - Two indirect changes to the same entity never conflict.
           ??? or just if same name ???

         - Changes to different entities never conflict.

Def: The server never accepts a delta based on a WC state that
      conflicts with the repository.  The client is always responsible
      for sending non-conflicting deltas.

Given these principles [though see footnote 1], the process for
updates is largely the same as for commits, so the two are described
together here:

   1. The working copy creates a snapshot (W) of its state, and sends
      it to the server.

   2. The server checks if the entities listed in W have changed in
      the repository too [see footnote 2].  If there are no conflicts,
      then the commit is registered and a token sent back (or, if this
      is an update, the server sends back the appropriate delta).

   3. If there is a conflict, then...

         - commit case:
             Server sends back a message telling the working
             copy it must update.  By principle (G), the client can
             only commit based on a non-conflicting state, therefore
             the client must not only update, but also resolve any
             conflicts, before it can successfully commit.

         - update case:

--------------------------- Footnotes -----------------------------------

[1] Haven't thought carefully about whether this all works smoothly
when directory *entries* are considered entities.  I think so, but am
not sure yet.

[2] The working copy doesn't always want to compare against the pure
latest version in the repository -- it may be comparing against some
other version, or perhaps even different versions for different parts.
In fact, every entity in the working copy snapshot might have a
different "latest" to compare against, in addition to the possiblity
of a different base version.  I haven't thought about this carefully
yet either, but see no reason the snapshots can't include both sides
of the comparison for each entity.
