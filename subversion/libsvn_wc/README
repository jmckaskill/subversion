     Oh Most High and Fragrant Emacs, please be in -*- text -*- mode!

This is the library described in the section "The working copy
management library" of svn-design.texi.

It performs local operations in the working copy, tweaking
administrative files and versioned data, generally in response to a
received delta.  It communicates with the server through libsvn_cl.

The Problem We're Solving.
==========================

The working copy is arranged as a directory tree, which, at checkout,
mirrors a tree rooted at some node in the repository.  Over time, the
working copy accumulates uncommitted changes, some of which may affect
its tree layout.  By commit time, the working copy's layout could be
arbitrarily different from the repository tree on which it was based.

Furthermore, updates/commits do not always involve the entire tree, so
it is possible for the working copy to go a very long time without
being a perfect mirror of some tree in the repository.

To resolve all situations safely, we define exactly what a "change" is
and what a "conflict" is, and how conflicts are resolved.

Kinds of Changes.
=================

As their trees change over time, the working copy and repository each
track changes to files and directories.  There are two kinds of
changes, "direct" and "indirect":

               Direct Change        Indirect Change
          ._______________________._______________________.
          | Change to file's      |                       |
   file   | contents; OR, file    |                       |
          | was added, removed,   |  [No such thing]      |
          | or renamed            |                       |
          |_______________________|_______________________|
          |                       |  A descendant of this |
   dir    | This dir was added,   |  dir was added,       |
          | removed, or renamed   |  removed, renamed,    |
          |                       |  or modified          |
          |_______________________|_______________________|

In other words, a change that directly affects an entity's textual
contents, its name, or its existence is a "direct" change.  A change
that affects the name or existence of a directory's descendant is an
"indirect" change to the directory (although it's a direct change to
the descendant, of course).  Only directories can have indirect
changes.


Comparing Changes.
==================

In both commits and updates, the client and server must compare
changes in the working copy against changes in the repository.  For
commits, the comparison is part of the pre-commit up-to-date check;
for updates, the comparison determines what changes will be sent from
server to client.

Since commits do not change the working copy, pre-commit checks need
not do intelligent conflict checking and merging.  They are only
concerned with whether things are "up-to-date" -- that is, for the
entities in question, have there been divergent changes between
working copy and repository?  If so, then the working copy is
out-of-date.

Updates, on the other hand, usually do affect the working copy.
Updates merge changes into the working copy where possible (not only
textual changes, but even tree-structure changes), and describe
conflicts as usefully as possible when merging is not an option.

To understand how the above happens, you need to know

  * How the working copy describes its state to the server.

  * In the case of a commit,
       a) how the server uses this state to perform a pre-commit check.
       b) how the client completes the commit.

  * In the case of an update,
       a) how the server uses this state to generate an update delta.
       b) how the client applies an update delta.


How the working copy describes its state to the server.
=======================================================

The problem of describing the working copy's state to the server is
the same whether for pre-commit check or for update.  In both
scenarios, the working copy describes its state to the server by
sending over a "snapshot".  The server uses the snapshot to determine
how to respond to the client.  (The state includes only those entities
involved in the transaction -- the working copy is certainly not
required to describe its *entire* state for every operation.)

For the moment, let's treat the snapshot as a black box (in practice,
it's probably a skelta).  It contains one entry per entity, and each
entry consists of:

   oName              (Original Name, a full path, of course)
   oVersion           (Original Version, also called "base" version)
   Action             (modify, add, remove, rename...)
   nName              (New Name, if any)
   nVersion           (New Version, == repos Latest if left empty)


How the server uses the snapshot to perform a pre-commit check.
===============================================================

First, the server checks the snapshot for internal consistency -- if
the snapshot claims that two files have been renamed to the same name,
or something equally ridiculous, it is rejected out of hand.

Assuming the snapshot is consistent, the server checks whether each
entity in it has changed in the repository, or will change due to a
pending commit, since the given base version.  A direct change always
causes the pre-commit check to fail; an indirect change causes failure
iff it mentions the same name as the change in the snapshot.

(See the section "Conflict/Merge Tables" farther down for a formal
accounting of these rules.)

The server *never* accepts a commit based on a working copy state that
conflicts with the repository.  The client is always responsible for
sending non-conflicting deltas.  Therefore, the client may need to
update and resolve any conflicts before committing.  So when a
pre-commit check fails, the server doesn't just send back a terse
denial.  It tells the client exactly which entities are out of date,
so the client can update efficiently.

If the pre-commit check succeeds, the server sends back a token
(unique among all other pending commits), which the client will use to
complete the commit.


How the client completes the commit.
------------------------------------

The client sends back the success token it received from the server,
along with a full delta describing the changes.  (In practice,
probably a filled-in version of the skelta it sent previously.)  The
server applies these changes, creating a new version, and sends a
success ACK back to the client.  The client-side entities involved in
the commit are, for that instant at least, up-to-date.


How the server uses the snapshot to generate an update delta.
=============================================================

This question is interesting if you're implementing the repository
filesystem, but it's too complex to go into here and it's not part of
libsvn_wc. :-) Suffice it to say that the server sends back a tree
delta describing what the working copy must do to become up-to-date,
according to the base revisions in the snapshot the working copy sent.

How the working copy *uses* that tree delta is much more relevant to
libsvn_wc, and is the subject of the next section...

[JimB: hopefully the first section, "How the server uses the snapshot
to perform a pre-commit check", resolves the issues about filesystem
implementation.  Basically, if there's any doubt about the
commitability of a delta, then reject it and tell the client to
update.  See also "Conflict/Merge Tables" below.]


How the client applies an update delta.
---------------------------------------

Updating is more than just bringing changes down from the repository;
it's also folding those changes into the working copy.  Getting the
right changes is the easy part -- folding them in is hard.

Before we examine how Subversion handles this, let's look at what CVS
does:

   1. Unmodified portions of the working copy are simply brought
      up-to-date.  The server sends a forward diff, the client applies
      it.

   2. Locally modified portions are "merged", where possible.  That
      is, the changes from the repository are incorporated into the
      local changes in an intelligent way (if the diff application
      succeeds, then no conflict, else go to 3...)

   3. Where merging is not possible, a conflict is flagged, and *both*
      sides of the conflict are folded into the local file in such a
      way that it's easy for the developer to figure out what
      happened.  (And the old locally-modified file is saved under a
      temp name, just in case.)

It would be nice for Subversion to do things this way too;
unfortunately, that's not possible in every case.

CVS has a wonderfully simplifying limitation: it doesn't version
directories, so never has tree-structure conflicts.  Given that only
textual conflicts are possible, there is usually a natural way to
express both sides of a conflict -- just include the opposing texts
inside the file, delimited with conflict markers.  (Or for binary
files, make both versions available under temporary names.)

While Subversion can behave the same way for textual conflicts, the
situation is more complex for trees.  There is sometimes no way for a
working copy to reflect both sides of a tree conflict without being
more confusing than helpful.  How does one put "conflict markers" into
a directory, especially when what was a directory might now be a file,
or vice-versa?

Therefore, while Subversion does everything it can to fold conflicts
intelligently (doing at least as well as CVS does), in extreme cases
it is acceptable for the Subversion client to punt, saying in effect
"Your working copy is too out of whack; please move it aside, check
out a fresh one, redo your changes in the fresh copy, and commit from
that."  (This response may also apply to subtrees of the working copy,
of course).

Usually it offers more detail than that, too.  In addition to the
overall out-of-whackness message, it can say "Directory foo was
renamed to bar, conflicting with your new file bar; file blah was
deleted, conflicting with your local change to file blah, ..." and so
on.  The important thing is that these are informational only -- they
tell the user what's wrong, but they don't try to fix it
automatically.

All this is purely a matter of *client-side* intelligence.  Nothing in
the repository logic or protocol affects the client's ability to fold
conflicts.  So as we get smarter, and/or as there is demand for more
informative conflicting updates, the client's behavior can improve and
punting can become a rare event.  We should start out with a _simple_
conflict-folding algorithm initially, though.


Conflict/Merge Tables.
======================

The tables below describe how client and server behave in various
potential conflict scenarios.  Each intersection describes what
happens when one change meets another on the same entity.

   Table 1:   Direct changes   <==>   Indirect changes
   Table 2:   Indirect changes  <==>  Indirect changes
   Table 3:   Direct changes   <==>   Direct changes

In each cell

   C   means    "Conflict"
   M   means    "Mergeable"

The principles involved are symmetrical, so the immediate origin of
each change (working copy vs repository) doesn't matter.

Let's justify this claim of symmetry:

It's tempting to think of a change as being either "from" the working
copy or "in" the repository.  But the true source of a change is some
committer -- each change represents some developer's intention toward
a file or a tree, and a conflict is what happens when two intentions
are incompatible (or their compatibility cannot be automatically
determined).

It doesn't matter in what order the intentions were discovered, i.e.,
which has already made it into the repository versus which exists only
in someone's working copy.  Incompatibility is incompatibility,
independent of timing.

(BEN SEZ: Right!  No matter how you look at it, we're attempting to
merge two branches.  It's irrelevant that one branch happens to be the
"mainline" repository branch.  We may want to mention that all of the
following logic will still apply when we actually merge "official"
repository branches too.)

So what these tables really show is how to decide when two changes are
compatible.  They're a brute force guide to the changespace, mapping
each kind of change against each other kind of change, and telling
what happens in each scenario.

Following the tables are some scenarios that explore a few of the
intersections in depth.


          Table 1: Direct changes against indirect changes
          ************************************************

  [changes    |         d i r e c t     c h a n g e s
   on direc-  |
   tories]    |    self add         self remove        self rename
  ------------|------------------.---------------.-------------------.
              | C                .               .                   .
        child | (Must be really  .       C       .       M           .
         add  | out-of-date for  .               .                   .
  i           | this to happen!) .               .                   .
  n           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  d           |                  .               .                   .
  i     child |  C               .               .                   .
  r    remove |                  .       C       .       M           .
  e           | (Same as above.) .               .                   .
  c           |                  .               .                   .
  t           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
              |                  .               .                   .
  c     child |  C               .               .                   .
  h    rename |                  .       C       .       M           .
  a           | (Same as above.) .               .                   .
  n           |                  .               .                   .
  g           |. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e           |                  .               .                   .
  s     child |  C               .               .                   .
       modify |                  .       C       .       M           .
              | (Same as above.) .               .                   .
              |                  .               .                   .
              |. . . . . . . . . . . . . . . . . . . . . . . . . . . .


A note about Table 1: technically, it is possible for the horizontal
axis to include changes on files as well as directories.  But this
would mean a directory's type had changed to file, which would imply
an add or remove at some point in the past, and that would have
conflicted already (by columns one and two).


         Table 2: Indirect changes against indirect changes
         **************************************************

  [changes  |         i n d i r e c t     c h a n g e s
   on direc-|
   tories]  |  child add      child remove      child rename    child mod
  ----------|--------------.-----------------.-----------------.-------------.
  i         |              .                 .                 .             .
  n   child |  C if name   .  C if name      .  C if name      . C if name   .
  d    add  |  conflicts,  .  conflicts,     .  conflicts,     . conflicts,  .
  i         |  else M      .  else M         .  else M         . else M      .
  r         |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e         |              . commit: C if    .                 .             .
  c   child |  C if name   . name conflicts, .  C if name      . C if name   .
  t  remove |  conflicts,  . else M          .  conflicts,     . conflicts,  .
            |  else M      . update: M       .  else M         . else M      .
  c         |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  h         |              .                 .                 . commit: C   .
  a   child |  C if name   .  C if name      .  C if name      . if name     .
  n  rename |  conflicts,  .  conflicts,     .  conflicts,     . conflicts,  .
  g         |  else M      .  else M         .  else M         . else M      .
  e         |              .                 .                 . update: M   .
  s         |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            |              .                 . commit: C if    .             .
      child |  C if name   .  C if name      . name conflicts, .  commit: C  .
     modify |  conflicts,  .  conflicts,     . else M          .  update: M  .
            |  else M      .  else M         . update: M       .    or C     .
            |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .


[Yes, the table mirrors itself across the diagonal -- I filled in both
sides anyway, to see if my mind would come to the same conclusions for
the same intersections.  It did. :-) -kff]

(BEN SEZ:  [grin])

Notes about Table 2: "if name conflicts" means "if the same child name
is mentioned in both changes".  (It doesn't matter if it's oName or
nName; if it appears anywhere on both sides, it's a conflict.)

In a sense, the conflicts-on-name don't even need to be mentioned,
because the two child entities will directly conflict with each other
in Table 3 below.  However, if Table 2 is to show circumstances in
which indirect changes do not conflict, it needs to also mention the
one circumstance in which they would conflict, for contrast.


           Table 3: Direct changes against direct changes
           **********************************************

  [changes to |            d i r e c t     c h a n g e s
   any kind   |
   of entity] |   add          remove         rename         text change
  ------------|------------.-------------.---------------.-----------------.
              |            .             .               .  commit: C      .
      add     |            .             .               .                 .
  d           |    C       .     C       .     C         .  update: M      .
  i           |            .             .               .    or C         .
  r           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  e           |            . commit: C   .               .                 .
  c   remove  |            .             .               .                 .
  t           |    C       . update: M   .     C         .    C            .
              |            .             .               .                 .
  c           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  h           |            .             .  commit: C    .  commit: C      .
  a   rename  |            .             .               .                 .
  n           |    C       .     C       .  update: M    .  update: M      .
  g           |            .             .    or C       .                 .
  e           |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  s           | commit: C  .             .  commit: C    .  commit: C      .
      text    |            .             .               .                 .
      change  | update: M  .     C       .  update: M    .  update: M or C .
              |   or C     .             .               .                 .
              |. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .


Note about all three tables: Haven't thought carefully about how this
extends to directory *entries* as entities.  I think it works out, but
am not sure yet.


Scenarios.
----------

* Scenario 1:

  Client edits foo/bar.c, meanwhile in repos foo/ has been renamed to
  baz/.  Client commits.

  RESULT: success.  The only "meeting" of changes is indirect (change
  to child of foo/) vs direct (rename of foo/ to baz/).  Table 1 shows
  that this intersection does not conflict, so the server accepts the
  change.  Afterwards, repository:baz/bar.c matches wc:foo/bar.c

  If the client did an update inside foo/, changes to foo/* (baz/* in
  the repository) would show up, but foo/ would not be renamed.  If
  the client updated from above foo/, then foo/ would be renamed to
  baz/ in the working copy.

  --- Mirror image of Scenario 1 ---

  Client renames foo/ to baz/ locally.  Meanwhile, in the repository,
  there has been a change to foo/bar.c.

  If the client updates (either in baz/ or above it), baz/bar.c will
  be updated to the latest repository version of foo/bar.c.

  If the client commits the rename, that will succeed too, and Version
  N of foo/bar.c in the repository will be the same as Version N+1 of
  baz/bar.c.

  Here's an interesting question: what happens if some third client,
  who is way behind the times and has *none* of the above commits, now
  runs update inside foo/?  Clearly, she should get the change to
  foo/bar.c, even though that change is found as baz/bar.c in the
  repository.  How does the repository implement this?

  Well, 

* Scenario 2:

  Client has local changes to foo/bar.c; meanwhile, in the repository,
  foo/ has been renamed to baz/, *and* bar.c renamed to qux.c.

  If client tries to commit, it fails, by Table 3 (rename vs text
  change).  Note that the dir rename was not the problem.

  If client updates, it is mergeable, and either one or both renames
  will happen depending on what was updated.  The local edits are
  preserved in the rename.

  --- Mirror image of Scenario 2 ---
  
  Client renames foo/ to baz/, and foo/bar.c to baz/qux.c.  Meanwhile,
  in repository, foo/bar.c has changed.

  If client commits, it will fail (direct changes to bar.c<>qux.c), so
  client must update first.

  If client updates, qux.c receives the changes that applied to bar.c
  in the repository (by rename vs text change in Table 3).

* Scenario 3:

  

From Jim's original scenario:

/dir1/file1
      file2
      dir2/file3
           file4
      dir3/file5
