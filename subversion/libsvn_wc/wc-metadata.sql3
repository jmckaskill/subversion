/* wc-metadata.sql3 -- schema used in the wc-metadata SQLite database
 *
 * ====================================================================
 * Copyright (c) 2008 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */

/* ### the following tables define the BASE tree */

CREATE TABLE REPOSITORY (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  /* the UUID of the repository */
  uuid  TEXT NOT NULL,

  /* URL of the root of the repository */
  url  TEXT NOT NULL
  );

CREATE INDEX I_UUID ON REPOSITORY (uuid);


CREATE TABLE WORKING_COPY (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  /* foreign key to REPOSITORY.id */
  repos_id  INTEGER NOT NULL,

  /* absolute path in the local filesystem */
  local_path  TEXT NOT NULL,

  /* repository path corresponding to root of the working copy */
  repos_path  TEXT NOT NULL
  );

CREATE UNIQUE INDEX I_LOCAL_PATH ON WORKING_COPY (local_path);


CREATE TABLE DIRECTORY (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  wc_id  INTEGER NOT NULL,

  /* relative path from wcroot */
  local_relpath  TEXT NOT NULL,

  /* path in repository */
  /* ### for switched subdirs, this could point to something other than
     ### local_relpath would imply. anything else for switching? */
  repos_path  TEXT NOT NULL
  );

CREATE UNIQUE INDEX I_DIR_PATH ON DIRECTORY (wc_id, local_relpath);


CREATE TABLE NODE (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  dir_id  INTEGER NOT NULL,

  filename  TEXT,

  revnum  INTEGER NOT NULL,

  kind  INTEGER NOT NULL,

  text_id  INTEGER,

  /* ### NOT NULL? do we always have this info? */
  changed_rev  INTEGER,
  /* ### or use TEXT and ISO-8601 datetime? */
  changed_date  INTEGER,
  changed_author  TEXT,

  /* ### the following fields are used to define the WORKING tree */
  conflict_old  TEXT,
  conflict_new  TEXT,
  conflict_working  TEXT,
  prop_reject  TEXT,  /* ### is this right? */

  /* ### note: these are caches from the server! */
  lock_token  TEXT,
  lock_owner  TEXT,
  lock_comment  TEXT,
  lock_date  INTEGER,  /* ### or TEXT and ISO? */

  /* ### some text or prop changes exist. this node is in a changelist. */
  changelist_id  INTEGER
  );

CREATE UNIQUE INDEX I_PATH ON NODE (dir_id, filename);
CREATE INDEX I_NODELIST ON NODE (dir_id);
CREATE INDEX I_LOCKS ON NODE (lock_token);


CREATE TABLE PROPERTIES (
  node_id  INTEGER NOT NULL,

  name  TEXT NOT NULL,

  value  BLOB NOT NULL,

  PRIMARY KEY (node_id, name)
  );

CREATE UNIQUE INDEX I_NODE_PROPS ON PROPERTIES (node_id);


CREATE TABLE BASE_TEXT (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  checksum  TEXT NOT NULL,

  compression  INTEGER NOT NULL,

  /* ### do we need to deal with repos-size vs. eol-style-size? this
     ### size should be what is in ACTUAL so we can quickly detect
     ### differences. */
  actual_size  INTEGER NOT NULL,

  /* ### used to verify the pristine file is "proper" */
  stored_size  INTEGER NOT NULL,

  refcount INTEGER NOT NULL
  );

CREATE UNIQUE INDEX I_CHECKSUM ON BASE_TEXT (checksum);

/* ------------------------------------------------------------------------- */

/* ### the following tables define the WORKING tree */

/* ### add/delete nodes */
CREATE TABLE NODE_CHANGES (
  id  INTEGER PRIMARY KEY AUTOINCREMENT, 

  dir_id  INTEGER NOT NULL,

  filename  TEXT,

  /* ### NULL kind implies "deletion". or use a special enumerated value? */
  kind  INTEGER,

  copyfrom_repos_path  TEXT,
  copyfrom_revnum  INTEGER,

  changelist_id  INTEGER
  );

CREATE UNIQUE INDEX I_PATH_CHANGES ON NODE_CHANGES (dir_id, filename);
CREATE INDEX I_NODELIST_CHANGES ON NODE_CHANGES (dir_id);


CREATE TABLE PROPERTIES_CHANGES (
  dir_id  INTEGER NOT NULL,

  filename  TEXT NOT NULL,

  name  TEXT NOT NULL,

  /* ### NULL implies deletion. */
  value  BLOB,

  PRIMARY KEY (dir_id, filename, name)
  );

CREATE INDEX I_PROPS_CHANGES ON PROPERTIES_WORKING (dir_id, filename);


CREATE TABLE CHANGELIST (
  id  INTEGER PRIMARY KEY AUTOINCREMENT,

  wc_id  INTEGER NOT NULL,

  name  TEXT NOT NULL
  );

CREATE UNIQUE INDEX I_CHANGELIST ON CHANGELIST (wc_id, name);
CREATE UNIQUE INDEX I_CL_LIST ON CHANGELIST (wc_id);
