
What the client looks like right now:
=====================================

The client for milestone 1 is somewhat limited: it can checkout and
update from XML files, and commit to XML files.  The changes it can
make in a working copy are file mods and file adds.

So:

   svn checkout -d TARGETDIR --xml-file FILE.XML \
                --ancestor-path blah --version N
   svn update --xml-file FILE.XML
   svn add FILE
   svn delete [--force] FILE
   svn commit --xml-file FILE.XML --version N

You may be wondering why the --ancestor-path and --version are on the
command line.  Don't worry, they won't be in a real-life client.  The
issue right now is that the client and server aren't actually talking
to one another, so information that they would have exchanged has to
be passed manually, by a human (excuse me, I mean by a developer).

If you check out into TARGETDIR, that directory must exist and be
empty.



What the client will look like in real life:
============================================

We're trying to be similar to command-line CVS, but not suffocatingly
so.  Subversion will differ where it provides a feature CVS doesn't,
or doesn't provide something CVS does, or where people generally agree
that the CVS way is not successful and shouldn't be imitated.



Behaviors
=========

  The CVS custom of switching on a subcommand seems to work out pretty
  well, so we'll do the same thing.  But many people have mentioned that
  having separate global versus command-local option namespaces is
  confusing.  So Subversion has one option namespace, and all options
  come after the subcommand.
  
     svn [<subcommand>] [<option|argument> ...]
  
  (The subcommand is marked as optional because there are a few cases where
  Subversion can do something meaningful without the command -- for
  example, "svn --help".)
  
  
  All files are assumed binary by default.  If the user explicitly
  asks for it, she can get keyword substitution.  And, if she asks for
  it, she can get line-end conversion.  These two filters are
  completely independent of one another.

* Keyword substitution (on/off)

* end-of-line conversion (on/off)



Global options
==============

  -? -h -H --help  Help.
  -q               Quiet.  (CVS has two levels of this, but that's overkill?)
  -v VERSION       Like "cvs cmd -r REV"
  --version        Print program name, version, and url.
                     /* Problem: "--version" and "-v" are both
                        pronounced "version", but they mean different
                        things. */
  -V --verbose     Run with a wordily prolix verbositude.
  -D DATE          Like "cvs cmd -D DATE"
  -l               Local dir only, do not recurse.
  -d               Target directory (like "cvs checkout -d DIR")
  -f               Force (probably useful for a few commands)
  --dry-run        Like "cvs -n"
  --no-rc          Suppress reading of .svnrc.
  --trace          Like "cvs -t"
  --               End of option processing (this is the standard, right?)
                   (Yes, it is one of the standards) :)

  -R REPOSITORY    Use REPOSITORY.
                     /* Issue: -R may be unnecessary, if arguments
                        are URLs anyway.  See thoughts from Greg
                        Stein.  That would be nice, it would free up
                        another option letter. */



Subcommands and their Options
=============================

This is just a beginning.  We need to expand each command to describe
exactly what it does and what options it honors.  

The commands will look a lot like CVS's, though there are some
newcomers:

Summary: 

   checkout | co
   update   | up
   commit   | ci
   add      | ad | new
   rename   | mv
   delete   | del | rm
   copy     | cp
   branch  /* implemented via copy, though may want to be its own command */
   tag     /* implemented via copy, though may want to be its own command */
   status   | stat
   diff     | di | dif
   rdiff
   annotate | ann
   import   | im | imp
   log      | lo
   propset  | pset
   propget  | pget

   ===Karl: Why are some short commands 2 letters, some 3, and some 4?
            Would it be better to make them all 2 letters? -Fitz

*  checkout

*  update

*  commit

*  add

*  rename

*  delete

*  copy

*  branch  /* implemented via copy, though may want to be its own command */

*  tag     /* implemented via copy, though may want to be its own command */

*  status

*  diff

*  rdiff

*  annotate

*  import

*  log

*  propset

*  propget



Miscellaneous Notes and addenda
===============================


----------------------------------------------------------------------
Some very old ideas from Jim's notes.  Maybe you can figure it out.

* The Subversion Unix Client

We need:
- enhanced patch files (emulate Bitkeeper's format?)
- way to refer to common ancestor of two branches

** command syntax

LOCAL-DIR: name of a directory on the local filesystem
LOCAL-FILE: name of a file
LOCAL-NAME: either LOCAL-DIR or LOCAL-FILE

REMOTE-DIR: something of the form HOST:REPO:DIR
REMOTE-FILE: something of the form HOST:REPO:FILE
REMOTE-NAME: either REMOTE-DIR or REMOTE-FILE
   Also --- if you omit HOST:REPO, and just write :DIR or :FILE,
   that takes the HOST and REPO and the base directory from the
   current working directory.

DIR: either a LOCAL-DIR or a REMOTE-DIR
FILE: either a LOCAL-FILE or a REMOTE-FILE
NAME: either a LOCAL-NAME or a REMOTE-NAME

If a non-remote filename doesn't refer to something in a working
directory, Subversion signals an error.  However, you can change `NAME'
to `-plain NAME', and Subversion will go ahead and munge NAME, and not
worry about recording its history.  (I guess it should make .~n~ files.)

NAME:N refers to version N of NAME, or the difference between
        versions N-1 and N of NAME, depending on context.
NAME:N1:N2 refers to the difference between versions N1 and N2 of NAME.

If N is "base", then NAME:N refers to the base version of NAME.
If N is "tip", then NAME:N refers to the most recent version of NAME.
If N is "here", then NAME:N refers to the present sources.  This is
      only useful in forms using two version numbers, since NAME:here
      is equivalent to NAME.

Thus, `.:base:tip' is the set of atoms in the repository waiting to be
merged into your directory.  And `.:base:here' is the set of changes
in your working directory waiting to be committed.

svn add [-r] NAME...
svn mkdir NAME...
svn rm [-r] NAME...
svn mv NAME... DIR
svn mv NAME1 NAME2
svn cp [-r] NAME... DIR
svn cp [-r] NAME1 NAME2

`svn add', `svn rm', and `svn cp' complain if an argument is a
directory, and `-r' isn't given.  Just as a sanity check.

svn repo CMD ...
  Same as `svn CMD ...', except that filenames are taken to apply to
  the current directory's repository, by default.

svn checkout HOST:REPO:NAME
  Equivalent to `svn cp -r HOST:REPO:NAME -plain .'.

svn import NAME1 HOST:REPO:NAME2
  Equivalent to `svn cp -r -plain NAME1 HOST:REPO:NAME2'.

svn apply NAME1[:N1[:N2]] NAME2
  Apply changes specified by NAME1[:N1[:N2]] to NAME2.
  If NAME1 form, then 
  If NAME1:N1 form, then the change applied is the difference between
        versions N1-1 and N1.
  If NAME1:N1:N2 form, then the change applied is the difference between
        versions N1 and N2 of NAME1.

svn commit [FILE...]
  If omitted, FILE... defaults to `.'.
  For each FILE, do `svn apply FILE:base:here FILE:base'.

svn update [FILE...]
  If omitted, FILE... defaults to `.'.
  For each FILE, do `svn apply FILE:base:tip FILE'.

svn vert LOCAL-DIR REMOTE-DIR
  Turn LOCAL-DIR into a working directory with the tip of REMOTE-DIR
  as its base version, by sticking in the appropriate control files.

svn script CMD ...
  The same as "svn CMD ...", except that the rules for names are a
  little different, to help make scripts more reliable.  Colons lose
  their special meaning, so if the names of actual files processed by
  the script contain colons, things will still work.
  Instead of FOO:N, write -name:n FOO N
  Instead of FOO:N:M, write -name:n:m FOO N M
  Instead of HOST:REPO:FOO, write -remote:name HOST:REPO FOO
  and so on.

  If you actually do want colons in a name parsed normally (to handle an
  argument from a user, for example), you can write `-parsed NAME'.



Haven't revised these yet:
svn diff FILE ...
svn diff -r N FILE ...
svn diff -r N1 -r N2 FILE ...
svn diff -r DIR:N FILE ...
svn diff -r DIR1:N1 -r DIR2:N2 FILE ...
svn diff -r N1 -r N2 FILE:N3 ...

svn log
svn fix-log

----------------------------------------------------------------------
