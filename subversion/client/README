
What the client looks like right now:
=====================================

The client for milestone 1 is somewhat limited: it can checkout and
update from XML files, and commit to XML files.  The changes it can
make in a working copy are file mods and file adds.

So:

   svn checkout -d TARGETDIR --xml-file FILE.XML \
                --ancestor-path blah --version N
   svn update --xml-file FILE.XML
   svn add FILE
   svn delete [--force] FILE
   svn commit --xml-file FILE.XML --version N

You may be wondering why the --ancestor-path and --version are on the
command line.  Don't worry, they won't be in a real-life client.  The
issue right now is that the client and server aren't actually talking
to one another, so information that they would have exchanged has to
be passed manually, by a human (excuse me, I mean by a developer).

If you check out into TARGETDIR, that directory must exist and be
empty.



What the client will look like in real life:
============================================

We're trying to be similar to command-line CVS, but not suffocatingly
so.  Subversion will differ where it provides a feature CVS doesn't,
or doesn't provide something CVS does, or where people generally agree
that the CVS way is not successful and shouldn't be imitated.



Parsing Command-Line Arguments
==============================

The CVS custom of switching on a subcommand seems to work out pretty
well, so we'll do the same thing.  But many people have mentioned that
having separate global versus command-local option namespaces is
confusing.  So Subversion has one option namespace, and all options
come after the subcommand.

   svn [<subcommand>] [<option|argument> ...]

(The subcommand is marked as optional because there are a few cases where
Subversion can do something meaningful without the command -- for
example, "svn --help".)
  


Behaviors
=========
  
All files are assumed binary by default.  If the user explicitly
asks for it, she can get keyword substitution.  And, if she asks for
it, she can get line-end conversion.  These two filters are
completely independent of one another.

* Keyword substitution (on/off)

* End-of-line conversion (on/off)

* Check for conflict markers/state prior to checkin (on/off)

* Will we provide anything like the most basic tasks that .cvswrappers does?


Common options
==============

  /* While these are listed under `common options', we would probably
   be well-served to document which subcommands support which
   options. -Fitz */


  -? -h -H --help  Help.
  -q               Quiet.  (CVS has two levels of this, but that's overkill?)
                   (Yes, overkill. -Fitz)  
  -v VERSION       Like "cvs cmd -r REV"
  --version        Print program name, version, and url.
                     /* Problem: "--version" and "-v" are both
                        pronounced "version", but they mean different
                        things. */
  -V --verbose     Run with a wordily prolix verbositude.
  -D DATE          Like "cvs cmd -D DATE"
  -l               Local dir only, do not recurse. 
                   (-R doesn't apply as it is the default behavior)
  -d               Target directory (like "cvs checkout -d DIR")
  -f               Force (probably useful for a few commands)
  -m               Use "message" for the creation log.
  -F file          Read the log message from file.

  -p               Check out/update/whatever files to standard output 
                   (avoids stickiness).

  --dry-run        Like "cvs -n"
  --no-rc          Suppress reading of .svnrc.
  --trace          Like "cvs -t"
  --               End of option processing (this is the standard, right?)
                   (Yes, it is one of the standards) :)


  -R REPOSITORY    Use REPOSITORY.
                     /* Issue: -R may be unnecessary, if arguments
                        are URLs anyway.  See thoughts from Greg
                        Stein.  That would be nice, it would free up
                        another option letter. */



Subcommands and their Options
=============================

This is just a beginning.  We need to expand each command to describe
exactly what it does and what options it honors.  

The commands will look a lot like CVS's, though there are some
newcomers:

Summary: 

   checkout | co
   update   | up
   commit   | ci
   add      | ad | new
   rename   | mv
   delete   | rm | del
   copy     | cp
   branch  /* implemented via copy, though may want to be its own command */
   tag     /* implemented via copy, though may want to be its own command */
   status   | st | stat
   diff     | di | dif
   rdiff
   annotate | an | ann
   import   | im | imp
   log      | lo
   propset  | ps | pset
   propget  | pg | pget
   apply    | ap
   merge    | me
   convert  | cv
   sync     | sy
   repo

NOTE: For now, I am not including Common Options in the usage
      statements for each subcommand -Fitz


  checkout
  ========

  Usage: svn checkout [-N] [-c] [-s] modules...

    -N    Don't shorten module paths if -d specified.
    /* This feels *weird* to me. Why use -d if you don't want things short? */


    Module specific commands 
    /* I entertained the thought of making
       `modules' a subcommand and merge the following--thoughts? -Fitz */

    -c    "cat" the module database.
    -s    Like -c, but include module status.
 
/* Do these apply to svn? 
 *  -A    Reset any sticky tags/date/kopts. 
 *  -f    Force a head revision match if tag/date not found. 
 *  -P    Prune empty directories.
 *  -n    Do not run module program (if any).
 */



  update
  ======

  Usage: svn update [-C] [--dirs] [-I ign] files...

    -C    Overwrite locally modified files with clean repository copies.
    --dirs    Build directories, like checkout does.

    -I ign    More files to ignore (! to reset).

/* Do these apply to svn? 
 *  -A    Reset any sticky tags/date/kopts.
 *  -P    Prune empty directories.
 *  -f    Force a head revision match if tag/date not found.
 *  -W spec    Wrappers specification line.
 */
 

  commit
  ======

  Usage: svn commit files...

- Looks like all these guys have moved to Common Options.
 
/* Do these apply to svn? 
 *  -n    Do not run the module program (if any).
 *  -f    Force the file to be committed; disables recursion.
 *        (We're not dealing with revisions anymore, so this should 
 *         be deprecated)  
 */


  add
  === 

  Usage: svn add files...

- Looks like all these guys have moved to Common Options.


  rename
  ======

  Usage: svn rename FILE1 FILE2

  This command is syntactic sugar for 'svn repo mv FILE1 FILE2', no?

 

  delete
  ======
 
  Usage: cvs remove [-f] files...

    -f    Delete the file before removing it.


  copy
  ====
 
  /* I fell asleep here */

  branch  /*  implemented via copy, though may want to be its own command */
  ======
 
  tag     /* implemented via copy, though may want to be its own command */
  ===
 
  status
  ======
 
  diff
  ====
 
  rdiff
  =====
 
  annotate
  ========
 
  import
  ======
 
  log
  ===
 
  propset
  =======
 
  propget
  =======

  apply
  =====

  merge
  =====

    -j rev    Merge in changes made between current revision and rev. 
    /* Taken from update */

  convert
  =======

svn convert local-dir remote-dir

(svn vert)


  repo
  ====



  sync
  ====

This is going to take a bit of explaining. Imagine an intelligent
update that knows to add new files and remove files that you've
removed, and all recursively (without having to svn add, svn rm, ad
nauseam). More to come!


Miscellaneous Notes and addenda
===============================



----------------------------------------------------------------------
Some very old ideas from Jim's notes.  Maybe you can figure it out.

* The Subversion Unix Client

We need:
- enhanced patch files (emulate Bitkeeper's format?)
- way to refer to common ancestor of two branches

** command syntax

LOCAL-DIR: name of a directory on the local filesystem
LOCAL-FILE: name of a file
LOCAL-NAME: either LOCAL-DIR or LOCAL-FILE

REMOTE-DIR: something of the form HOST:REPO:DIR
REMOTE-FILE: something of the form HOST:REPO:FILE
REMOTE-NAME: either REMOTE-DIR or REMOTE-FILE
   Also --- if you omit HOST:REPO, and just write :DIR or :FILE,
   that takes the HOST and REPO and the base directory from the
   current working directory.

DIR: either a LOCAL-DIR or a REMOTE-DIR
FILE: either a LOCAL-FILE or a REMOTE-FILE
NAME: either a LOCAL-NAME or a REMOTE-NAME

If a non-remote filename doesn't refer to something in a working
directory, Subversion signals an error.  However, you can change `NAME'
to `-plain NAME', and Subversion will go ahead and munge NAME, and not
worry about recording its history.  (I guess it should make .~n~ files.)

NAME:N refers to version N of NAME, or the difference between
        versions N-1 and N of NAME, depending on context.
NAME:N1:N2 refers to the difference between versions N1 and N2 of NAME.

If N is "base", then NAME:N refers to the base version of NAME.
If N is "tip", then NAME:N refers to the most recent version of NAME.
If N is "here", then NAME:N refers to the present sources.  This is
      only useful in forms using two version numbers, since NAME:here
      is equivalent to NAME.

Thus, `.:base:tip' is the set of atoms in the repository waiting to be
merged into your directory.  And `.:base:here' is the set of changes
in your working directory waiting to be committed.

svn add [-r] NAME...
svn mkdir NAME...
svn rm [-r] NAME...
svn mv NAME... DIR
svn mv NAME1 NAME2
svn cp [-r] NAME... DIR
svn cp [-r] NAME1 NAME2

`svn add', `svn rm', and `svn cp' complain if an argument is a
directory, and `-r' isn't given.  Just as a sanity check.

svn repo CMD ...
  Same as `svn CMD ...', except that filenames are taken to apply to
  the current directory's repository, by default.

svn checkout HOST:REPO:NAME
  Equivalent to `svn cp -r HOST:REPO:NAME -plain .'.

svn import NAME1 HOST:REPO:NAME2
  Equivalent to `svn cp -r -plain NAME1 HOST:REPO:NAME2'.

svn apply NAME1[:N1[:N2]] NAME2
  Apply changes specified by NAME1[:N1[:N2]] to NAME2.
  If NAME1 form, then 
  If NAME1:N1 form, then the change applied is the difference between
        versions N1-1 and N1.
  If NAME1:N1:N2 form, then the change applied is the difference between
        versions N1 and N2 of NAME1.

svn commit [FILE...]
  If omitted, FILE... defaults to `.'.
  For each FILE, do `svn apply FILE:base:here FILE:base'.

svn update [FILE...]
  If omitted, FILE... defaults to `.'.
  For each FILE, do `svn apply FILE:base:tip FILE'.

svn vert LOCAL-DIR REMOTE-DIR
  Turn LOCAL-DIR into a working directory with the tip of REMOTE-DIR
  as its base version, by sticking in the appropriate control files.

svn script CMD ...
  The same as "svn CMD ...", except that the rules for names are a
  little different, to help make scripts more reliable.  Colons lose
  their special meaning, so if the names of actual files processed by
  the script contain colons, things will still work.
  Instead of FOO:N, write -name:n FOO N
  Instead of FOO:N:M, write -name:n:m FOO N M
  Instead of HOST:REPO:FOO, write -remote:name HOST:REPO FOO
  and so on.

  If you actually do want colons in a name parsed normally (to handle an
  argument from a user, for example), you can write `-parsed NAME'.



Haven't revised these yet:
svn diff FILE ...
svn diff -r N FILE ...
svn diff -r N1 -r N2 FILE ...
svn diff -r DIR:N FILE ...
svn diff -r DIR1:N1 -r DIR2:N2 FILE ...
svn diff -r N1 -r N2 FILE:N3 ...

svn log
svn fix-log

----------------------------------------------------------------------



For reference, I have included below the current command line options
(global and command local) for CVS.  -Fitz
--------------------8-<-------cut-here---------8-<-----------------------

CVS global options (specified before the command name) are:
    -H           Displays usage information for command.
    -Q           Cause CVS to be really quiet.
    -q           Cause CVS to be somewhat quiet.
    -r           Make checked-out files read-only.
    -w           Make checked-out files read-write (default).
    -l           Turn history logging off.
    -n           Do not execute anything that will change the disk.
    -t           Show trace of program execution -- try with -n.
    -v           CVS version and copyright.
    -T tmpdir    Use 'tmpdir' for temporary files.
    -e editor    Use 'editor' for editing log information.
    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.
    -f           Do not use the ~/.cvsrc file.
    -z #         Use compression level '#' for net traffic.
    -a           Authenticate all net traffic.
    -s VAR=VAL   Set CVS user variable.
(Specify the --help option for a list of other help options)



====================== add
Usage: cvs add [-k rcs-kflag] [-m message] files...
    -k    Use "rcs-kflag" to add the file with the specified kflag.
    -m    Use "message" for the creation log.
====================== admin
Usage: cvs admin rcs-options files...
====================== annotate
Usage: cvs annotate [-lRf] [-r rev|-D date] [files...]
    -l    Local directory only, no recursion.
    -R    Process directories recursively.
    -f    Use head revision if tag/date not found.
    -r rev    Annotate file as of specified revision/tag.
    -D date    Annotate file as of specified date.
(Specify the --help global option for a list of other help options)
====================== checkout
Usage:
  cvs checkout [-ANPRcflnps] [-r rev | -D date] [-d dir]
    [-j rev1] [-j rev2] [-k kopt] modules...
    -A    Reset any sticky tags/date/kopts.
    -N    Don't shorten module paths if -d specified.
    -P    Prune empty directories.
    -R    Process directories recursively.
    -c    "cat" the module database.
    -f    Force a head revision match if tag/date not found.
    -l    Local directory only, not recursive
    -n    Do not run module program (if any).
    -p    Check out files to standard output (avoids stickiness).
    -s    Like -c, but include module status.
    -r rev    Check out revision or tag. (implies -P) (is sticky)
    -D date    Check out revisions as of date. (implies -P) (is sticky)
    -d dir    Check out into dir instead of module name.
    -k kopt    Use RCS kopt -k option on checkout.
    -j rev    Merge in changes made between current revision and rev.
====================== commit
Usage: cvs commit [-nRlf] [-m msg | -F logfile] [-r rev] files...
    -n    Do not run the module program (if any).
    -R    Process directories recursively.
    -l    Local directory only (not recursive).
    -f    Force the file to be committed; disables recursion.
    -F file    Read the log message from file.
    -m msg    Log message.
    -r rev    Commit to this branch or trunk revision.
====================== diff
Usage: cvs diff [-lNR] [rcsdiff-options]
    [[-r rev1 | -D date1] [-r rev2 | -D date2]] [files...] 
    -l    Local directory only, not recursive
    -R    Process directories recursively.
    -D d1    Diff revision for date against working file.
    -D d2    Diff rev1/date1 against date2.
    -N    include diffs for added and removed files.
    -r rev1    Diff revision for rev1 against working file.
    -r rev2    Diff rev1/date1 against rev2.
    --ifdef=arg    Output diffs in ifdef format.
(consult the documentation for your diff program for rcsdiff-options.
The most popular is -c for context diffs but there are many more).
====================== edit
Usage: cvs edit [-lR] [files...]
-l: Local directory only, not recursive
-R: Process directories recursively
-a: Specify what actions for temporary watch, one of
    edit,unedit,commit,all,none
====================== editors
Usage: cvs editors [-lR] [files...]
    -l    Process this directory only (not recursive).
    -R    Process directories recursively.
====================== export
Usage: cvs export [-NRfln] [-r rev | -D date] [-d dir] [-k kopt] module...
    -N    Don't shorten module paths if -d specified.
    -f    Force a head revision match if tag/date not found.
    -l    Local directory only, not recursive
    -R    Process directories recursively (default).
    -n    Do not run module program (if any).
    -r rev    Export revision or tag.
    -D date    Export revisions as of date.
    -d dir    Export into dir instead of module name.
    -k kopt    Use RCS kopt -k option on checkout.
====================== history
Usage: cvs history [-report] [-flags] [-options args] [files...]

   Reports:
        -T              Produce report on all TAGs
        -c              Committed (Modified) files
        -o              Checked out modules
        -m <module>     Look for specified module (repeatable)
        -x [TOEFWUCGMAR] Extract by record type
        -e              Everything (same as -x, but all record types)
   Flags:
        -a              All users (Default is self)
        -l              Last modified (committed or modified report)
        -w              Working directory must match
   Options:
        -D <date>       Since date (Many formats)
        -b <str>        Back to record with str in module/file/repos field
        -f <file>       Specified file (same as command line) (repeatable)
        -n <modulename> In module (repeatable)
        -p <repos>      In repository (repeatable)
        -r <rev/tag>    Since rev or tag (looks inside RCS files!)
        -t <tag>        Since tag record placed in history file (by anyone).
        -u <user>       For user name (repeatable)
        -z <tz>         Output for time zone <tz> (e.g. -z -0700)
====================== import
Usage: cvs import [-d] [-k subst] [-I ign] [-m msg] [-b branch]
    [-W spec] repository vendor-tag release-tags...
    -d    Use the file's modification time as the time of import.
    -k sub    Set default RCS keyword substitution mode.
    -I ign    More files to ignore (! to reset).
    -b bra    Vendor branch id.
    -m msg    Log message.
    -W spec    Wrappers specification line.
====================== init
Usage: cvs init
====================== log
Usage: cvs log [-lRhtNb] [-r[revisions]] [-d dates] [-s states]
    [-w[logins]] [files...]
    -l    Local directory only, no recursion.
    -R    Only print name of RCS file.
    -h    Only print header.
    -t    Only print header and descriptive text.
    -N    Do not list tags.
    -b    Only list revisions on the default branch.
    -r[revisions]    Specify revision(s)s to list.
    -d dates    Specify dates (D1<D2 for range, D for latest before).
    -s states    Only list revisions with specified states.
    -w[logins]    Only list revisions checked in by specified logins.
====================== login
Usage: cvs login
====================== logout
Usage: cvs logout
====================== rdiff
Usage: cvs rdiff [-flR] [-c|-u] [-s|-t] [-V %d]
    -r rev|-D date [-r rev2 | -D date2] modules...
    -f    Force a head revision match if tag/date not found.
    -l    Local directory only, not recursive
    -R    Process directories recursively.
    -c    Context diffs (default)
    -u    Unidiff format.
    -s    Short patch - one liner per file.
    -t    Top two diffs - last change made to the file.
    -D date    Date.
    -r rev    Revision - symbolic or numeric.
    -V vers    Use RCS Version "vers" for keyword expansion.
====================== release
Usage: cvs release [-d] directories...
    -d    Delete the given directory.
====================== remove
Usage: cvs remove [-flR] [files...]
    -f    Delete the file before removing it.
    -l    Process this directory only (not recursive).
    -R    Process directories recursively.
====================== rtag
Usage: cvs rtag [-aflRnF] [-b] [-d] [-r rev|-D date] tag modules...
    -a    Clear tag from removed files that would not otherwise be tagged.
    -f    Force a head revision match if tag/date not found.
    -l    Local directory only, not recursive
    -R    Process directories recursively.
    -n    No execution of 'tag program'
    -d    Delete the given Tag.
    -b    Make the tag a "branch" tag, allowing concurrent development.
    -r rev    Existing revision/tag.
    -D    Existing date.
    -F    Move tag if it already exists
====================== status
Usage: cvs status [-vlR] [files...]
    -v    Verbose format; includes tag information for the file
    -l    Process this directory only (not recursive).
    -R    Process directories recursively.
====================== tag
Usage: cvs tag [-lRF] [-b] [-d] [-c] [-r rev|-D date] tag [files...]
    -l    Local directory only, not recursive.
    -R    Process directories recursively.
    -d    Delete the given tag.
    -r rev    Existing revision/tag.
    -D    Existing date.
    -f    Force a head revision if specified tag not found.
    -b    Make the tag a "branch" tag, allowing concurrent development.
    -F    Move tag if it already exists.
    -c    Check that working files are unmodified.
====================== unedit
Usage: cvs unedit [-lR] [files...]
-l: Local directory only, not recursive
-R: Process directories recursively
====================== update
Usage: cvs update [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]
    [-I ign] [-W spec] [files...]
    -A    Reset any sticky tags/date/kopts.
    -P    Prune empty directories.
    -C    Overwrite locally modified files with clean repository copies.
    -d    Build directories, like checkout does.
    -f    Force a head revision match if tag/date not found.
    -l    Local directory only, no recursion.
    -R    Process directories recursively.
    -p    Send updates to standard output (avoids stickiness).
    -k kopt    Use RCS kopt -k option on checkout.
    -r rev    Update using specified revision/tag (is sticky).
    -D date    Set date to update from (is sticky).
    -j rev    Merge in changes made between current revision and rev.
    -I ign    More files to ignore (! to reset).
    -W spec    Wrappers specification line.
====================== watch
Usage: cvs watch [on|off|add|remove] [-lR] [-a action] [files...]
on/off: turn on/off read-only checkouts of files
add/remove: add or remove notification on actions
-l (on/off/add/remove): Local directory only, not recursive
-R (on/off/add/remove): Process directories recursively
-a (add/remove): Specify what actions, one of
    edit,unedit,commit,all,none
====================== watchers
Usage: cvs watchers [-lR] [files...]
    -l    Process this directory only (not recursive).
    -R    Process directories recursively.
--------------------8-<-------cut-here---------8-<-----------------------
