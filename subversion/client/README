Emacs, please be in -*-text-*- mode.  Danke!

What the client looks like right now:
=====================================

The client for milestone 1 is somewhat limited: it can checkout and
update from XML files, and commit to XML files.  The changes it can
make in a working copy are file mods and file adds.  Local mods are
not preserved in updates.

So:

   svn checkout -d TARGETDIR --xml-file FILE.XML \
                --ancestor-path blah --version N
   svn add FILE
   svn delete [--force] FILE
   svn commit --xml-file FILE.XML --version N
   svn update --xml-file FILE.XML --version N

You may be wondering why the --ancestor-path and --version are on the
command line.  Don't worry, they won't be in a real-life client.  The
issue right now is that the client and server aren't actually talking
to one another, so information that they would have exchanged has to
be passed manually, by a human (excuse me, I mean by a developer).

If you check out into TARGETDIR, that directory must exist and be
empty.

Also, because update is taking input only from an XML file, it doesn't
yet know enough to be able to update the version numbers of
directories in which nothing changed, even though a real update might
do so.  The issue is that sometimes the user may restrict the update
to a few files, and sometimes do it across the whole tree.  In the
latter kind of update, one can safely set version numbers everywhere
afterwards; but in the former, only the version numbers of the updated
entities may be set.  Since the client doesn't yet distinguish between
selective and non-selective updates, it just sets the version numbers
of entities that received updates, and their ancestors.  Obviously,
things will be more sophisticated when we have selective updates.

If you want to see the milestone 1 client in action, run "make check"
in this directory.  That runs the tests/svn-test.sh script, which see
for details of piping to and from xml files.



What the client will look like in real life:
============================================

We're trying to be similar to command-line CVS, but not suffocatingly
so.  Subversion will differ where it provides a feature CVS doesn't,
or doesn't provide something CVS does, or where people generally agree
that the CVS way is not successful and shouldn't be imitated.

Note that since we're not building on top of RCS and directories are
first class citizens, a lot of options just disappear. If you are
concerned that a particular body of functionality is not in Subversion
1.0, don't get upset, just mail dev@subversion.tigris.org and we'll
talk about it like the civilized human beings that we all hope to be
one day. :)


Parsing Command-Line Arguments
==============================

The CVS custom of switching on a subcommand seems to work out pretty
well, so we'll do the same thing.  But many people have mentioned that
having separate global versus command-local option namespaces is
confusing.  So Subversion has one option namespace, and all options
come after the subcommand.

   svn  [<subcommand>]  [<option> ...]  [<argument> ...]

Notes: the subcommand is marked as optional because there are a few
cases where Subversion can do something meaningful without the
command, for example, "svn --help".

Also, it would be nice for options and arguments to be mixable, but
it's not necessary (CVS doesn't permit this, for example).  We
shouldn't block on that functionality right now, as it can always be
added later without breaking backwards-compatibility.
  


Behaviors
=========
  
All files are assumed binary by default.  If the user explicitly
asks for it, she can get keyword substitution.  And, if she asks for
it, she can get line-end conversion.  These two filters are
completely independent of one another.

* Keyword substitution (on/OFF) per filesystem object. Children of
  directories inherit this property.

* End-of-line conversion (on/OFF) per filesystem object. Children of
  directories inherit this property.

* Check for conflict markers in working copy files prior to checkin
  (ON/off) per filesystem object. Children of directories inherit this
  property. TODO SURVEY

* .svnfiletypespecifics file. SVN will implement basic .cvswrapper
  functionality (only that related to file types determined by regular
  expressions. This may happen in .svnfiletypespecifics or in
  .svnrc. TODO SURVEY


Options
==============

* Options 

  This lists *all* command line options available to the subversion 
  client. Options that are command specific (that is, available only
  to a single command are noted as such)

  -? -h -H --help                Help.
      
  -V --verbosity KEY             [quiet|progress|verbose|pontifical]
                                 Determines the level of spewage that the
                                 client gives (progress is the default)
      
  -D --date DATESPEC             Like "cvs cmd -D DATESPEC"
      
  -v --version VER               Like "cvs -r" Subversion does not have revisions,
                                 we have versions. Multiple version #s are
                                 separated by a `,'
      
  -l --local-dir                 Local; run only in current working directory.
      
     --recursive                 Operate recursively (default).
      
  -d --destination DEST          Target directory (like "cvs checkout -d DEST")
      
  -f --force                     Force. 
      
  -m --message MSG               Use "MSG" for the log message
      
  -F --msg-file FILE             Read the log message from FILE.
              
  -p --stdout                    Check out/update/whatever files to standard output 
              
  -n --dry-run                   Like "cvs -n" 
      
     --no-rc                     Suppress reading of .svnrc.
              
  -e --editor EDITOR             Edit messages with EDITOR.
      
     --read-only                 Make new working files read-only.
      
     --writable                  Make new working files read-write (default)
      
     --                          End of option processing

  -I --ignore GLOB               Ignore entities whose names match GLOB

  -K --keywords GLOB             Expand keywords in files whose names match GLOB.

  -L --line-conversion GLOB      Do line-end conversion for files matching GLOB.

* Aliases (shorthand for commonly used options and option combinations)

  -q --quiet                     alias for --verbose=quiet
  -T --text-defaults GLOB        alias for '-L GLOB -K GLOB'



Subcommands
===========

The commands will look a lot like CVS's, though there are some
newcomers:

Summary: 

   add      | ad | new
   annotate | an | ann
   apply    | ap
   branch   | br
   checkout | co
   commit   | ci
   convert  | cv
   copy     | cp
   delete   | rm | del
   diff     | di | dif
   import   | im | imp
   keyword  | kw | key
   log      | lo
   merge    | me
   propget  | pg | pget
   propset  | ps | pset
   rdiff    | rd
   rename   | mv | move
   repo     | rp
   status   | st | stat
   tag      | tg
   update   | up

NOTE: For now, I am not including Options in the usage
      statements for each subcommand. Once this document becomes a bit
      less fluid, we should document them for each subcommand as the
      behaviors of the Options may have subtle differences
      depending on the subcommand -Fitz


  checkout
  ========

  Usage: svn checkout URL
  
  This checks out a working copy from a repository. 

  e.g. svn checkout http://svn.tigris.org/repository1/subversion


  update
  ======

  Usage: svn update [-b PATH] [[FILE|DIR] ...]

  This updates your working copy from the repository.
  If PATH is specified, update based on PATH in the repository (Which
  is presumed to share a lot of ancestry with the current working copy).

  e.g. svn update foo.c bar.h baz/ bat/*.m 
       svn update -b /some/branch/path

  commit
  ======

  Usage: svn commit [[FILE|DIR] ...]

  Commit changes from your working copy into the repository.

  e.g. svn commit foo.c bar.h baz/ bat/*.m 


  add
  === 

  Usage: svn add [[FILE|DIR] ...]

  Add files/directories to your working copy. Commit will check them
  into the repository.

  e.g. svn add foo.c bar.h baz/ bat/*.m 


  rename
  ======

  Usage: svn rename FILE1 FILE2

  This command moves files/directories within your working copy. When
  you commit after doing this, the files/directories are moved within
  the repository (thus retaining all ancestry and version
  history). 
 
  e.g. svn rename foo.c bar.c 

  Note that this command behaves in the way that unix `mv' does:

  $ ls
    foo.c bar/

  $ svn rename foo.c bar

  $ ls
    bar/

  $ ls bar
    foo.c


  delete
  ======
 
  Usage: svn remove [[FILE|DIR] ...]

  Marks FILE|DIR for deletion upon commit. When you commit, the file
  will be marked as deleted in the repository and deleted from your
  working copy. TODO SURVEY

  "I for one abhor cvs's current behavior for cvs rm" -Fitz
  "I for two abhor cvs's current behavior for cvs rm" -Karl


  copy
  ====
  
  Usage: svn copy SOURCE DESTINATION

  Where SOURCE and DESTINATION can be directories or files. `copy' is
  used where you want to make a copy of SOURCE so that DESTINATION
  will share ancestry of SOURCE. Unless DESTINATION is a directory,
  DESTINATION must not exist (In the spirit of unix cp, SOURCE will be
  placed inside of DESTINATION if DESTINATION is a directory).

  e.g. If you do this (MAINTAIN ANCESTRY)

  $ svn copy foo.c bar.c

  Then foo.c and bar.c will share a common ancestor in the repository.

  But, if you do this (NO ANCESTRY)

  $ cp foo.c bar.c 
  $ svn add bar.c
  $ svn ci -m "Initial Import"

  Then you will have the identical file in your working copy, but
  bar.c will have no revision history beyond the initial import that
  you just did.


  tag
  ===

  Usage: svn tag PATH

  Create a configuration in the repository at PATH, mirroring the tree
  in the working copy and based on the versions found there.

  TODO: this needs to be documented _very_ thoroughly.  These are not
  much like CVS tags.
 
 
  status
  ======

  Usage: svn status [[FILE|DIR] ...]

  Print out the status of each file (noting what --verbosity is set to
  and behaving accordingly).


  diff
  ====

  Usage: svn diff [svn-diff-opts/args]

  This is like cvs diff. Anyone have anything to add?


  rdiff
  =====

  Usage: svn rdiff URL1 URL2

  Exactly the same as diff, but takes 2 URLs and requires no working
  copy.

  e.g. svn rdiff http://svn.tigris.org/1999-10-23-alpha \
                 http://svn.tigris.org/2000-05-19-beta


  annotate
  ========

  This is like cvs annotate. Anyone have anything to add?
 

  import
  ======
 
  Usage: svn import URL [-I GLOB] [-K GLOB] [-L GLOB] [-T GLOB]

  Import something new into the repository

  e.g. svn import http://svn.tigris.org/blahblah -I '*.jpg' -T '*.txt *.c *.h'


  log
  ===
 
  Usage: svn log [-D DATESPEC] [-v VERSPEC] [[FILE|DIR] ...]

  Show log messages (and affected entities) for commits in which any
  of the entities in question changed.  If none were specified, then
  recursive inclusion is the default.  The set of messages can be
  further restricted by a date or version range specification.


  propset
  =======

  TODO Talk to ben about this

   TODO
   deal with keyword substitution and end-of-line conversion. We can
   make aliases for these 2 particular functions in the future. For
   example:

   svn key STATE FILE
   svn eol STATE FILE
 

  propget
  =======

  TODO talk to ben about this


  merge
  =====

  Merge is identifies some set of diffs (likely from a branch) and
  applies them to your current working copy. merge ONLY changes your
  working copy, not the repository. The repository is changed when you
  commit.

    /* Taken from update */
    -v ver    Merge in changes made between current revision and ver. 

  Note: Merges cannot happen in the repository. The repository has no
  way to resolve conflicts, so all merges have to be done in a working
  copy. If you don't have a working copy for your trunk and your
  branch, you can't merge (for now). In the future, there's no reason
  why your branch can't be a URL (a reference directly to the repository). 

  TODO This is related to the ancestry sets mentioned in the spec and
  must be described in careful detail. 


